<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用游戏框架</title>
    <url>/2023/04/06/javaGame/%E5%B8%B8%E7%94%A8%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h1><ol>
<li>ecs [^文章]</li>
<li>服务器架构[^常用的]</li>
</ol>
<h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="1-同步机制"><a href="#1-同步机制" class="headerlink" title="1. 同步机制"></a>1. 同步机制</h3><blockquote>
<ul>
<li><p>帧同步  moba atc game </p>
<p>按帧同步客户端所有协议给所有玩家</p>
<p>每个客户端都在执行相同的操作，所以最后的结果一样。</p>
<p>需要使用定点数，当你的逻辑中使用了浮点数的时候，因为每一台机器的不同，浮点最后的有效值其实是不一样的，所以为了保证逻辑的同步性，再游戏逻辑中，需要使用定点数。</p>
</li>
<li><p>状态同步 mmo等</p>
<p>状态改变再同步</p>
</li>
<li><p>状态帧同步 fps游戏</p>
<p>状态帧同步就是状态同步和帧同步的概念相结合。客户端向服务器上传操作，服务器跑逻辑，但是又在按照固定的每一帧下发所有玩家的状态（属性位置等）给每一个客户端实现同步。</p>
</li>
</ul>
</blockquote>
<h3 id="2-定点数-浮点数"><a href="#2-定点数-浮点数" class="headerlink" title="2. 定点数 浮点数"></a>2. 定点数 浮点数</h3><ul>
<li><p>帧同步中 定点数 作为一个标准存在</p>
<p>定点数小数 [^计算方式]</p>
<p><img src="C:\Users\sunjusong1\AppData\Roaming\Typora\typora-user-images\image-20230406112247469.png" alt="image-20230406112247469"></p>
</li>
</ul>
<p>计算方式和整数一样</p>
<ul>
<li>浮点数 定点化</li>
</ul>
<p>  java 可以用bigdecimal</p>
<p>  浮点数的定点化 [^设计用例]</p>
<p>　IEEE 754 规定，浮点数的表示方法为：</p>
<p><img src="https://pic3.zhimg.com/80/v2-b5d44cc4d1f293d07826fc052b20213c_720w.jpg?source=1940ef5c" alt="img"></p>
<p>　　最高的 1 位是符号位 s，接着的 8 位是指数E，剩下的 23 位为有效数字 M。</p>
<h1 id="ECS框架-和-传统编程方式"><a href="#ECS框架-和-传统编程方式" class="headerlink" title="ECS框架 和 传统编程方式"></a>ECS框架 和 传统编程方式</h1><blockquote>
<p>主要说明ecs框架 部分内容会带出区别</p>
</blockquote>
<p>守望先锋框架使用了这个模式[^守望先锋的架构和网络]</p>
<h2 id="什么是ECS"><a href="#什么是ECS" class="headerlink" title="什么是ECS"></a>什么是ECS</h2><p>Entity Component System (ECS) 是一个 gameplay 层面的框架，它是建立在渲染引擎、物理引擎之上的，主要解决的问题是如何建立一个模型来处理游戏对象 (Game Object) 的更新操作。</p>
<h3 id="Entity（实体，本质上是存放组件的容器）"><a href="#Entity（实体，本质上是存放组件的容器）" class="headerlink" title="Entity（实体，本质上是存放组件的容器）"></a>Entity（实体，本质上是存放组件的容器）</h3><p>可以说就是传统引擎中的 Game Object 。但在这个系统下，它仅仅是 C&#x2F;Component 的组合。它的意义在于生命期管理。</p>
<h3 id="System（系统，根据组件数据处理逻辑状态的管理器）"><a href="#System（系统，根据组件数据处理逻辑状态的管理器）" class="headerlink" title="System（系统，根据组件数据处理逻辑状态的管理器）"></a>System（系统，根据组件数据处理逻辑状态的管理器）</h3><p>C 和 S 是这个框架的核心。System 系统（或者模块）对于游戏来说，每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。它也不一定关心游戏世界中的所有对象，比如关心那些不参与碰撞的装饰物。所以对每个子系统来说，筛选出系统关心的对象子集以及只给它展示它所关心的数据就是框架的责任了。</p>
<h3 id="Component（组件，游戏所需的所有数据结构）"><a href="#Component（组件，游戏所需的所有数据结构）" class="headerlink" title="Component（组件，游戏所需的所有数据结构）"></a>Component（组件，游戏所需的所有数据结构）</h3><p>把每个可能单独使用的对象属性归纳为一个个 Component ，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component 。</p>
<h2 id="ECS-框架設計方式"><a href="#ECS-框架設計方式" class="headerlink" title="ECS 框架設計方式"></a>ECS 框架設計方式</h2><p>设计观念：DOP(data-oriented programming) 面向数据编程</p>
<p>组合大于继承： DDD（Date-Driver-Development）数据驱动开发</p>
<p>和面向对象开发区别是 设计出发点是基于我需要什么数据 而不是要什么玩法逻辑</p>
<p><img src="D:\moyu\hexo\blog\hexo_back\sjsHexo\source\pic\ecs.png" alt="image-20230412142737884"></p>
<p>上图大概意思就是，有三个Entity，其中A和B具有相同的Component，还有一个system能够通过Translation和Rotation计算出LocalToWorld。</p>
<p><img src="D:\moyu\hexo\blog\hexo_back\sjsHexo\source\pic\image-20230412143110113.png" alt="image-20230412143110113"></p>
<p>先有一个World，它是<strong>系统</strong>和<strong>实体</strong>的集合，而<strong>实体</strong>就是一个ID，这个ID对应了<strong>组件</strong>的集合。<strong>组件</strong>用来存储游戏状态并且没有任何行为，<strong>系统</strong>拥有处理<strong>实体</strong>的行为但是没有状态。</p>
<blockquote>
<p>entity – int id （可以是一个id或者构建成一个类型）<br>    | - Component1  附加在实体上的数据 （血量 ）<br>    | - Component2    包含多个 组件  （速度等）<br>    | - Component3    组件 主要是数据 尽可能不涉及函数逻辑</p>
<p>动态的注册删除组件 很灵活</p>
<p>system 描写组件的逻辑 我可以查询到所有我想要的实体</p>
</blockquote>
<p>项目1[^entt]:c++ 但是大量C++ 模板元编程 看起来不方便</p>
<p>推荐项目2[^entitas]:c# unity  还有c++版本 比较好理解 实际项目有enttpong也可以看一下</p>
<h2 id="ecs的一些设计概念-复杂的文字部分"><a href="#ecs的一些设计概念-复杂的文字部分" class="headerlink" title="ecs的一些设计概念 复杂的文字部分"></a>ecs的一些设计概念 复杂的文字部分</h2><ol>
<li><p>每个 Entity 是由多个 Component 组合而成，共享一个生命期；而 Component 之间可以组合在一起作为 System 筛选的标准。我们在开发的时候，可以定义一个 System 关心某一个固定 Component 的组合；那么框架就会把游戏世界中满足有这个组合的 Entity 都筛选出来供这个 System 遍历，如果一个 Entity 只具备这组 Component 中的一部分，就不会进入这个筛选集合，也就不被这个 System 所关心了。</p>
</li>
<li><p>ECS 的设计就是为了管理复杂度，它提供的指导方案就是 Component 是纯数据组合，没有任何操作这个数据的方法；而 System 是纯方法组合，它自己没有内部状态。它要么做成无副作用的纯函数，根据它所能见到的对象 Component 组合计算出某种结果；要么用来更新特定 Component 的状态。System 之间也不需要相互调用（减少耦合），是由游戏世界（外部框架）来驱动若干 System 的。如果满足了这些前提条件，每个 System 都可以独立开发，它只需要遍历给框架提供给它的组件集合，做出正确的处理，更新组件状态就够了。编写 Gameplay 的人更像是在用胶水粘合这些 System ，他只要清楚每个 System 到底做了什么，操作本身对哪些 Component 造成了影响，正确的书写 System 的更新次序就可以了。一个 System 对大多数 Component 是只读的，只对少量 Component 是会改写的，这个可以预先定义清楚，有了这个知识，一是容易管理复杂度，二是给并行处理留下了优化空间。</p>
</li>
<li><p>作者自己也说，最终有 40% 的组件就是单件。单件本身其实就和传统面向对象模型差不多了。但是数据和方法分离还是很有意义。我们在用面向对象模式做开发的时候也会碰到一个对象有几个不同的方法，某些方法关注这部分状态、另一些方法关注另一部分状态，还有一些方法关注前面几组状态的集合。这里的方法就是 ECS 中的系统、状态就是组件。将数据和方法分离可以将不同的方法解耦。如果用传统的 C++ 的面向对象模式，很可能需要用多继承、组合转发等等复杂的语法手段。</p>
</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p><a href="https://www.bilibili.com/video/BV1Dd4y1j7sV/?vd_source=3bb22ce73abf7cadb35da9d846e87510">【构建你自己的ECS系统】1-什么是ECS_哔哩哔哩_bilibili</a></p>
<p>[^守望先锋的架构和网络]: <a href="https://juejin.cn/post/6844903635864780813">《守望先锋》架构设计与网络同步 - 掘金 (juejin.cn)</a><br>[^设计用例]: <a href="https://www.cnblogs.com/xianyufpga/p/13518872.html">校招基础——浮点数的定点化 - 咸鱼FPGA - 博客园 (cnblogs.com)</a><br>[^计算方式]: <a href="https://blog.csdn.net/wanrenqi/article/details/106000274">(23条消息) 定点小数的运算_定点小数运算_wanrenqi的博客-CSDN博客</a><br>[^常用的]: <a href="https://blog.csdn.net/qq_44918090/article/details/126494287">(23条消息) ARPG、MMORPG、MOBA、卡牌类、棋盘类游戏服务器架构图_游戏架构_森明帮大于黑虎帮的博客-CSDN博客</a><br>[^文章]: <a href="https://zhuanlan.zhihu.com/p/30538626">游戏开发中的ECS 架构概述 - 知乎 (zhihu.com)</a><br>[^entt]: <a href="https://gitee.com/iceeye001/entt">entt: Gaming meets modern C++ - a fast and reliable entity-component system (ECS) and much more (gitee.com)</a></p>
<p>[^entitas]: <a href="https://gitee.com/macodes/Entitas-Cpp">HelloMa&#x2F;Entitas-Cpp (gitee.com)</a></p>
]]></content>
      <categories>
        <category>游戏服务端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>游戏服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏服务器中的分布式</title>
    <url>/2021/07/25/javaGame/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="游戏服务器中的分布式"><a href="#游戏服务器中的分布式" class="headerlink" title="游戏服务器中的分布式"></a>游戏服务器中的分布式</h1><p>之前有了解一些服务器架构发展</p>
<p>现在大多游戏的服务端都是分布式架构，这个篇文章稍微学习以下分布式架构在游戏中使用吧。</p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>在《分布式系统原理与范型》一书中定义:<strong>分布式系统是若干独立计算机的集合, 这些计算机对于用户来说就像单个相关系统</strong></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>多个组件通过网路配合协作</p>
<ol>
<li><p>socket</p>
<p>网络编程，写服务器客户端连接，服务端与服务端连接，第三方服务连接等。</p>
</li>
<li><p>一些中间件，消息队列，MQ，tbus（腾讯的）等</p>
</li>
</ol>
<h3 id="tbus"><a href="#tbus" class="headerlink" title="tbus"></a>tbus</h3><p>Tbus基于共享内存构建无锁双通循环消息队列，发送的双方通过专用的读写队列完成数据收发，实现本地进程通信或者远程进程间通信。通信双方使用的两个队列称之为tbus通道(channel)，每一组通讯的双方就需要有一个tbus通道。进程A或B启动后，通过tbus API绑定到对应的通道，使用通道的两个消息队列进行收发数据，而不用关注对方的部署位置。</p>
<p><img src="https://i.loli.net/2021/01/23/NFUkQWCjEYBGdZs.png" alt="image.png"></p>
<h4 id="如果A和B进程不在同一台物理设备上"><a href="#如果A和B进程不在同一台物理设备上" class="headerlink" title="如果A和B进程不在同一台物理设备上"></a>如果A和B进程不在同一台物理设备上</h4><p><img src="https://i.loli.net/2021/01/23/fQrnp82u3UNmx6F.png" alt="image.png"></p>
<ol>
<li>标记找到进程A和B的地址（World.Zone.Func.Instance）4位十进制的地址</li>
<li>通过Tbusd将两台机器建立联系，互相发送消息</li>
<li>Tbusd如何获得进程地址，以及相互建立联系呢？这时候就有了GCIM(本机)和GRM</li>
</ol>
<h4 id="GCIM-GRM"><a href="#GCIM-GRM" class="headerlink" title="GCIM GRM"></a>GCIM GRM</h4><ul>
<li>一台服务器可以有诸多的通信关系，每一条tbus通道就是最小的通信单元，每条通道都有自己的配置区域，保存着通道大小，通道地址以及读写指针等，一台服务器上所有配置信息汇聚起来就是全局通道信息表（globalchannel information map, GCIM），一台服务器仅需要一份。管理GCIM的工具是tbusmgr。管理关系如下：</li>
</ul>
<p><img src="https://i.loli.net/2021/01/23/edGH6u4rkLa9vEc.png" alt="image.png"></p>
<ul>
<li>如果一台服务器不需要和其他远程服务器通信，则使用GCIM就能完成所有工作。当两台服务器需要使用tbus进行通信时，为了完成通信，除了启动tbusd服务进程之外，还需要建立一份通信配置，称之为全局路由表（globalroute map，GRM），用于说明哪些通道的消息需要中转。GRM也是保存在共享内存中，每一台机器只需要一份，管理GRM的工具为trelaymgr。</li>
</ul>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>通信格式，发送者和接受者统一，并且高效。</p>
<ol>
<li>序列化、反序列化（高性能）</li>
<li>版本兼容</li>
</ol>
<p>例如： protocol buffers：</p>
<p><img src="https://i.loli.net/2021/01/23/tyAm6pcEC7OgbvM.png" alt="image.png"></p>
<h2 id="定时器-超时处理"><a href="#定时器-超时处理" class="headerlink" title="定时器 - 超时处理"></a>定时器 - 超时处理</h2><p>没什么理解（未来在做吧）</p>
<p>时间轮</p>
<h2 id="游戏中经典的三层架构"><a href="#游戏中经典的三层架构" class="headerlink" title="游戏中经典的三层架构"></a>游戏中经典的三层架构</h2><p>接入层-》逻辑层-》数据层</p>
<p><img src="https://i.loli.net/2021/01/23/vklXESOUd5RT2jW.png" alt="image.png"></p>
<h3 id="分区分服务的实现"><a href="#分区分服务的实现" class="headerlink" title="分区分服务的实现"></a>分区分服务的实现</h3><p><img src="https://i.loli.net/2021/01/23/bqkEY3ohapIFBix.png" alt="image.png"></p>
<h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><p>异步处理框架：</p>
<ol>
<li>网络处理，多路复用：</li>
<li>状态机框架</li>
<li>协程处理</li>
</ol>
<h3 id="eos"><a href="#eos" class="headerlink" title="eos"></a>eos</h3><p><img src="https://s2.loli.net/2022/06/14/oMwt4WnxmRT3pDL.png" alt="image-20220614115216516"></p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p>todo： 比较杂，什么时候全面了在补全</p>
<p><a href="https://www.jianshu.com/p/543480357755">tbus</a></p>
]]></content>
      <categories>
        <category>游戏服务端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>nas系统Unraid</title>
    <url>/2023/08/03/other/UnRaid/</url>
    <content><![CDATA[<h1 id="unraid"><a href="#unraid" class="headerlink" title="unraid"></a>unraid</h1><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li><p>未来考虑直接安装linux 完成所有功能</p>
<p>原因：unraid的基础系统为（Linux version 5.19.17-Unraid (root@Develop) (gcc (GCC) 12.2.0, GNU ld version 2.39-slack151) #2 SMP PREEMPT_DYNAMIC Wed Nov 2 11:54:15 PDT 2022） 虽作为nas基本够用但是作为linux服务器用户量小 有些功能实现起来过于繁琐。</p>
</li>
<li><p>问题：qb下载cpu占满。安装nvida驱动后 启动系统和docker详情界面极慢（暂时没有找到方案）</p>
</li>
</ul>
<h1 id="1-设备"><a href="#1-设备" class="headerlink" title="1. 设备"></a>1. 设备</h1><p>拯救者r720-15ikbn </p>
<ul>
<li>方案： U盘作为启动盘 1t叠瓦机械 和125g的m.2固态作为缓存盘 无外接硬盘柜。功耗 基本在 50左右</li>
<li>作为一个中转暂缓的方案临时用就笔记本改</li>
</ul>
<h1 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2.安装部署"></a>2.安装部署</h1><p>安装方案：搜索unraid安装就好了 开心版和正版一样  <a href="https://www.bilibili.com/video/BV14L411b76f/?spm_id_from=333.1245.0.0&vd_source=3bb22ce73abf7cadb35da9d846e87510">最详尽的Unraid安装教程（2）- 国内网络环境下安装APP市场以及几个必要的插件安装与使用（Unraid002）_哔哩哔哩_bilibili</a></p>
<p><strong>缓存盘机制</strong>：<a href="https://www.bilibili.com/video/BV1kB4y1c7ES/?vd_source=3bb22ce73abf7cadb35da9d846e87510">Unraid开荒教程03——详细说一说Unraid系统的缓存机制 又灵活又丰富_哔哩哔哩_bilibili</a></p>
<p>读取不到nvme 固态的话： 需要在bios里设置 sata mode selection ahci </p>
<p>flash中的go文件设置为：</p>
<p>原因： unraid每次重启环境数据重置 go文件为启动后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start the Management Utility</span></span><br><span class="line">http_proxy=http://192.168.1.2:7899 https_proxy=http://192.168.1.2:7899 /usr/local/sbin/emhttp &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Update mirrors</span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;:[</span><br><span class="line">  &quot;https://8odv2i1d.mirror.aliyuncs.com&quot;,</span><br><span class="line">  &quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Update Host</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;199.232.4.133   raw.githubusercontent.com&quot;</span> &gt;&gt;  /etc/hosts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;20.27.177.113   github.com&quot;</span> &gt;&gt;  /etc/hosts</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Update Clash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;use_proxy=yes&quot;</span> &gt;&gt; /root/.wget-hsts</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;http_proxy=http://192.168.1.2:7899&quot;</span> &gt;&gt; /root/.wget-hsts</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;https_proxy=http://192.168.1.2:7899&quot;</span> &gt;&gt; /root/.wget-hsts</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;wait=10&quot;</span> &gt;&gt; /root/.wget-hsts</span></span><br></pre></td></tr></table></figure>

<h2 id="1-clash安装"><a href="#1-clash安装" class="headerlink" title="1. clash安装"></a>1. clash安装</h2><p>作用：代理上网， 加速app商店</p>
<p><a href="https://homedt.net/47571.html">unraid安装clash 及启用http代理 | 夜风博客 (homedt.net)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/609967222">UnRaid 网络代理填坑，Apps市场安装，Apps不显示内容，Docker镜像加速，适用最新6.11.5，大佬文章填坑 - 知乎 (zhihu.com)</a></p>
<hr>
<h2 id="2-电影墙-nastools"><a href="#2-电影墙-nastools" class="headerlink" title="2. 电影墙 nastools"></a>2. 电影墙 nastools</h2><p>nastools 要装下载器（我选的是qbittorrent）解码器（jellyfin）</p>
<p><strong>参考：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1cv4y1S7m7/?vd_source=3bb22ce73abf7cadb35da9d846e87510">Unraid版NAS Tools部署教程，使用NAS打造家庭影音中心！【Unraid篇02】_哔哩哔哩_bilibili</a></p>
<p><a href="https://wiki.nastool.org/zh/home">开始 | NAStool Wiki</a> </p>
<p>上面的打不开 看这个也行 <a href="https://post.smzdm.com/p/arqgoqp7/">Unraid部署多媒体自动机器人nas-tools全过程，可直接食用_NAS存储_什么值得买 (smzdm.com)</a></p>
<h3 id="jellyfin-单独说-踩了很多坑"><a href="#jellyfin-单独说-踩了很多坑" class="headerlink" title="jellyfin 单独说 踩了很多坑"></a>jellyfin 单独说 踩了很多坑</h3><p>如果别的比他好用那就别用这个了</p>
<ol>
<li><p>首先安装按照视频就可以</p>
</li>
<li><p>解码部分 如果用核显可以跳过这部分 独立显卡继续看（我用核显cpu太高所以不想闲着独显）</p>
</li>
<li><p>首先安装nvida 驱动 [<a href="https://forums.unraid.net/topic/98978-plugin-nvidia-driver/">插件]英伟达驱动程序 - 插件支持 - Unraid</a></p>
</li>
<li><p>记住： <strong>PCI 设备和 IOMMU 组</strong> 不能使用显卡否则会安装失败。</p>
</li>
<li><p>我的版本打不开 <strong>Nvidia Driver</strong> 但是用命令  nvidia-smi 查看是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Tower:~# nvidia-smi </span><br><span class="line">Wed Aug  2 15:26:26 2023       </span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.54.03              Driver Version: 535.54.03    CUDA Version: 12.2     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                      |               MIG M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce GTX 1050 Ti     Off | 00000000:01:00.0 Off |                  N/A |</span><br><span class="line">| N/A   44C    P0              N/A / ERR! |      0MiB /  4096MiB |      0%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                                         </span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                            |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |</span><br><span class="line">|        ID   ID                                                             Usage      |</span><br><span class="line">|=======================================================================================|</span><br><span class="line">|  No running processes found                                                           |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置   </p>
<p><a href="https://www.right.com.cn/forum/thread-8267275-1-1.html">群晖docker jellyfin 调用n卡(独显)驱动 ——恩山首发-存储先锋-恩山无线论坛 - Powered by Discuz! (right.com.cn)</a></p>
<p>[<a href="https://github.com/jellyfin/jellyfin/issues/7036">问题]： ffmpeg 日志 ·问题 #7036 ·果冻鳍&#x2F;果冻鳍 (github.com)</a></p>
</li>
<li><p>要配置gpu额外参数</p>
</li>
</ol>
<p>我改了版本 <em>nyanmisaka&#x2F;jellyfin</em> 因为之前gpu用不了是因为版本问题 但是好像是因为参数问题 所以官方版本应该也行</p>
<h3 id="nastools"><a href="#nastools" class="headerlink" title="nastools"></a>nastools</h3><p>现在存活的版本是3.x 但是3.x要pt站认证 所以 我找到了 2.9.1的版本 dockerhub很多人在用的</p>
<p>[nastool V3.x 安装及用户认证-有搞头-有搞头笔记 (ljs.fun)](<a href="https://ljs.fun:521/?id=340#:~:text=%E7%99%BB%E5%BD%95nastool%E5%B9%B6%E8%AE%A4%E8%AF%81">https://ljs.fun:521/?id=340#:~:text=登录nastool并认证</a> 登录地址： ip%3A3003 用户名： admin 密码： password,*登录成功后请修改用户名和密码 点击左下角 用户认证 选择 IYUU%2C输入 token%2C 即可顺利通过认证，获取nastool全部功能。)</p>
<h3 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h3><p><a href="https://www.bilibili.com/video/BV1JW4y1W7FW/?vd_source=3bb22ce73abf7cadb35da9d846e87510">部署ChineseSubFinder+NAS Tools联动设置，中文字幕自动化下载，追剧观影必备工具_哔哩哔哩_bilibili</a></p>
<p>不是很好用 而且我看的很多电影是代字幕的</p>
<h3 id="qbittorrent"><a href="#qbittorrent" class="headerlink" title="qbittorrent"></a>qbittorrent</h3><p>下载上传没什么感觉 硬盘感觉不够用</p>
<h2 id="3-pt站"><a href="#3-pt站" class="headerlink" title="3. pt站"></a>3. pt站</h2><p>注册了冰淇淋 刷流都很好用 </p>
<h1 id="3-其他软件"><a href="#3-其他软件" class="headerlink" title="3. 其他软件"></a>3. 其他软件</h1><h2 id="1-voceChat"><a href="#1-voceChat" class="headerlink" title="1. voceChat"></a>1. voceChat</h2><p>解决局域网实时聊天传文字和文件功能。</p>
<p><a href="https://doc.voce.chat/">What is VoceChat | VoceChat</a></p>
<h2 id="2-iyuu自动辅种"><a href="#2-iyuu自动辅种" class="headerlink" title="2. iyuu自动辅种"></a>2. iyuu自动辅种</h2><p>暂时没有pt认证所以观望中</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>unraid</tag>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title>电吉他</title>
    <url>/2023/05/25/music/%E7%94%B5%E5%90%89%E4%BB%96%E5%85%BB%E6%8A%A4/</url>
    <content><![CDATA[<h1 id="电吉他养护"><a href="#电吉他养护" class="headerlink" title="电吉他养护"></a>电吉他养护</h1><h1 id="日常维护"><a href="#日常维护" class="headerlink" title="日常维护"></a>日常维护</h1><ol>
<li><p>Gibson 硝基漆清洁液</p>
<p>漆面擦擦就行 其他类型漆面基本随便擦擦就行 </p>
</li>
<li><p>玫瑰木指版 要上油 保湿 防止干裂 1-1.5月清洁保湿一次就可以</p>
<blockquote>
<p>musicNoMad 天然指版油</p>
<p>柠檬油 分情况 邓禄普的建议是经常用琴的。起到清洁保湿，但是基本不会补湿。 </p>
<p>有条件用蜡代替油 蜡不会沁入品丝里 导致脱落。上油要小心 控制用量。</p>
<p>清洁后 滋润几分钟擦掉就行 <strong>正常应该是玫瑰木原木色</strong> 红黑色 润润的</p>
</blockquote>
</li>
<li><p>品丝 正常使用 避免琴弦生锈时使用 一般不需要抛光</p>
<p>抛光用： vortex清洁</p>
<p>清洁用油擦净就可以</p>
</li>
<li><p>琴弦：定期换就行 每次用完琴擦干净琴弦上的污渍。 练琴前洗手。</p>
<p>什么品丝清洁液 都没性价比（会导致琴弦有变化，声音和手感都变差。到时间都要换，所以用处不大）。实在每天见换琴弦，也可以用。</p>
</li>
<li><p>保湿</p>
<p>玫瑰木指板 药保湿湿度50-70% 要不然会裂&#x3D;。&#x3D;</p>
</li>
</ol>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol>
<li>b站GibsonTv官方维护琴的教程够用</li>
</ol>
<p>找了一阵子 我的Gibson怎么买护理液 找到了这个贴吧</p>
<p><a href="https://tieba.baidu.com/p/5983584895?pn=1">【图片】关于电吉他的保养维护【老炮可以忽略】_电吉他吧_百度贴吧 (baidu.com)</a></p>
]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>电吉他</tag>
      </tags>
  </entry>
  <entry>
    <title>电吉他</title>
    <url>/2023/05/25/music/%E7%94%B5%E5%90%89%E4%BB%96%E5%BC%B9%E5%A5%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="电吉他-弹奏"><a href="#电吉他-弹奏" class="headerlink" title="电吉他 弹奏"></a>电吉他 弹奏</h1><p>跳弦 也不是什么大问题 是一种演奏技巧  会影响弹奏速度 但是 利于跨弦</p>
<p>三连音 音阶 5,6  机构先</p>
<h3 id="音阶"><a href="#音阶" class="headerlink" title="音阶"></a>音阶</h3><p>跨弦八度音找法:65弦找八度就是空一品跨一弦，43弦找八度就是空2品跨一弦 </p>
<p><strong>弹奏除了摇滚金属以外的</strong></p>
<blockquote>
<p> 弹奏抱着电吉他 右手肩膀放松下垂手腕手臂尽量直线 </p>
<p>不压琴桥,琴桥是放开的 </p>
<p>可能会有杂音(所以拨弦要准确)</p>
<p> 下拨:压弦 但是瞬发 上拨:挑弦</p>
<p>放松弹奏 很快乐!!!  拨弦的感觉类似甩手腕的感觉 </p>
</blockquote>
]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>电吉他</tag>
      </tags>
  </entry>
  <entry>
    <title>effective Java记录</title>
    <url>/2023/04/23/bookNote/effective-Java%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="effective-Java"><a href="#effective-Java" class="headerlink" title="effective Java"></a>effective Java</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://github.com/jbloch/effective-java-3e-source-code">书中代码用例 jbloch&#x2F;effective-java-3e-source-code: The source code from the third edition of Effective Java, with minor additions as necessary to make it runnable. (github.com)</a></p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1>]]></content>
      <categories>
        <category>技术读物</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>linux线上分析</title>
    <url>/2023/03/28/linuxRelevant/linux%E7%BA%BF%E4%B8%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="linux性能分析"><a href="#linux性能分析" class="headerlink" title="linux性能分析"></a>linux性能分析</h1><ul>
<li><p>uptime</p>
<blockquote>
<p>$ uptime<br> 16:53:45 up 588 days, 22:34,  1 user,  load average: 0.12, 0.14, 0.14</p>
<p>load average 分别是1，5，15min内的load值 load越大 cpu越忙</p>
</blockquote>
</li>
<li><p>top</p>
<blockquote>
<p>$ top |grep Cpu<br>%Cpu(s):  0.8 us,  0.4 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</p>
<p><a href="https://zhuanlan.zhihu.com/p/479517115">深入聊聊 top 命令中的 CPU 使用率（超详细） - 知乎 (zhihu.com)</a></p>
<p>shift+h 按照线程查看</p>
<p>-p [pid] 查看端口</p>
<p>top -H -p  查看线程 shift&lt;和&gt; </p>
<p>Shift+M键 内存排序</p>
<p>Shift+P键 cpu排序</p>
</blockquote>
</li>
<li><p>free </p>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-comm-free.html">Linux free命令 | 菜鸟教程 (runoob.com)</a></p>
<p>查看内存剩余</p>
</blockquote>
</li>
<li><p>jstat -gc 24107 </p>
</li>
<li><p>jps -m -l</p>
</li>
<li><p>jstack 虚拟机快照 </p>
</li>
<li><p>jinfo 查看参数</p>
</li>
<li><p>jmap 查看等待回收队列</p>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://zhuanlan.zhihu.com/p/387788218">性能工具之Java调试工具BTrace入门 - 知乎 (zhihu.com)</a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>-verbose:class  查看是否有类重复依赖加载</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>三体</title>
    <url>/2023/03/05/%E8%AF%BB%E4%B9%A6/%E4%B8%89%E4%BD%93/</url>
    <content><![CDATA[<h1 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h1><p>只是想记录一下 所以这玩应应该叫emmm读书笔记？不重要</p>
<p>前一阵看完了买了好久的《重启蒙娜丽莎》看完之后怀疑起了自己的阅读能力，随即放弃了后面的部分。 正巧 三体电视剧热度上来了</p>
<p>那就看看三体吧</p>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>当前看书+听书 1,2部看完了。</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>待做</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>时间管理-timeManagement</title>
    <url>/2022/06/14/other/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-timeManagement/</url>
    <content><![CDATA[<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><blockquote>
<p>这个笔记 就是记录一下公司白嫖的课程 本来想搞一个京东卡或者番茄时钟. 结果白嫖了空气炸锅 番茄钟觉得鸡肋就先上课呗.看了 一下概述 可能会有用先看一下</p>
</blockquote>
<h1 id="如何有效的做计划"><a href="#如何有效的做计划" class="headerlink" title="如何有效的做计划"></a>如何有效的做计划</h1><h3 id="项目管理表-x2F-日历表"><a href="#项目管理表-x2F-日历表" class="headerlink" title="项目管理表&#x2F;日历表"></a>项目管理表&#x2F;日历表</h3><p><strong>项目管理表</strong></p>
<p>大概就是<strong>规划备忘</strong></p>
<ul>
<li><p>项目拆分为子目标  计划先构思</p>
</li>
<li><p>阶段性规划 按照周期 (举例: 季度规划 粒度到周)</p>
</li>
<li><p>不要太细致 反而没效果</p>
</li>
<li><p>不漏不重(流程不漏, 具体细节不重)</p>
</li>
</ul>
<blockquote>
<p>每个项目只有一个重要负责人 </p>
</blockquote>
<ul>
<li><p>deadline很重要</p>
</li>
<li><p>承诺与一致: 尽量需要他人的截止时间由他们自己定</p>
</li>
<li><p>项目记下相关方(同步记录等)</p>
</li>
</ul>
<p> <strong>日历表</strong>  </p>
<p>大概就是<strong>规划备忘</strong></p>
<p>  日历表 周期性的规划</p>
<ol>
<li><p>先规划大石头(意义重大 耗时的)</p>
<p>两类”先规划的”工作: 短期无效长期有影响 &#x2F; 短期起效 </p>
<p>重要日期需要准备的</p>
</li>
<li><p>后规划其他的碎的对象</p>
</li>
</ol>
<blockquote>
<p>流出20%的缓冲时间</p>
</blockquote>
<ul>
<li>每日计划 这个我一直在做 但是摆烂懒了 盒盒盒盒盒盒盒</li>
</ul>
<h1 id="提升执行力的关键方法"><a href="#提升执行力的关键方法" class="headerlink" title="提升执行力的关键方法"></a>提升执行力的关键方法</h1><h1 id="敏捷工作法"><a href="#敏捷工作法" class="headerlink" title="敏捷工作法"></a>敏捷工作法</h1><h1 id="管理合作者的时间"><a href="#管理合作者的时间" class="headerlink" title="管理合作者的时间"></a>管理合作者的时间</h1><h1 id="摆脱被动忙碌-投入自我驱动主动忙碌"><a href="#摆脱被动忙碌-投入自我驱动主动忙碌" class="headerlink" title="摆脱被动忙碌 投入自我驱动主动忙碌"></a>摆脱被动忙碌 投入自我驱动主动忙碌</h1>]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>linux1</title>
    <url>/2022/06/14/linuxRelevant/linux/</url>
    <content><![CDATA[<h1 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h1><blockquote>
<p>基于CentOS7</p>
</blockquote>
<p>常用的基本命令</p>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><blockquote>
<p>绝对路径和相对路径</p>
</blockquote>
<p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<p><strong>绝对路径：</strong></p>
<p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p>
<p><strong>相对路径：</strong></p>
<p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p>
<blockquote>
<p>处理目录的常用命令</p>
</blockquote>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>ls （列出目录）</p>
</blockquote>
<p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cd （切换目录）</p>
</blockquote>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 切换到用户目录下</span><br><span class="line">[root@kuangshen /]# cd home  </span><br><span class="line"></span><br><span class="line"># 使用 mkdir 命令创建 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# mkdir kuangstudy</span><br><span class="line"></span><br><span class="line"># 进入 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# cd kuangstudy</span><br><span class="line"></span><br><span class="line"># 回到上一级</span><br><span class="line">[root@kuangshen kuangstudy]# cd ..</span><br><span class="line"></span><br><span class="line"># 回到根目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd /</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 /root 这个目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd ~</span><br></pre></td></tr></table></figure>

<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<blockquote>
<p>pwd ( 显示目前所在的目录 )</p>
</blockquote>
<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen kuangstudy]#pwd [-P]</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 单纯显示出目前的工作目录</span><br><span class="line">[root@kuangshen ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br><span class="line">[root@kuangshen /]# cd bin</span><br><span class="line">[root@kuangshen bin]# pwd -P</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mkdir （创建新目录）</p>
</blockquote>
<p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入我们用户目录下</span><br><span class="line">[root@kuangshen /]# cd /home</span><br><span class="line"></span><br><span class="line"># 创建一个 test 文件夹</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 创建多层级目录</span><br><span class="line">[root@kuangshen home]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory ‘test1/test2/test3/test4’:</span><br><span class="line">No such file or directory  # &lt;== 没办法直接创建此目录啊！</span><br><span class="line"></span><br><span class="line"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br><span class="line">[root@kuangshen home]# mkdir -p test1/test2/test3/test4</span><br><span class="line"></span><br><span class="line"># 创建权限为 rwx--x--x 的目录。</span><br><span class="line">[root@kuangshen home]# mkdir -m 711 test2</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rmdir ( 删除空的目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 看看有多少目录存在？</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"># 可直接删除掉，没问题</span><br><span class="line">[root@kuangshen home]# rmdir test</span><br><span class="line"></span><br><span class="line"># 因为尚有内容，所以无法删除！</span><br><span class="line">[root@kuangshen home]# rmdir test1</span><br><span class="line">rmdir: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><br><span class="line">[root@kuangshen home]# rmdir -p test1/test2/test3/test4</span><br></pre></td></tr></table></figure>

<p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！</p>
<blockquote>
<p>cp ( 复制文件或目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找一个有文件的目录，我这里找到 root目录</span><br><span class="line">[root@kuangshen home]# cd /root</span><br><span class="line">[root@kuangshen ~]# ls</span><br><span class="line">install.sh</span><br><span class="line">[root@kuangshen ~]# cd /home</span><br><span class="line"></span><br><span class="line"># 复制 root目录下的install.sh 到 home目录下</span><br><span class="line">[root@kuangshen home]# cp /root/install.sh /home</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 再次复制，加上-i参数，增加覆盖询问？</span><br><span class="line">[root@kuangshen home]# cp -i /root/install.sh /home</span><br><span class="line">cp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rm ( 移除文件或目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br><span class="line">[root@kuangshen home]# rm -i install.sh</span><br><span class="line">rm: remove regular file ‘install.sh’? y</span><br><span class="line"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><span class="line"></span><br><span class="line"># 尽量不要在服务器上使用 rm -rf /</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mv  ( 移动文件与目录，或修改名称 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制一个文件到当前目录</span><br><span class="line">[root@kuangshen home]# cp /root/install.sh /home</span><br><span class="line"></span><br><span class="line"># 创建一个文件夹 test</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 将复制过来的文件移动到我们创建的目录，并查看</span><br><span class="line">[root@kuangshen home]# mv install.sh test</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">test</span><br><span class="line">[root@kuangshen home]# cd test</span><br><span class="line">[root@kuangshen test]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 将文件夹重命名，然后再次查看！</span><br><span class="line">[root@kuangshen test]# cd ..</span><br><span class="line">[root@kuangshen home]# mv test mvtest</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure>

<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><blockquote>
<p>看懂文件属性</p>
</blockquote>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：更改文件属组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p><strong>3、chmod：更改文件9个属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure>

<p>可以自己下去多进行测试！</p>
<h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span><br><span class="line">[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tac</p>
</blockquote>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>



<blockquote>
<p>nl  显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=yes</span><br></pre></td></tr></table></figure>



<blockquote>
<p>more  一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>&#x2F;字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# more /etc/csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></pre></td></tr></table></figure>



<blockquote>
<p>less  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
</blockquote>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# more /etc/csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   # 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure>



<blockquote>
<p>head  取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# head -n 20 /etc/csh.login</span><br></pre></td></tr></table></figure>



<blockquote>
<p>tail  取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# tail -n 20 /etc/csh.login</span><br></pre></td></tr></table></figure>



<blockquote>
<p>拓展：Linux 链接概念</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kuangshen /]# cd /home</span><br><span class="line">[root@kuangshen home]# touch f1 # 创建一个测试文件f1</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2</span><br><span class="line">[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3</span><br><span class="line">[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span><br><span class="line">[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1</span><br><span class="line">[root@kuangshen home]# cat f1</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# rm -f f1</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">cat: f3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<p>后面的话，我们就开始学习Vim和用户磁盘相关的命令！从而修改配置！</p>
<p>视频同步更新，这次一定！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux2</title>
    <url>/2022/06/14/linuxRelevant/linuxNote/</url>
    <content><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><blockquote>
<p>一些常用指令 基本要领 技巧</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>正常一个流程 应该有这个 想看就上这里看吧 <a href="https://mp.weixin.qq.com/s/RT93qJdTagtKjWKx_A_6Nw">：概述及环境搭建</a></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>&#x2F;bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>&#x2F;boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>&#x2F;dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li><strong>&#x2F;etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li>
<li><strong>&#x2F;home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><strong>&#x2F;lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li>
<li><strong>&#x2F;lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>&#x2F;media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>&#x2F;mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li>
<li><strong>&#x2F;opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li>
<li><strong>&#x2F;proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li><strong>&#x2F;root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>&#x2F;sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>&#x2F;srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>&#x2F;sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li><strong>&#x2F;tmp</strong>：这个目录是用来存放一些临时文件的。</li>
<li><strong>&#x2F;usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li>
<li><strong>&#x2F;usr&#x2F;bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>&#x2F;usr&#x2F;sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>&#x2F;usr&#x2F;src：</strong> 内核源代码默认的放置目录。</li>
<li><strong>&#x2F;var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li><strong>&#x2F;www</strong> : 网站数据</li>
</ul>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><blockquote>
<p>说明</p>
</blockquote>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站</a></p>
<p><a href="https://www.bilibili.com/video/BV14A411378a">熬7天夜，我肝了个Linux速查备忘手册！有了它，还怕Linux操作系统常用操作和命令记不住？_哔哩哔哩_bilibili</a></p>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
</li>
<li>rm: 移除文件或目录<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
</li>
<li>pwd: 显示目前所在目录的命令 <strong>-P</strong> ：显示出确实的路径，而非使用连接(link) 路径</li>
<li>ln: 创建链接<ul>
<li>-s: 软链接</li>
</ul>
</li>
<li>touch: 创建文件</li>
<li>tar: -zxvf  &#x2F; zcvf <ul>
<li>-A	新增文件到以存在的备份文件</li>
<li>-B	设置区块大小</li>
<li>-c	建立新的备份文件</li>
<li>-C &lt;目录&gt;	仅压缩指定目录里的内容或解压缩到指定目录</li>
<li>-d	记录文件的差别</li>
<li>-x	从归档文件中提取文件</li>
<li>-t	列出备份文件的内容</li>
<li>-z	通过gzip指令压缩&#x2F;解压缩文件，文件名最好为*.tar.gz</li>
<li>-Z	通过compress指令处理备份文件</li>
<li>-f&lt;备份文件&gt;	指定备份文件</li>
<li>-v	显示指令执行过程</li>
<li>-r	添加文件到已经压缩的文件</li>
<li>-u	添加改变了和现有的文件到已经存在的压缩文件</li>
<li>-j	通过bzip2指令压缩&#x2F;解压缩文件，文件名最好为*.tar.bz2</li>
<li>-v	显示操作过程</li>
<li>-l	文件系统边界设置  </li>
<li>-k	保留原有文件不覆盖</li>
<li>-m	保留文件不被覆盖</li>
<li>-w	确认压缩文件的正确性</li>
<li>-p	保留原来的文件权限与属性</li>
<li>-P	使用文件名的绝对路径，不移除文件名称前的“&#x2F;”号</li>
<li>-N &lt;日期格式&gt;	只将较指定日期更新的文件保存到备份文件里</li>
<li>– -exclude&#x3D;&lt;范本样式&gt;	排除符合范本样式的文件</li>
<li>– -remove-files	归档&#x2F;压缩之后删除源文件</li>
</ul>
</li>
<li>gzip&#x2F;gunzip 压缩&#x2F;解压 文件</li>
<li>zip&#x2F;unzip<ul>
<li>-r 递归 压缩目录</li>
<li>-d 解压目录</li>
</ul>
</li>
<li>find [路径] [参数]<ul>
<li>-name	匹配名称</li>
<li>-perm	匹配权限（mode为完全匹配，-mode为包含即可）</li>
<li>-user	匹配所有者</li>
<li>-group	匹配所有组</li>
<li>-mtime -n +n	匹配修改内容的时间（-n指n天以内，+n指n天以前）</li>
<li>-atime -n +n	匹配访问文件的时间（-n指n天以内，+n指n天以前）</li>
<li>-ctime -n +n	匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</li>
<li>-nouser	匹配无所有者的文件</li>
<li>-nogroup	匹配无所有组的文件</li>
<li>-newer f1 !f2	匹配比文件f1新但比f2旧的文件</li>
<li>-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f	匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</li>
<li>-size	匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</li>
<li>-prune	忽略某个目录</li>
<li>-exec …… {};	后面可跟用于进一步处理搜索结果的命令</li>
</ul>
</li>
<li>locate:   [参数] 文件 <ul>
<li><strong>注: Linux系统需定期执行下updatedb命令对数据库文件进行更新</strong></li>
<li>-d	指定数据库所在的目录</li>
<li>–help	显示帮助</li>
<li>–version  显示版本信息</li>
</ul>
</li>
<li>grep: <ul>
<li>-i	忽略大小写</li>
<li>-c	只输出匹配行的数量</li>
<li>-l	只列出符合匹配的文件名，不列出具体的匹配行</li>
<li>-n	列出所有的匹配行，显示行号</li>
<li>-h	查询多文件时不显示文件名</li>
<li>-s	不显示不存在、没有匹配文本的错误信息</li>
<li>-v	显示不包含匹配文本的所有行</li>
<li>-w	匹配整词</li>
<li>-x	匹配整行</li>
<li>-r	递归搜索</li>
<li>-q	禁止输出任何结果，已退出状态表示搜索是否成功</li>
<li>-b	打印匹配行距文件头部的偏移量，以字节为单位</li>
<li>-o	与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</li>
<li>-F	匹配固定字符串的内容</li>
<li>-E	支持扩展的正则表达式</li>
</ul>
</li>
</ul>
<h2 id="属性权限"><a href="#属性权限" class="headerlink" title="属性权限"></a>属性权限</h2><ul>
<li>chgrp: 更改文件属组<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
</li>
<li>chown: 更改文件属主，也可以同时更改文件属组<ul>
<li>-R</li>
</ul>
</li>
<li>chmod: 更改文件9个属性<ul>
<li>-R</li>
</ul>
</li>
</ul>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
<li>:f 查看行号</li>
</ul>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><ul>
<li>crondtab<ul>
<li>-e 编辑crontab定时任务</li>
<li>-l 查看</li>
<li>-r 删除当前用户的所有任务</li>
<li>-u  指定用户名字</li>
</ul>
</li>
</ul>
<h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p><strong>权限说明</strong> </p>
<p><img src="https://s2.loli.net/2022/06/20/KlTrvYSp1MaWoEx.png" alt="权限说明"></p>
<p>计算时是三位数 对应三个权限  权限是三个数据相加 rwx &#x3D; 4 + 2 + 1 </p>
<h2 id="文件链接-软"><a href="#文件链接-软" class="headerlink" title="文件链接 软"></a>文件链接 软</h2><p><strong>硬连接</strong> 拷贝的文件 可以同步修改</p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p>**软连接 (符号链接) ** 相当于快捷方式</p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p><a href="https://www.vim.org/">welcome home : vim online</a> 官网 它是一个程序编辑器</p>
<p>键盘图: </p>
<p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图（入门到进阶） | 菜鸟教程 (runoob.com)</a></p>
<p><img src="https://s2.loli.net/2022/06/21/iFEC8NH1kWR79xB.png" alt="image-20220621165643654"></p>
<h2 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h2><p>1</p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n&lt; space&gt;</td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left">n&lt; Enter&gt;</td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p>2</p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i, I</td>
<td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p>3</p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
</li>
<li>du：检查磁盘空间使用量<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
</li>
<li>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li>
</ul>
</li>
<li>lsblk -f 查看磁盘分区和挂载情况</li>
</ul>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>查看进程指令 </p>
<p><img src="https://s2.loli.net/2022/06/23/cMmRwpSY91IQ5dO.png" alt="image-20220623200034474"></p>
<ul>
<li>ps -aux<ul>
<li>a:所有</li>
<li>u: 用户格式显示</li>
<li>x: 显示后台进程运行参数</li>
</ul>
</li>
<li>ps -ef  父进程(ppid)</li>
<li>kill   杀死进程 [pid]</li>
<li>killall [name]<ul>
<li>-9 强制杀掉</li>
</ul>
</li>
<li>pstree 树状展示进程信息<ul>
<li>-p 显示pid</li>
<li>-u 显示用户</li>
</ul>
</li>
</ul>
<h1 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h1><h2 id="新机器安装配置"><a href="#新机器安装配置" class="headerlink" title="新机器安装配置"></a>新机器安装配置</h2><p>LNMP安装</p>
<p><a href="https://blog.csdn.net/qq_24917475/article/details/123024060">基于Linux(CentOS)快速搭建LNMP环境【使用LNMP安装包一键搭建】_Say Something的博客-CSDN博客_linux lnmp</a></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>用户部分跳过了 11-12</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器停服维护，回档，反外挂</title>
    <url>/2022/04/06/javaGame/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%81%9C%E6%9C%8D%E7%BB%B4%E6%8A%A4,%E5%9B%9E%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="一．-服务器停服维护"><a href="#一．-服务器停服维护" class="headerlink" title="一． 服务器停服维护"></a>一． 服务器停服维护</h1><ol>
<li><p>QA测试完成后会打出服务器更新维护的整包放到<a href="http://xxx.xxx.xxx.xxx:xxxx/#/xxxx/01_Official/xxxx/">这里</a>,同时会通知包名</p>
</li>
<li><p>下载更新包到本地，然后上传到指定的<a href="ftp://los.xxxx.com/">ftp目录</a></p>
</li>
<li><p>将更新包的信息同步给运维和运营的同学</p>
</li>
<li><p>到更新的时间点后运营同学会切换服务器状态到维护，运维同学负责停服，更新，启服等具体操作，不出意外的话是不需要程序这边做任何操作的。</p>
</li>
<li><p>服务器更新重启之后QA同学会过一遍基本功能，程序这边就看下日志是否有异常或者报错，主要关注1001和6001服，QA主要测试这两个服。QA测试通过了，服务器也没有异常和错误就可以开服对外了（一般由QA在大群里对运营同学说，运营将服务器状态切换为正常）</p>
</li>
</ol>
<p><strong>&#x3D;&#x3D;注意事项：&#x3D;&#x3D;</strong></p>
<ul>
<li><p>每次更新服务器启动之后，需要将服务器的自动封禁关闭，避免程序bug导致误封。在游戏对外跑一个小时之后如果没有战斗校验的bug可以开启自动封禁。在关闭期间需要值班同学关注企业微信的MT-外挂监控告警群，手动对外挂玩家进行封禁，具体细节参照<em><strong>反外挂文档。</strong></em></p>
</li>
<li><p>因为1001服目前人数较多，配置和其他服不一样，1001服的战斗校验线程数量需要单独手动修改（运维操作），所以维护时需要提醒一下运维同学修改</p>
</li>
</ul>
<h1 id="二-回档"><a href="#二-回档" class="headerlink" title="二. 回档"></a>二. 回档</h1><h2 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h2><h2 id="1-线上数据库获取"><a href="#1-线上数据库获取" class="headerlink" title="1. 线上数据库获取"></a>1. 线上数据库获取</h2><ol>
<li><p>拷贝当时数据库脚本  </p>
<p>执行 sh -x get_gameid_all_sql.sh [serverid]  备注:all有建库语句 data没有建库建表</p>
</li>
<li><p>以前的快照</p>
<ul>
<li><p>获取到 实例名称 </p>
</li>
<li><p>在机器上拉取  </p>
</li>
<li><p>修改实例名字（rm-bp1ofj5dorx7ha83p.mysql.rds.aliyuncs.com）和导出文件的名字（mtob_game_6081 ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -hrm-bpXXXXX.mysql.rds.aliyuncs.com -ultgame_read -pXXX --opt --single-transaction --set-gtid-purged=OFF xxxx_game_6081 &gt;mtob_game_6081_1111.sql</span><br><span class="line">压缩下载：</span><br><span class="line">mysqldump -hrm-bpxxxx.mysql.rds.aliyuncs.com -ultgame_read -pxxxx --opt --single-transaction --set-gtid-purged=OFF mtob_game_6081 | gzip &gt; xxxx_game_6081_0111.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库常用命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `localids` <span class="keyword">SET</span> `v` <span class="operator">=</span> <span class="string">&#x27;&#123;\&quot;1\&quot;:[11x,400x]&#125;&#x27;</span> <span class="keyword">WHERE</span> `k` <span class="operator">=</span> <span class="string">&#x27;0000000x&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> xxxx_game_1111_1128 <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE xxxx_game_xxxx_1202;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> localids;</span><br><span class="line">mysql <span class="operator">-</span>h172<span class="number">.2</span><span class="number">.2</span><span class="number">.2</span> <span class="operator">-</span>uroot <span class="operator">-</span>pxxxx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="热更新可以看服务器维护文档"><a href="#热更新可以看服务器维护文档" class="headerlink" title="热更新可以看服务器维护文档"></a>热更新可以看服务器维护文档</h3><blockquote>
<p>回档可能需要 上传数据到服务器</p>
</blockquote>
<h2 id="2-运营-道具操作"><a href="#2-运营-道具操作" class="headerlink" title="2. 运营 道具操作"></a>2. 运营 道具操作</h2><p>运营提供回档数据表格 我们把json打包热更新数据包。执行gm </p>
<h3 id="自动复制key的脚本"><a href="#自动复制key的脚本" class="headerlink" title="自动复制key的脚本"></a>自动复制key的脚本</h3><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#x27; keyData:  脚本导出的数据</span></span><br><span class="line"><span class="comment">&#x27; roleData: 需要操作的数据 [serverId(tab)roleId]</span></span><br><span class="line"><span class="comment">&#x27; ====================</span></span><br><span class="line"><span class="comment">&#x27; xShell 脚本主函數</span></span><br><span class="line"><span class="keyword">Sub</span> Main</span><br><span class="line">	readTxt()</span><br><span class="line">	xsh.Dialog.<span class="built_in">MsgBox</span>(<span class="string">&quot;complete&quot;</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> writeTxt(serverId, roleId, data)</span><br><span class="line">	<span class="keyword">set</span> fs=<span class="built_in">createobject</span>(<span class="string">&quot;scripting.filesystemobject&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span>(fs.fileexists(<span class="string">&quot;E:\todo\huidang\keyData\keyData.txt&quot;</span>)) <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">set</span> f =fs.opentextfile(<span class="string">&quot;E:\todo\huidang\keyData\keyData.txt&quot;</span>,<span class="number">8</span>)</span><br><span class="line">	f.write serverId</span><br><span class="line">	f.write <span class="built_in">Chr</span>(<span class="number">9</span>)</span><br><span class="line">	f.write roleId</span><br><span class="line">	f.write <span class="built_in">Chr</span>(<span class="number">9</span>)+<span class="built_in">Chr</span>(<span class="number">9</span>)</span><br><span class="line">	f.write data</span><br><span class="line">	f.WriteBlankLines <span class="number">1</span></span><br><span class="line">	f.close</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">set</span> f=fs.opentextfile(<span class="string">&quot;E:\todo\huidang\keyData\keyData.txt&quot;</span>,<span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">	f.writeblanklines <span class="number">2</span></span><br><span class="line">	f.write serverId</span><br><span class="line">	f.write roleId</span><br><span class="line">	f.write data</span><br><span class="line">	f.WriteBlankLines <span class="number">1</span></span><br><span class="line">	f.close</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27; 146 测试</span></span><br><span class="line"><span class="keyword">function</span> seachsshTest(serverId, roleId)</span><br><span class="line">    xsh.Screen.Send(<span class="string">&quot;cd gm 读取回档路径&quot;</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="string">&quot;ls -lAFR | grep xxxx | head -n 1&quot;</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line">	<span class="keyword">dim</span> readline</span><br><span class="line">	screenrow = xsh.Screen.CurrentRow - <span class="number">2</span></span><br><span class="line">	readline = xsh.Screen.<span class="keyword">Get</span>(screenrow, <span class="number">28</span>, screenrow, <span class="number">99</span>)</span><br><span class="line">	<span class="keyword">dim</span> str1:str1 = <span class="built_in">Split</span>(readline, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">	<span class="keyword">dim</span> str2:str2 = <span class="built_in">Split</span>(str1(<span class="number">0</span>), <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">call</span> writeTxt(serverId, roleId, str2(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27; 跳板机操作</span></span><br><span class="line"><span class="keyword">function</span> seachssh(serverId, roleId)</span><br><span class="line">	xsh.Screen.Send(<span class="string">&quot;ssht &quot;</span> + serverId)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="string">&quot;cd apps/mtgl_server/exportData/human_rollback_data/&quot;</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="string">&quot;ls -lAFR |  grep &quot;</span> + roleId + <span class="string">&quot; | head -n 1&quot;</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line">	screenrow = xsh.Screen.CurrentRow - <span class="number">2</span></span><br><span class="line">	readline = xsh.Screen.<span class="keyword">Get</span>(screenrow, <span class="number">28</span>, screenrow, <span class="number">99</span>)</span><br><span class="line">	<span class="keyword">dim</span> str1:str1 = <span class="built_in">Split</span>(readline, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">	<span class="keyword">dim</span> str2:str2 = <span class="built_in">Split</span>(str1(<span class="number">0</span>), <span class="string">&quot;_&quot;</span>)</span><br><span class="line">	<span class="keyword">call</span> writeTxt(serverId, roleId, str2(<span class="number">1</span>))</span><br><span class="line">	xsh.Screen.Send(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">	xsh.Screen.Send(<span class="built_in">chr</span>(<span class="number">13</span>))</span><br><span class="line">	xsh.Session.Sleep(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> readTxt()</span><br><span class="line">	<span class="keyword">set</span> fs=<span class="built_in">createobject</span>(<span class="string">&quot;scripting.filesystemobject&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span>(fs.fileexists(<span class="string">&quot;E:\todo\huidang\keyData\roleData.txt&quot;</span>)) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> f =fs.opentextfile(<span class="string">&quot;E:\todo\huidang\keyData\roleData.txt&quot;</span>,<span class="number">1</span>,<span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">Do</span> until f.atendofstream   </span><br><span class="line">			line=f.readline</span><br><span class="line">			<span class="keyword">dim</span> str</span><br><span class="line">			str = <span class="built_in">Split</span>(line, <span class="string">&quot;	&quot;</span>)</span><br><span class="line">			<span class="keyword">call</span> seachssh(str(<span class="number">0</span>),str(<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">Loop</span></span><br><span class="line">		f.Close</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>



<h2 id="回档实现方案"><a href="#回档实现方案" class="headerlink" title="回档实现方案"></a>回档实现方案</h2><blockquote>
<ol>
<li>按照玩家异常数据镜像导出json文件 和时间节点</li>
<li>根据节点回档</li>
<li>具体实现 在 【back&#x2F;backGM.java】</li>
</ol>
</blockquote>
<h1 id="反外挂"><a href="#反外挂" class="headerlink" title="反外挂"></a>反外挂</h1><h2 id="更新之后-维护期间操作"><a href="#更新之后-维护期间操作" class="headerlink" title="更新之后 维护期间操作"></a>更新之后 维护期间操作</h2><ol>
<li><p>清理战斗校验次数 gsc后台 &#x2F;clearCheck</p>
</li>
<li><p>关闭战斗校验自动封号 gsc后台 &#x2F;setCloseAutoCheck true</p>
</li>
</ol>
<blockquote>
<ul>
<li>观察对外后外挂次数新增情况，比较集中的外挂是前几个服和后几个服，主要看人比较多的服务器是不是有<br>异常的次数激增</li>
<li>（<strong>重要</strong>）对新增的次数玩家尤其是高等级玩家要确认一下，比如战斗类型，伤害的json 就是有一个观察期<br>确保更新没带来战斗校验的问题而对玩家误抓的可能，哪怕就算不开自动封禁让外挂跑一段时间也不能大面<br>积误封</li>
<li>具体观察周期视情况而定，开服后不能少于一小时，如果有任何疑虑和问题及时反馈东方和亮亮排查。等确<br>认稳定后开始自动封禁，完成更新。</li>
<li>期间外挂群内告警确定是外挂需要手动封榜封号</li>
</ul>
</blockquote>
<ol start="3">
<li>开启战斗校验自动封号 &#x2F;setCloseAutoCheck false</li>
</ol>
<h2 id="对比数据："><a href="#对比数据：" class="headerlink" title="对比数据："></a>对比数据：</h2><ol>
<li>打龙会输出如下信息 自上线起 打龙未出现误封 可以判定外挂</li>
</ol>
<p><img src="/.%5Cpic%5ClongFeng.png" alt="image-20230129180106309"></p>
<ol start="2">
<li><p>外挂使用日志查看战斗数据 server. log 查看并对比客户端和服务器伤害值 做成json文件发给客户端</p>
</li>
<li><p>对应的二进制文件mtgl_server&#x2F;battle_check_input 下文件</p>
<p><img src="/.%5Cpic%5Cbattle_check_input.png" alt="battle_check_input"></p>
</li>
<li><p>历史封禁数据在logs的error*.log查看</p>
</li>
<li><p>警告信息监听的是xdb.log 10分钟内外挂数据</p>
</li>
</ol>
<h2 id="战斗校验计次规则"><a href="#战斗校验计次规则" class="headerlink" title="战斗校验计次规则"></a>战斗校验计次规则</h2><ol>
<li>服务器胜负结果不一致即认定外挂并记录次数</li>
<li>次数记录在游戏服 通过网关后台 查看admin</li>
<li>页面显示的封禁数据是5天内的热数据 可以以通过查询角色按钮查询过期数据</li>
</ol>
<h2 id="封禁规则"><a href="#封禁规则" class="headerlink" title="封禁规则"></a>封禁规则</h2><h3 id="OB首周试封禁外挂规则"><a href="#OB首周试封禁外挂规则" class="headerlink" title="OB首周试封禁外挂规则:"></a>OB首周试封禁外挂规则:</h3><ol>
<li>程序在服务器运行时自动识别外挂，对于识别出认定为外挂的玩家进行第一步封禁：拉黑排行榜（所有榜单），如果在推图阵容推荐，即刻删除（后续通关的玩家补位）。</li>
<li>对于（1）步骤，随即输出Log，通过企业微信机器人发送消息，外挂玩家服务器，角色名，角色ID，战力，等级，战斗校验失败次数输出。</li>
<li>运营同学根据（2）的告警信息，对玩家进行人工识别，充值信息，等级，战力，阵容，养成<br>情况等，如果确认，随即进行封号处理，如果觉得误封通知研发进行排行榜黑名单恢复。<br>识别外挂的原则：玩家对于配置表里的战斗关卡通关结果，服务器校验失败超过30次（次数随近几<br>天观察可以随时调整）</li>
</ol>
<h3 id="OB第二周自动封禁外挂规则："><a href="#OB第二周自动封禁外挂规则：" class="headerlink" title="OB第二周自动封禁外挂规则："></a>OB第二周自动封禁外挂规则：</h3><ol>
<li>自动封禁一个用户 输出以下信息：耍外挂的战斗类型和对应次数，充值总额，爬塔层数，推图进度，等级，战力，VIP等级</li>
<li>打龍一次即封榜，作弊10次自动封榜,作弊15次自动封号</li>
</ol>
<h2 id="针对外挂的处理方案"><a href="#针对外挂的处理方案" class="headerlink" title="针对外挂的处理方案"></a>针对外挂的处理方案</h2><p>会按照充值额度区分处罚力度，详细信息如下：</p>
<p><img src="/.%5Cpic%5Cwaigua.png" alt="image-20230129180731539"></p>
<h3 id="服务器回档记录"><a href="#服务器回档记录" class="headerlink" title="服务器回档记录"></a>服务器回档记录</h3><p>**<img src="/.%5Cpic%5Cjilu.png" alt="image-20230129180709866"></p>
<h1 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h1><ul>
<li>gsc平台：<a href="http://gsc.z4v.cn/v3/gsc/gamecontrol?product=20000062&language=01">运营管理 (z4v.cn)</a></li>
<li>mt后台：<a href="http://web-20000062.longtugame.cn/#/dashboard">admin</a></li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><blockquote>
<p>修改一下1001服的战斗校验连接数配置在&#x2F;home&#x2F;ltgame&#x2F;apps&#x2F;mtgl_server&#x2F;config&#x2F;battlecheck.properties里面的<br>server.connection.num&#x3D;3<br>改成：server.connection.num&#x3D;7</p>
<p>常用指令</p>
<p>cat error*.log | grep 5013615 | grep BATTLECHECK | grep ERROR | grep resSucc&#x3D;false</p>
<p>cat server.log |  grep GUILD_WAR |  grep 5013615</p>
</blockquote>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>服务器流程</tag>
        <tag>游戏服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP编程(面向对象)基础</title>
    <url>/2021/08/25/JavaBase/OOP%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="OOP编程-面向对象-基础"><a href="#OOP编程-面向对象-基础" class="headerlink" title="OOP编程(面向对象)基础"></a>OOP编程(面向对象)基础</h1><h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><blockquote>
<ul>
<li><p>OOP: Object-Oriented Programming</p>
<ol>
<li>对象: 对象是一个自包含的实体,用一组可识别的特性和行为来标识</li>
<li>类: 类就是具有相同属性和功能的对象的抽象集合</li>
<li>实例: 一个真实的对象(实例化就是创建对象的过程)</li>
</ol>
<blockquote>
<p>类A name; &#x2F;&#x2F; 声明一个 类A的对象 叫name</p>
<p>name &#x3D; new 类A(); &#x2F;&#x2F; 将name对象实例化</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="构造方法-x2F-方法重载"><a href="#构造方法-x2F-方法重载" class="headerlink" title="构造方法&#x2F;方法重载"></a>构造方法&#x2F;方法重载</h2><blockquote>
<ul>
<li>构造方法—构造函数,就是对类进行初始化. 在被new时调用<ol>
<li>所有类都有个默认无参数构造方法,,如果你定义了构造方法,则默认的失效</li>
</ol>
</li>
<li>方法重载提供了创建同名的多个方法的能力, 需要<strong>参数类型</strong>,<strong>参数个数</strong>不同</li>
</ul>
</blockquote>
<h2 id="封装-继承和多态"><a href="#封装-继承和多态" class="headerlink" title="封装,继承和多态"></a>封装,继承和多态</h2><blockquote>
<ul>
<li><p>封装: 每个对象都包含它能进行操作所需要的所有信息, 这就是封装, 所以对象不必依赖其他对象来完成自己的操作,好处:</p>
<ol>
<li>良好的封装能降低耦合</li>
<li>类内部的实现可以自由修改</li>
<li>类有清晰的对外接口</li>
</ol>
</li>
<li><p>继承: 面向对象中 <em>is - a</em> 的关系,可以说为<em>是一个</em> 的关系 . (猫类继承动物类—猫是动物) 继承可使得修改和扩展 继承而来的实现 比较容易</p>
<ol>
<li>子类拥有父类非private的属性和功能</li>
<li>子类具有自己的属性和功能</li>
<li>子类可以通过自己的方式实现弗雷德功能(方法重写)</li>
<li>protected修饰的只对子类公开</li>
</ol>
</li>
<li><p>多态: 不同的对象可以执行相同的动作,但是要通过他们自己的实现代码执行(实现的结果一样,但是行为方式不同)</p>
<ol>
<li>子类以父类的身份出现</li>
<li>子类在工作时以自己的方式实现</li>
<li>子类以父类的身份出现是,子类特有的实行和方法不可使用</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父 f1 =<span class="keyword">new</span> 子（）；<span class="comment">// 每个子类通过自己的方式完成</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><blockquote>
<p>重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。具体实现方式不同</p>
</blockquote>
<h2 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h2><blockquote>
<ul>
<li><p>Java可以把类和方法声明为abstract, 即抽象方法和抽象类</p>
<ol>
<li>抽象类不能实例化</li>
<li>抽象方法必须被自类重写</li>
<li>抽象方法必须在抽象类中</li>
</ol>
</li>
<li><p>抽象类拥有尽可能多的共同代码,尽可能少的数据</p>
<p>J&amp;DP</p>
<ol>
<li>抽象类提供一个继承的出发点–一定使用来继承的</li>
<li>在一个继承关系里 – 树叶是具体类, 树枝是抽象类</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><blockquote>
<p>官方解释:Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p>
<ul>
<li><p>特性</p>
<ol>
<li>实现接口必须实现所有方法和属性</li>
<li>接口中的方法默认抽象的</li>
<li>Java只支持单一继承,但是可以实现多个接口,接口也可以被多个类实现</li>
</ol>
</li>
<li><p>接口回调:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 Interface =<span class="keyword">new</span> 实现（）； <span class="comment">// 接口对象可以调用被实现类中的方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接口和抽象类</p>
<ol>
<li>类是对对象的抽象 ,抽象类是对对象的抽象, 接口是对行为的抽象</li>
<li>如果行为跨越不同的类—可以用接口; 对于一些相似的类对象–用继承抽象类</li>
<li>实现接口和继承抽象类可以一起用不冲突</li>
<li>从设计角度来说: 抽象类是从子类中发现了公共选项,泛化出来的(<strong>重构</strong>); 而接口是预先定义设计出来的</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h2><blockquote>
<p>一般我们在实现主要业务，一些辅助功能一般是父类(一般类或抽象类)中实现好了或者通过委托实现，大多数中一般使用父类，继承父类需要耦合在主类中，使用的委托的方式是解耦主类，使主类不知道谁帮我做了这些事，但是Java中没有对委托进行封装，则需要开发者自己实现。(待完成)</p>
</blockquote>
<h2 id="OOP编程的七大原则"><a href="#OOP编程的七大原则" class="headerlink" title="OOP编程的七大原则"></a>OOP编程的七大原则</h2><blockquote>
<ul>
<li><strong>开闭原则:</strong> 对扩展开放,对修改关闭(首要遵守)</li>
<li>**里氏替换原则: ** 继承必须确保超类拥有的性质在子类中任然成立(尽可能不去重写父类)</li>
<li><strong>依赖倒置原则：</strong>摆脱面向过程中高层依赖底层, 抽象依赖于具体. 而是面向接口编程</li>
<li><strong>单一职责原则：</strong>控制累的粒度大小,将对象解耦合,高内聚(一个类的职责尽量单一)</li>
<li><strong>接口隔离原则：</strong> 为每个类建立属于它们需要的专用接口,使用多个专门的接口比使用单一的总接口要好。</li>
<li><strong>迪米特原则或最少知识原则：</strong> 只与直接朋友通信,或者通过朋友与陌生人传递消息</li>
<li><strong>合成服用原则:</strong> 关联关系优于继承关系。尽量使用 <strong>合成&#x2F;聚合</strong>(has - a)、尽量不使用继承(is - a)。</li>
</ul>
</blockquote>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><p>要做到低耦合</p>
<p>资源时独立的(只有 属性和方法)</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2021/07/25/JavaBase/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程Thread"><a href="#线程Thread" class="headerlink" title="线程Thread"></a>线程Thread</h1><p>[toc]</p>
<blockquote>
<p>Thread隶属于java.lang包下的类 ,java语言的JVM允许程序运行多个线程</p>
<p>Thread:每个线程通过特定Thread对象的run()方法来完成操作,经常把</p>
</blockquote>
<h2 id="程序-线程和进程"><a href="#程序-线程和进程" class="headerlink" title="程序,线程和进程"></a>程序,线程和进程</h2><ul>
<li><p>**程序(Program):**为了完成特定任务, 用某种语言编写的一组指令集合. 即一段静态代码,静态对象</p>
</li>
<li><p>**进程(process):**是指程序的一次执行过程, 或是正在运行的一个程序. 动态过程: 有它自身的产生, 存在和消亡的过程.</p>
<blockquote>
<p>如: 运行中的软件qq 浏览器等</p>
<p>程序是静态的,运行的进程是动态的</p>
</blockquote>
</li>
<li><p>**线程(Thread):**进程细化一些为线程,是一个程序内部的一条执行路径</p>
<blockquote>
<p>当热程序在同一时间可以有多个执行路径, 也就是支持多线程</p>
</blockquote>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>java中线程分为:<strong>守护线程(daemon)<strong>和</strong>用户线程</strong></p>
<blockquote>
<p>虚拟机必须保证用户线程执行完毕,守护线程不需要等待: 如后台记录日志,内存监控,gc垃圾回收等</p>
</blockquote>
<p>守护线程设置: thread.setDemon(true为守护线程)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程就是独立执行的路径</span><br><span class="line">2.在程序运行时，即使没有创建线程，也会有多个线程(javg gc线程，主线程)</span><br><span class="line">3.main()称为主线程 ，为系统的入口，用于执行整个程序</span><br><span class="line">4.在一个进程中，开了多个线程，线程的运行由调度器安排调度，调度器是与操作系统5.紧密相关的，先后顺序是不能人为干预的</span><br><span class="line">6.对同一份资源操作时，会存在资源抢夺问题，要加入并发控制</span><br><span class="line">7.线程会带来额外的开销，cpu调度时间，并发控制开销</span><br><span class="line">8.每个线程在自己的工作内存中交互，内存控制不当会造成数据不一致</span><br></pre></td></tr></table></figure>

<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote>
<p>在JDK中Thread.State枚举表示了线程的六种状态</p>
<p>getState():获取状态:hamburger:</p>
</blockquote>
<ul>
<li><strong>让我们看一下源码, 看一下线程的几个状态</strong></li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java中hread的内部枚举</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">// 线程被声明并且创建后, 尚未启动的线程的线程状态。</span></span><br><span class="line">        NEW,</span><br><span class="line">        <span class="comment">// 可运行的状态, 一般执行了star() 在虚拟机中执行等待分配资源 (如果执行了会执行run方法)</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line">        <span class="comment">// 阻塞了 </span></span><br><span class="line">        BLOCKED,</span><br><span class="line">          <span class="comment">// 等待</span></span><br><span class="line">        WAITING,</span><br><span class="line">        <span class="comment">// 也是等待 但是有等待时间的等待</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        <span class="comment">//线程结束 终止</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如图</p>
<p><img src="https://i.loli.net/2020/05/27/sQ7TN4wSIAkUCFp.png" alt="线程生命周期"></p>
<p><strong>线程生命周期</strong></p>
<h2 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h2><blockquote>
<p><strong>Junit4单元测试线程异常</strong>: 具体原因不太了解但是和junit的实现有关(记到小本本–下次在了解)</p>
</blockquote>
<h3 id="一-继承Thread类"><a href="#一-继承Thread类" class="headerlink" title="一 . 继承Thread类"></a>一 . 继承Thread类</h3><blockquote>
<p>重写run()方法 ,并且用thread.start()启动线程</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadBuild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        threadTest.start();<span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;线程1&quot;</span>);<span class="comment">// 线程命名</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);<span class="comment">// 获取当前线程名 + 变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序中创建了一个 <strong>线程1</strong> 线程 在主线程中启动 线程间是独立执行的 ,如图:</p>
<p><img src="https://sunxinan12138.github.io/images/Thread.png" alt="执行方式图解"></p>
<p><strong>执行方式图解</strong></p>
<p>所以会看到并行交替执行的情况:</p>
<p><img src="https://sunxinan12138.github.io/images/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="并没有顺序"></p>
<p><strong>并没有顺序</strong></p>
</blockquote>
<p>在Thread中有以下代码保证了Start()方法不能重复调用:</p>
<p><img src="https://sunxinan12138.github.io/images/start.png" alt="start的源码"></p>
<p><strong>start的源码</strong></p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h4><blockquote>
<p>用多线程写图片复制&#x2F;用线程实现3个售票窗口(<strong>要考虑产生资源冲突</strong>)(代码emmmm就不粘了)</p>
</blockquote>
<h3 id="二-实现Runnable接口"><a href="#二-实现Runnable接口" class="headerlink" title="二. 实现Runnable接口"></a>二. 实现Runnable接口</h3><blockquote>
<p>实现Runnable接口并且重写run()方法</p>
<p>由于Thread类为一个代理类 代理了Runnable</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现接口的线程创建方式</span></span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();<span class="comment">// Runnable接口实现类对象</span></span><br><span class="line">        <span class="comment">// 将此对象作为形参放入 Thread的构造方法中 并创造对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadTest);</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadTest);</span><br><span class="line">        thread1.setName(<span class="string">&quot;1Thread&quot;</span>);<span class="comment">// 命名</span></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程</span></span><br><span class="line">           thread2.start();</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lamdba表达式（1.8新特性）</span></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run方法&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>Thread 本身就实现了Runnable接口</li>
<li>实现方式优于继承方式<ol>
<li>避免了java中单继承的局限性</li>
<li>在操作同一份资源中,更适合使用实现方式<ol>
<li>一个对象的资源给多个线程使用</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="三-实现Callable接口"><a href="#三-实现Callable接口" class="headerlink" title="三. 实现Callable接口"></a>三. 实现Callable接口</h3><blockquote>
<p>重写的call()方法</p>
<p>需要执行服务和关闭服务(ExecutorService的对象 )<br>ExecutorService service &#x3D; Executors.newFixedThreadPool(3);</p>
<p>提交执行 submit(线程对象)<br>Future f1 &#x3D; service.submit(c);</p>
<p>获取返回值 记得结束服务<br>String s1 &#x3D; (String) f1.get();service.shutdown();</p>
</blockquote>
<h2 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h2><blockquote>
<ol>
<li><p>start(): 启动线程并执行响应的run()方法</p>
</li>
<li><p>run():子线程要执行的代码</p>
</li>
<li><p>currentThread(): 静态的,调用当前的线程</p>
</li>
<li><p>getName()&#x2F;setName(): 获取和设置线程名字</p>
</li>
<li><p>yield(): 调用此方法的线程放弃当前cpu的执行权，礼让别的线程（我让了但是，你们抢不抢得到那不归我管）</p>
</li>
<li><p>join(): 在A线程中调用B.join()方法. （插入A线程中）</p>
<blockquote>
<p><strong>表示</strong>: A线程停止,直到B线程执行完毕 A线程在执行后面的代码</p>
<blockquote>
<p>&#x3D;&#x3D;sleep()和yield()方法&#x3D;&#x3D;</p>
<ul>
<li><p>sleep不考虑优先级&#x2F;yield同优先级</p>
</li>
<li><p>sleep 后是阻塞&#x2F;yield是就绪状态</p>
</li>
<li><p>sleep有异常 &#x2F;而且不会释放线程 – 都不会释放标志锁</p>
</li>
<li><p>sleep比yield有更好的移植性</p>
<p>wait(): 当前线程等待执行wait的线程(要加同步锁 谁等就锁谁)</p>
</li>
<li><p>和notify()&#x2F;notifyAll() 一起用</p>
</li>
<li><p>必须在synchronized中使用</p>
</li>
<li><p>wait会释放标志锁&#x2F;sleep和yield不会</p>
</li>
<li><p>sleep是Thread的 &#x2F; wait是Object的</p>
</li>
<li><p>sleep有异常需要捕获</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p>isAlive(): 判断当前线程是否存活</p>
</li>
<li><p>sleep(long time): 当前线程睡眠time毫秒(1000ms &#x3D; 1s)</p>
<ol>
<li>不会释放线程</li>
</ol>
</li>
<li><p>线程通信中wait()</p>
</li>
<li><p>notify()：释放优先级高的等待的线程</p>
</li>
<li><p>notifyAll()：释放所有等待的线程</p>
</li>
<li><p>设置线程的优先级</p>
<blockquote>
<p>getPriority(): 返回当前线程优先级</p>
<p>setPriority(int newPriority): 改变当前线程优先级 : 正常为5,最大10,最小是1</p>
</blockquote>
</li>
</ol>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote>
<blockquote>
<p><strong>保证线程安全</strong></p>
</blockquote>
<ul>
<li>尽量避免<strong>共享</strong>资源的存取冲突, 如果必须有共享资源, 那就设计一个规则(锁)来保证, 同时间只有一个线程访问资源 而且<strong>一个客户</strong>的计算工作由<strong>一个线程</strong>解决</li>
</ul>
</blockquote>
<blockquote>
<p>线程不安全的集合:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">线程不安全</th>
<th align="left">对应线程安全</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriterArrayLis&#x2F;vector</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HashMap</td>
<td align="left">HashTable</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">StringBuilder</td>
<td align="left">StringBuffer</td>
</tr>
</tbody></table>
<ol>
<li>Servlet&#x2F;Controller线程不安全的</li>
</ol>
</blockquote>
<blockquote>
<p>刚才的窗口买票程序就会出现安全问题</p>
<p>原因:由于多个线程在操作共享的数据时,在其中一个线程未执行完毕时,另一个线程进入,导致共享数据出现问题</p>
</blockquote>
<p><img src="https://i.loli.net/2020/05/28/EhVquDZ5Bwpit4g.png" alt="线程安全出现的原因.png"></p>
<p><strong>线程安全出现的原因.png</strong></p>
<ul>
<li><p>如何解决线程安全的问题?</p>
<blockquote>
<p>想办法热那个一个线程操作数据完毕后,其他线程才能操作</p>
</blockquote>
</li>
<li><p>java中实现线程安全,线程同步机制:</p>
<blockquote>
</blockquote>
<ul>
<li><p>一 同步代码块</p>
<blockquote>
<p>synchronized关键字 — 要有一个对象充当同步监视器(缺点:会影响效率)</p>
<p>同步监视器:由一个类的对象充当.当一个线程获取监视器,就执行代码.(通一把锁的对象一定是同一个对象) — <strong>锁</strong></p>
</blockquote>
<p><img src="https://i.loli.net/2020/05/28/dEHqCfLVynIOJQP.png" alt="synchronized.png"></p>
<p><strong>synchronized.png</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现代码:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> public  void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123; // 用本类的对象为同步监视器</span><br><span class="line">                if (ticket &gt; 0) &#123; // 如果有票 修改变量</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10); // 假设睡眠</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二 同步方法</p>
<blockquote>
<p>保证同一时间只有一个线程访问此方法</p>
<p>用synchronized修饰方法: public synchronized void method()叫同步方法</p>
<p>同步监视器对象默认为当前对象</p>
</blockquote>
</li>
<li><p>在单例模式中 – <a href="https://sunxinan12138.github.io/2020/05/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">锁的问题(双重锁定)</a></p>
</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote>
<ul>
<li>概念: 不同的线程分别占用对方的同步资源不放弃,都在等待对方放弃自己需要的同步资源,就形成了死锁</li>
<li>解决办法:<ul>
<li>算法, 原则</li>
<li>尽量减少同步资源的定义</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="LOCK锁"><a href="#LOCK锁" class="headerlink" title="LOCK锁"></a>LOCK锁</h4><blockquote>
<ul>
<li>从JDk5.0开始, JAVA提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步. 同步锁使用Lock对象充当</li>
<li>Java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具. 锁提供了对共享资源的独占访问, 每次只能有一个线程对Lock对象加锁, 线程开始访问共享资源之前硬获得Lock对象</li>
<li>ReentrantLock(可重入锁)类实现了Lock, 它拥有与synchronized相同的并发性,在实现线程安全控制中,比较常用的是ReentrantLock, 可以显式加锁,释放锁</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Lock与synchronized的对比</strong></p>
<ul>
<li>Lock是显式锁(需要手动开关) synchronized是隐式锁,自动释放</li>
<li>Lock只是锁代码块</li>
<li>使用Lock, JVM调度线程花费时间少,性能好. 而且具有更好的扩展性(提供更多的子类)</li>
<li>优先级:<ul>
<li>Lock &gt; 同步代码块&gt;同步方法</li>
</ul>
</li>
</ul>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123; <span class="comment">// 官方建议用Try，catch， finally</span></span><br><span class="line">           lock.lock();<span class="comment">// 加锁</span></span><br><span class="line">              <span class="comment">// 需要加锁的代码区</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();<span class="comment">// 解锁</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>一种处理并发数据的方式 将数据 隔离 每个线程单独持有</p>
<ol>
<li>用空间换时间</li>
<li>创建副本进行数据隔离</li>
</ol>
<ul>
<li><p>要求是多个线程用一个对象,但是每个线程的对象是独立的</p>
</li>
<li><p>每个线程独立的改变自己的变量副本,不去影响其他线程</p>
</li>
<li><p>Thread里面包含 ThreadLocal</p>
<p><img src="https://i.loli.net/2020/10/02/AOLEhVptz3QDa1y.png" alt="image-20200720211033368.png"></p>
<p><strong>image-20200720211033368.png</strong></p>
<p><img src="https://i.loli.net/2020/10/02/LcskzqfCXDpAihu.png" alt="image-20200720211926178.png"></p>
<p><strong>image-20200720211926178.png</strong></p>
</li>
<li><p>内部类ThreadLocalMap: k-v组成的entry[]数组</p>
</li>
<li><p>key是ThreadLocal的弱引用</p>
<ul>
<li>val就是值</li>
</ul>
</li>
</ul>
<p>get: 获取</p>
<p>set: 存储</p>
<p>remove: 移除</p>
<p>initialValue :重写</p>
<ul>
<li><p><strong>内存泄漏问题</strong></p>
<p>由于key的Thread是弱引用 所以会存在key是null 但是val是强引用 就会内存泄漏</p>
<p>解决方法:是每一次get和set,remove时都会清楚为null的val 下一次垃圾回收就会清除了</p>
<p>所以调用一下remove就行了</p>
</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&quot;</span> + DateUtilSafe.parsesss(<span class="string">&quot;2020-20-20 21:50:90&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">.................</span><br><span class="line">        service.shutdown();</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtilSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 写这个才安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-DD HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parsesss</span><span class="params">(String dateStr)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = THREAD_LOCAL.get().parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote>
<p>关键字:wait(), notify()和 notifyAll() – 线程调度的方法</p>
<ul>
<li>wait(): 令当前线程挂起cpu&#x2F;同步资源器, 使别的线程可以访问并修改公共资源,当前线程会在排队等待状态.</li>
<li>notify():唤醒正在排队等待同步资源的的<strong>优先级最高</strong>的线程 – 结束等待</li>
<li>notifyAll(): 唤醒正在排队等待同步资源的的<strong>所有</strong>线程 – 结束等待</li>
</ul>
<p>注意: 这三个方法为java.lang.Object下的 而且只有在synchronized方法或代码块中才会使用.</p>
</blockquote>
<h2 id="写个生产者-x2F-消费者练习-不是OO的Pattern"><a href="#写个生产者-x2F-消费者练习-不是OO的Pattern" class="headerlink" title="写个生产者&#x2F;消费者练习(不是OO的Pattern)"></a>写个生产者&#x2F;消费者练习(不是OO的Pattern)</h2><p><img src="https://i.loli.net/2020/06/01/jQAPyZdFRN1Ye4w.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<blockquote>
<p>分析:</p>
<p>markdown</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 是否考虑线程</span><br><span class="line"><span class="bullet">2.</span> 是否涉及共享数据</span><br><span class="line"><span class="bullet">3.</span> 如果有共享数据 考虑线程安全/同步的问题</span><br><span class="line"><span class="bullet">4.</span> 是否有线程通信</span><br></pre></td></tr></table></figure>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管城法</span></span><br><span class="line"><span class="comment">// 生产者做东西 消费者买 (通信:生产到20 停止生产 0开始生产停止购买)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2CTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 主线程</span></span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产1&quot;</span>);</span><br><span class="line">        p2.setName(<span class="string">&quot;生产2&quot;</span>);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费1&quot;</span>);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费2&quot;</span>);</span><br><span class="line">        c3.setName(<span class="string">&quot;消费3&quot;</span>);</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123; <span class="comment">// 店员 公共部分</span></span><br><span class="line">    <span class="type">int</span> product;<span class="comment">// 生产到20 停止生产 0开始生产停止购买</span></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &gt;= <span class="number">20</span>) &#123; <span class="comment">// 如果作满了 停止制作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;暂停制作&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            product += num;<span class="comment">// 添加制作数量</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产了: &quot;</span> + num + <span class="string">&quot;====现在还有&quot;</span> + product);</span><br><span class="line">            <span class="keyword">if</span> (product &gt;= <span class="number">1</span>) &#123; <span class="comment">// 如果有存货就释放锁 让用户购买</span></span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buyProduct</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;暂停购买&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            product -= num;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;购买了了: &quot;</span> + num + <span class="string">&quot;====现在还有&quot;</span> + product);</span><br><span class="line">            <span class="keyword">if</span> (product &lt; <span class="number">20</span>) &#123; <span class="comment">// 如果数量不足释放生产者来制作</span></span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">// 生产者</span></span><br><span class="line">    Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            clerk.addProduct(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 消费者</span></span><br><span class="line">    Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            clerk.buyProduct(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>出现的问题</p>
</blockquote>
<p>在等待中推荐使用wait 如果使用 if 将会有肯能出现虚假唤醒问题:</p>
<ul>
<li><p>线程可以唤醒但是不会被通知, 中断或者超时,即所谓的虚假唤醒. 发生概率虽然还很小, 但是程序必须通过测试应该使线程被唤醒的条件来防范, 并且如果条件不满足则继续等待.</p>
</li>
<li><p>等待应该总是出现在循环中</p>
</li>
<li><p>原因:</p>
<blockquote>
<p>本质在于 if 和while 的区别 : if中挂起了 如果被唤醒会继续执行但是这个唤醒有可能不正确</p>
</blockquote>
<ol>
<li>两个消费者线程发现剩余0 于是唤醒生产者 自己<strong>挂起</strong>;(if判断)</li>
<li>生产者生产一个 唤醒所有消费者 两个消费者 不管谁先获得锁 都是继续if 执行</li>
<li>但是 其中一个消费过后 下一个应该挂起但是没有了判断 所以被虚假唤醒了</li>
</ol>
</li>
<li><p>解决 把等待放到while中 让他循环判断</p>
</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (product &gt;= 20) &#123; </span></span><br><span class="line"><span class="comment">    wait();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">修改为:</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">while</span>(product &gt;= <span class="number">20</span>)&#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---------------</span></span><br><span class="line">    <span class="keyword">if</span> (product &gt;= <span class="number">1</span>) &#123; </span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<ul>
<li>将线程放入池子,方便使用和管理,也避免了销毁造成的浪费</li>
<li>3.Java线程池（工具）</li>
<li>线程池有很多种，但是核心线程池ThreadPoolExecutor。</li>
<li>ExecutorService:线程池接口</li>
<li>Executors(Runable 接口):工具类,线程池工厂</li>
</ul>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池：内含了一些线程数量，以及拒绝策略，阻塞队列...内容。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,       //核心线程数,工作的</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,      //最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, //最大活跃时间，如果超过最大活跃时间，不工作的线程被回收（优先回收非核心线程）</span></span><br><span class="line"><span class="params">                          TimeUnit unit,        //时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程工厂，创建线程的方式</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>&#123; <span class="comment">//拒绝策略</span></span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>假设线程池中有20个线程，10个核心线程数，当有10个任务来临，优先使用核心线程来工作，如果又来1个任务:</p>
<ol>
<li>第一，创建一个非核心线程工作</li>
<li>第二，进入阻塞队列</li>
<li>阻塞队列共有4种：S&gt;L&gt;A:<ol>
<li>SynchronousQueue:同步队列，如果有任务进入队列，直接创建一个线程工作。</li>
<li>LinkedBlockingQueue:链表阻塞队列，如果有任务进入队列，直接排队，按照先进先出的规则进行执行，先排队，先执行。</li>
<li>ArrayBlockingQueue:数组阻塞队列，如果有任务进入队列，直接排队，按照先进先出的规则进行执行，先排队，先执行。</li>
<li>DelayQueue:延迟队列，如果有任务进入队列，先排队，但是不立即执行，而是等到延迟时间到了，再执行。</li>
</ol>
</li>
</ol>
</li>
<li><p>拒绝策略也有4种：当有任务来临时，如果超过了线程池的规定线程数，可以选择任务执行的策略。</p>
<ol>
<li>直接丢弃（DiscardPolicy）</li>
<li>队列中最老的任务（DiscardOldestPolicy）</li>
<li>抛出异常（AbortPolicy），默认策略</li>
<li>将任务分配调用线程来执行（CallerRunsPolicy）</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义核心线程数</span><br><span class="line">private static final int MAX_CORE = 4;</span><br><span class="line">//定义最大线程数</span><br><span class="line">private static final int MAX_THREAD_NUM = 10;</span><br><span class="line">//定义活跃时间,单位毫秒</span><br><span class="line">private static final long MAX_ACTIVE_TIME = 3000;</span><br><span class="line">//定义阻塞队列</span><br><span class="line">private static LinkedBlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//定义一个线程执行器</span><br><span class="line">private static ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">//静态代码块</span><br><span class="line">static &#123;</span><br><span class="line">    //实例化一个线程池执行器</span><br><span class="line">    ThreadPoolExecutor executor = new ThreadPoolExecutor(MAX_CORE,</span><br><span class="line">            MAX_THREAD_NUM,</span><br><span class="line">            MAX_ACTIVE_TIME,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            workQueue</span><br><span class="line">            );</span><br><span class="line">    //允许核心线程超时，核心线程也在销毁之内</span><br><span class="line">    executor.allowCoreThreadTimeOut(true);</span><br><span class="line">    //将创建出来的线程池执行器赋值给成员变量</span><br><span class="line">    threadPoolExecutor = executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  /*threadPoolExecutor = new ThreadPoolExecutor(MAX_CORE,</span><br><span class="line">          MAX_THREAD_NUM,</span><br><span class="line">          MAX_ACTIVE_TIME,</span><br><span class="line">          TimeUnit.MILLISECONDS,</span><br><span class="line">          workQueue);*/</span><br><span class="line">  for(int i = 1;i &lt;= 20;i++)&#123;</span><br><span class="line">      Runnable r =  new Runnable()&#123;</span><br><span class="line">          public void run()&#123;</span><br><span class="line">              try&#123;</span><br><span class="line">                  Thread.sleep(1000);</span><br><span class="line">              &#125;catch (Exception e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              for(int i = 1;i &lt;= 10;i++)&#123;</span><br><span class="line">                  System.out.println(&quot;i = &quot; + i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPoolExecutor.execute(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">// 数量</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">SJSThread</span>);</span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">SJSThread</span>);</span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">SJSThread</span>);</span><br><span class="line">service.shutdown();<span class="comment">//结束线程连接池</span></span><br></pre></td></tr></table></figure>

<h2 id="同步-x2F-异步"><a href="#同步-x2F-异步" class="headerlink" title="同步&#x2F;异步"></a>同步&#x2F;异步</h2><blockquote>
<ul>
<li>异步: (非阻塞)<ol>
<li>当程序正在执行一个较长时间的程序, 不等待他的返回,就是异步</li>
<li>异步效率高.</li>
</ol>
</li>
<li>同步:(阻塞)<ol>
<li>当程序中存在竞争资源, 或者正在读取的数据可能被修改 就使用同步存取</li>
<li>如果有公共数据就要用同步方法</li>
<li>数据库的排它锁</li>
</ol>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的工厂模式</title>
    <url>/2021/07/25/JavaBase/%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单的工厂模式-大话设计模式"><a href="#简单的工厂模式-大话设计模式" class="headerlink" title="简单的工厂模式 - 大话设计模式"></a>简单的工厂模式 - 大话设计模式</h1><p>*<strong>每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心。*</strong></p>
<blockquote>
<p>先了解面向对象设计</p>
</blockquote>
<blockquote>
<p>当你需要实例化哪个类,或者未来会不会增加实例化对象,所以考虑用一个单独的类来做这个创造实例化的过程–工厂</p>
</blockquote>
<blockquote>
<p>耦合度降低 每个实例是相对独立的 做到了<strong>容易维护,扩展和复用</strong></p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><p><img src="https://sunxinan12138.github.io/images/SimpleFactory.png" alt="简单的工厂模式"></p>
<p><strong>简单的工厂模式</strong></p>
<p>1.PO类</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjs.SimpleFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">double</span> numberA;</span><br><span class="line">    <span class="type">double</span> numberB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getNumberA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberA</span><span class="params">(<span class="type">double</span> numberA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numberA = numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getNumberB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberB</span><span class="params">(<span class="type">double</span> numberB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numberB = numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getReasult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.加减乘除类(封装类继承基类)</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjs.SimpleFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="comment">// 重写getResult方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getReasult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.numberA + <span class="built_in">super</span>.numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="comment">// 重写getResult方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getReasult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.numberA - <span class="built_in">super</span>.numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.简单工厂类</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjs.SimpleFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 当你输入表达式工厂自动匹配类创建对象</span></span><br><span class="line">    <span class="comment">// 实例化对象的问题交给工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">operation</span><span class="params">(String operate)</span> &#123;<span class="comment">// 用符号自动匹配要创建的实例</span></span><br><span class="line">        <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="comment">// add</span></span><br><span class="line">                operation = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="comment">// sub</span></span><br><span class="line">                operation = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.使用简单工厂模式</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjs.SimpleFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单工厂模式()</span></span><br><span class="line">        <span class="comment">// 用工厂类自动创建实例</span></span><br><span class="line">        <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> OperationFactory.operation(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        operation.setNumberA(<span class="number">12</span>);</span><br><span class="line">        operation.setNumberB(<span class="number">23</span>);</span><br><span class="line">        System.out.println(operation.getReasult());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有代理模式</span></span><br><span class="line"><span class="comment">//        Operation add = new Add();</span></span><br><span class="line"><span class="comment">//        add.setNumberA(12);</span></span><br><span class="line"><span class="comment">//        add.setNumberB(23);</span></span><br><span class="line"><span class="comment">//        System.out.println(add.getReasult());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Operation sub = new Sub();</span></span><br><span class="line"><span class="comment">//        sub.setNumberA(12);</span></span><br><span class="line"><span class="comment">//        sub.setNumberB(23);</span></span><br><span class="line"><span class="comment">//        System.out.println(sub.getReasult());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2021/07/25/JavaBase/redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>redis  介绍</p>
</blockquote>
<p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务。是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于<strong>内存</strong>亦<strong>可持久化</strong>的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。[百度百科]</p>
<blockquote>
<p>官网介绍</p>
</blockquote>
<p>Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 Redis提供数据结构，例如字符串，哈希列表，集合，排序集，带有范围查询，位图，超级目录，地理空间索引和流。 Redis拥有内置复制，Lua Scripting，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供高可用性</p>
<blockquote>
<p>redis 用途</p>
</blockquote>
<ol>
<li>内存存储，持久化，持久化机制（rdb,aof）</li>
<li>高效，用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计量器，计数器</li>
<li>。。。</li>
</ol>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis  默认16个db 使用第0个</p>
<p>端口6379 是因为作者的偶像的9键名字。</p>
<blockquote>
<p>redis 是单线程的</p>
</blockquote>
<p>redis是很快的，官方介绍，Redis基于内存操作，CPU不是Redis的性能瓶颈，Redis的瓶颈瑟吉欧根据机器的内存和网络带宽，既然可以单线程实现，就使用单线程了。</p>
<p>Redis是C语言写的。挂房提供数据：100000+ 的QPS， 和Memecache不相上下。</p>
<blockquote>
<p>为什么Redis是单线程还这么快？</p>
</blockquote>
<p>单线程和多线程认识误区：</p>
<ol>
<li>高性能服务器<strong>不</strong>一定是多线程。</li>
<li>多线程（CPU是上下文切换）一定<strong>不比</strong>多线程高</li>
</ol>
<p>速度：CPU&gt;内存&gt;硬盘。 cpu切换非常耗时间。</p>
<p>reids将所有数据存放内存中。所以单线程去操作效率就是最高的，多线程（CPU上下文切换消耗时间），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都在同一个CPU上的，在内存情况下，这就是最佳方案。</p>
<h2 id="Redis-Benchmark-性能测试"><a href="#Redis-Benchmark-性能测试" class="headerlink" title="Redis -Benchmark 性能测试"></a>Redis -Benchmark 性能测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>-h</strong></td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>-p</strong></td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>-s</strong></td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>-c</strong></td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>-n</strong></td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>-d</strong></td>
<td align="left">以字节的形式指定 SET&#x2F;GET 值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>-k</strong></td>
<td align="left">1&#x3D;keep alive 0&#x3D;reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>-r</strong></td>
<td align="left">SET&#x2F;GET&#x2F;INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>-P</strong></td>
<td align="left">通过管道传输 <numreq> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>-q</strong></td>
<td align="left">强制退出 redis。仅显示 query&#x2F;sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>–csv</strong></td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">***-l*（L 的小写字母）**</td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>-t</strong></td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">***-I*（i 的大写字母）**</td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 --restart unless-stopped -v /home/redis/data:/data -v /home/redis/conf/redis.conf:/etc/redis/redis.conf -d redis:buster redis-server /etc/redis/redis.conf </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">自启</span><br><span class="line">/usr/local/bin/redis-server  /usr/soft/redis/redis-6.2.5/etc/redis.conf</span><br></pre></td></tr></table></figure>



<h2 id="Redis-Key命令"><a href="#Redis-Key命令" class="headerlink" title="Redis Key命令"></a>Redis Key命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num： 切换第num个数据库</span><br><span class="line">DBSIZE： 查看dbSize</span><br><span class="line">keys * ： 查看keys</span><br><span class="line">flushdb ：清空</span><br><span class="line">flushAll : 清空所有</span><br><span class="line">move key （1 数据库）： 移除key 一般不用？？？</span><br><span class="line">-------------------</span><br><span class="line">set key val : 插入</span><br><span class="line">mset 批量添加</span><br><span class="line">-------------------</span><br><span class="line">mget 批量获取</span><br><span class="line">expire key time： time后失效</span><br><span class="line">setex key time val : time后失效</span><br><span class="line">setinx ： 不存在设置</span><br><span class="line">setnx : 不存在创建</span><br><span class="line">ttl key : 实时查看过期时间</span><br><span class="line">type kay ： 查看 key的类型</span><br><span class="line">Exists key ： 是否存在</span><br><span class="line">-------------------</span><br><span class="line">i++</span><br><span class="line">decr/ incr key ： 减一/加一</span><br><span class="line">decrby/ incrby key num: 减/加 num</span><br><span class="line">--------------------</span><br><span class="line">msetnx: 原子性 批量添加</span><br><span class="line"></span><br><span class="line">getset key val： 不存在返回null  存在 返回旧 插入新 ==CAS==</span><br></pre></td></tr></table></figure>



<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>append key ： 追加Str<br>strlen key ： 返回长度<br>getRange key star end : 截取长度【star , end】<br>setRange key star end “str” : 替换[s到n]字符串</p>
</blockquote>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote>
<p>lpush key val : 头部从左近入</p>
<p>Rpush ： 尾部右插入</p>
<p>Lpop key ： 移出左侧</p>
<p>rPop  ： 右侧移出</p>
<p>lRange key a b 获取第[a,b]数据</p>
<p>lindex key val 获取某一个值</p>
<p>llen ： 长度</p>
<p>trim  a,b： 截取 剩下 [a,b] 的数据</p>
<p>rpoplPush  souce tar : 右侧移除最后一个 左侧添加一个</p>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>sadd key val : 添加</p>
<p>smembers  key ： 查看</p>
<p>sismember key val 查看是否存在set中</p>
<p>srem 移除</p>
<p>srandmember key  num随机查询num个数据</p>
<p>sdiff fox king  # 查看fox集合的差集</p>
<p>sinter fox king  # 查看两个集合的交集</p>
<p>sunion fox king  # 查看两个集合的并集</p>
<hr>
<p>srem fox one  #移除set集合中指定的元素</p>
<p>spop fox    随机删除</p>
<p>smove fox king 1 # 讲一个指定的值、移动到另外一个set集合中</p>
</blockquote>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul>
<li>hash是一个String类型的field（字段）和value（值）的映射表，hash特别适合于存储对象。</li>
<li>Redis中每个Hash可以存储232-1键值对（40多亿）</li>
<li>hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！hash更适于对象是存储，String更加适合字符串！！</li>
</ul>
<blockquote>
<p>hset name keys vals 添加</p>
<p>hget name key</p>
<p>hgetall name 查看</p>
<p>–</p>
<p>hkeys name  查看key</p>
<p>hvals name  查看val</p>
<p>hlen name 数量</p>
<p>hexists name key 是否存在</p>
<p>hdel name key 删除 name的 key段</p>
<p>hincrby name key num  #指定增量 加num</p>
<p>hsetnx name key val  #若不存在、则可以设置、反之不可用设置</p>
</blockquote>
<h3 id="ZSet（sorted-set-有序集合）"><a href="#ZSet（sorted-set-有序集合）" class="headerlink" title="ZSet（sorted set:有序集合）"></a>ZSet（sorted set:有序集合）</h3><blockquote>
<p>zadd name ks  vs  		#添加值</p>
<p>zcard fox  #获取有序集合的成员数</p>
<p>zrange 获取值</p>
<p>zrangebyscore name -inf +inf  			# 查看全部用户，并从小到大排序</p>
</blockquote>
<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h3><ul>
<li>geospatial 地理位置空间   官方网址：<a href="https://www.redis.net.cn/order/3689.html">https://www.redis.net.cn/order/3689.html</a></li>
<li>朋友的定位，附近的人，打车距离计算？</li>
<li>Redis 的 Geo 在Redis3.2版本就推出了！这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</li>
<li>可以查询一些测试数据：<a href="https://jingweidu.51240.com/">https://jingweidu.51240.com/</a></li>
<li>GEO 底层的实现原理：Zset！ 我们可以用Zset命令来操作Geo</li>
</ul>
<blockquote>
<p>getadd 添加地理位置 规则：南北两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</p>
<p>参数 key 值(纬度、经度、名称) (-180度到180度)</p>
<p>纬度: -85.05112878度到85.05112878度<br>geoadd china:city 116.40 39.90 beijing</p>
<p>geopos china:city hangzhou beijing  # 获取指定的城市的经度 和 维度！</p>
<p>geodist china:city hangzhou beijing km geodist 返回两个给定位置之间的距离</p>
<hr>
<p>GEORADIUS china:city 110 30 1000 km   # 以110,30这个经纬度为中心，寻找方圆1000km内的城市<br>GEORADIUS china:city 110 30 500 km withdist # 显示到中间位置的直线距离 半径500km<br> GEORADIUS china:city 110 30 500 km withcoord # 显示到中心距离半径500km的城市 +  经纬度信息<br> GEORADIUS china:city 110 30 500 km withcoord withdist count 3 # 筛选出指定结果<br>GEORADIUSBYMEMBER china:city beijing 1000 km # 找出位于指定范围内的元素，中心点是由给定的位置元素决定</p>
</blockquote>
<h3 id="hyperloglog-位图"><a href="#hyperloglog-位图" class="headerlink" title="hyperloglog 位图"></a>hyperloglog 位图</h3><blockquote>
<p>基数</p>
</blockquote>
<p>基数（一个集合中不重复的元素）<br>统计疫情感染人数：存身份标识码<br>优点：占用的内存是固定的，2^64不同的元素的技术，只需要废12kb内存。如果要从内存角度来比较的话Hyperloglog首选！<br>如果允许容错，那么一定可以使用Hyperloglog <strong>0.81的错误率</strong><br>如果不允许容错，就使用 set 或 自己的数据类型 即可</p>
<blockquote>
<p>pfadd mykey a b c d e f g h i j  # 创建第一组元素 mykey</p>
<p>PFCOUNT mykey  # 统计mykey元素的基数数量</p>
<p>PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2&#x3D;&gt;mykey3并集</p>
</blockquote>
<h3 id="bitmap-位图"><a href="#bitmap-位图" class="headerlink" title="bitmap 位图"></a>bitmap 位图</h3><blockquote>
<ul>
<li>位存储 用于 打卡 登录与否 这类 0&#x2F;1 状态切换的类型 1字节 &#x3D; 8位</li>
</ul>
</blockquote>
<blockquote>
<p>setbit name a b  输入第a条数据为b（0&#x2F;1）</p>
<p>get name x 获取第x天的数据</p>
<p>bitcount name 查看 数据</p>
</blockquote>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p>Redis事务本质：一组命令的集合！一个事务中所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性、顺序性、排他性！执行一系列的命令！<br>Redis事务没有隔离级别的概念！</p>
</li>
<li><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p>
</li>
<li><p>Redis单条命令是保证原子性的，但是事务不保证原子性！</p>
</li>
</ul>
<blockquote>
<p>Redis的事务：<br>一个事务从开始到执行会经历以下三个阶段：</p>
</blockquote>
<blockquote>
<p>开启事务（MULTI)<br>命令入队（）<br>执行事务（EXEC）</p>
</blockquote>
<ol>
<li>MULTI	标记一个事务块的开始。</li>
<li>EXEC	执行所有事务块内的命令。</li>
<li>DISCARD	取消事务，放弃执行事务块内的所有命令。</li>
<li>UNWATCH	取消 WATCH 命令对所有 key 的监视。</li>
<li>WATCH key [key …]	监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li>
</ol>
<h3 id="事务错误异常"><a href="#事务错误异常" class="headerlink" title="事务错误异常"></a>事务错误异常</h3><blockquote>
<p>编译型异常（代码有问题、命令有错）、事务中所有的命令都不会被执行</p>
</blockquote>
<blockquote>
<p>运行时异常（1&#x2F;0）,如果事务队列中存在语法性、那么执行命令的时候、其他命令是可以正常执行的、错误命令抛出异常！</p>
</blockquote>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><blockquote>
<p>watch 监控</p>
</blockquote>
<p>悲观锁：</p>
<ul>
<li>任务怎么样都会出问题，无论什么操作都要加锁。</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>认为不会出问题，只有需要的时候才会上锁。更新数据的时候回去判断一下，在此期间是否数据被修改。</li>
<li>获取version</li>
<li>更新时比较version</li>
</ul>
<blockquote>
<p>watch 监视 unwatch 解锁 提交失败 所有都失败</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;watch money <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;mu1ti</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt;INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1;6379&gt; <span class="built_in">exec</span> <span class="comment">#执行之前，另外一个线程。修改「我们的值，这个时候，就会导改事务执行失败!</span></span><br><span class="line">(ni1)</span><br></pre></td></tr></table></figure>

<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><p>我们要使用java来操作Redis</p>
<blockquote>
<p>什么是Jedis？ 是Redis官方推荐的java连接开发工具！使用java操作Redis的中间件！如果要使用java操作Redis、一定要对Jedis十分的熟悉！</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入Jedis的包--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;8.*.*.76&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;清空数据：&quot;</span> + jedis.flushDB());</span><br><span class="line">       System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span> + jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;username&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class="line">       Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">       System.out.println(keys);</span><br><span class="line">       System.out.println(<span class="string">&quot;删除键password：&quot;</span> + jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span> + jedis.exists(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;查看username所存储的值的类型：&quot;</span> + jedis.type(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span> + jedis.randomKey());</span><br><span class="line">       System.out.println(<span class="string">&quot;重命名key：&quot;</span> + jedis.rename(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;取出改后的name：&quot;</span> + jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;按索引查询：&quot;</span> + jedis.select(<span class="number">0</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class="line">       System.out.println(<span class="string">&quot;返回当前数据库中的key的数目：&quot;</span> + jedis.dbSize());</span><br><span class="line">       System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span> + jedis.flushAll());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;8.*.*.*&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">       jedis.flushDB();</span><br><span class="line">       System.out.println(<span class="string">&quot;==========增加数据==========&quot;</span>);</span><br><span class="line">       System.out.println(jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">       System.out.println(jedis.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">       System.out.println(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;删除键key2：&quot;</span> + jedis.del(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;获取键key2：&quot;</span> + jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;修改key1：&quot;</span> + jedis.set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;valueChanged&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;获取key1的值：&quot;</span> + jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;在key3后面加入值：&quot;</span> + jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;key3的值：&quot;</span> + jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span> + jedis.mset(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;value01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;value02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;value03&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>,  <span class="string">&quot;key02&quot;</span>,  <span class="string">&quot;key03&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span> + jedis.del(<span class="string">&quot;key01&quot;</span>,  <span class="string">&quot;key02&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>,  <span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">       jedis.flushDB();</span><br><span class="line">       System.out.println(<span class="string">&quot;=============新增键值对防止覆盖原先值=================&quot;</span>);</span><br><span class="line">       System.out.println(jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">       System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">       System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;新增键值对并设置有效时间&quot;</span>);</span><br><span class="line">       System.out.println(jedis.setex(<span class="string">&quot;key3&quot;</span>, <span class="number">2</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;================获取原值，更新为新值==============&quot;</span>);</span><br><span class="line">       System.out.println(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;获得key2的值的字串：&quot;</span> + jedis.getrange(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;*.*.*.*&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;==============向集合中添加元素(不重复)==============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e5&quot;</span>, <span class="string">&quot;e6&quot;</span>, <span class="string">&quot;e7&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e8&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e8&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个元素e1:&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除两个元素e7和e4:&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e4&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet中包含元素的个数：&quot;</span> + jedis.scard(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;e3是否在eleSet中：&quot;</span> + jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e5&quot;</span>, <span class="string">&quot;e6&quot;</span>, <span class="string">&quot;e7&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e5&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span> + jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将eleSet1中删除e2并存入eleSet3中：&quot;</span> + jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet3中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;==================集合运算=================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet2中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的交集：&quot;</span>+jedis.sinter(<span class="string">&quot;eleSet1&quot;</span>,<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的并集：&quot;</span>+jedis.sunion(<span class="string">&quot;eleSet1&quot;</span>,<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的差集：&quot;</span>+jedis.sdiff(<span class="string">&quot;eleSet1&quot;</span>,<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的交集个数为：&quot;</span>+jedis.sinterstore(<span class="string">&quot;eleSet4&quot;</span>, <span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;把eleSet1和eleSet2的交集存储到eleSet4中、eleSet4的元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet4&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;*.*.*.*&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;=========添加名称为hash(key)的hash元素============&quot;</span>);</span><br><span class="line">    jedis.hmset(<span class="string">&quot;hash&quot;</span>, map);</span><br><span class="line">    System.out.println(<span class="string">&quot;===向名称为hash的hash中添加key为key5，value为value5的元素====&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key6&quot;</span>,<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key6&quot;</span>,<span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的key3的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的key3、key4的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;key4&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;服务器IP地址&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;fox&quot;</span>);</span><br><span class="line">    <span class="comment">//        开启事务</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">    <span class="comment">//        jedis.watch(string);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        multi.set(<span class="string">&quot;user1&quot;</span>, string);</span><br><span class="line">        multi.set(<span class="string">&quot;user2&quot;</span>, string);</span><br><span class="line">        <span class="comment">//            int i = 1 / 0;//代码抛出异常，执行失败！</span></span><br><span class="line">        multi.exec();<span class="comment">//执行事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        multi.discard();<span class="comment">//放弃事务</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">        jedis.close();<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot-整合"><a href="#SpringBoot-整合" class="headerlink" title="SpringBoot 整合"></a>SpringBoot 整合</h2><ul>
<li>在springboot2.X之后，原来使用的jedis被替换为了lettuce</li>
<li>jedis：采用的直接连接，多个线程操作的话，会不安全，如果要避免不安全，使用jedis Pool连接池 类似BIO模式。</li>
<li>lettuce：采用nett ，实例可以再多个线程中共享，不存在线程不安全的情况！可以减少线程数据，更像NIO模式。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RedisAutoConfigUration 自动配置类</span></span><br><span class="line"><span class="comment"># RedisProperTies 配置文件</span></span><br><span class="line"><span class="comment"># 配置文件：</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">8.131.86.76</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis02SpringbootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">/*   redisTemplate 操作不同的数据类型.api和我们的指令是一样的</span></span><br><span class="line"><span class="comment">        opsForValue 操作字符串 类似String</span></span><br><span class="line"><span class="comment">        opsForList  操作list</span></span><br><span class="line"><span class="comment">        opsForSet</span></span><br><span class="line"><span class="comment">        opsForHash</span></span><br><span class="line"><span class="comment">        opsForZSet</span></span><br><span class="line"><span class="comment">        opsForGeo</span></span><br><span class="line"><span class="comment">        opsForHyperLogLog</span></span><br><span class="line"><span class="comment">        redisTemplate.opsForHyperLogLog();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      除了以上的基本操作，我们常用的方法都可以通过redisTemplate直接操作、比如事务、基本的crud</span></span><br><span class="line"><span class="comment">        redisTemplate.multi();*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*     获取Redis的连接对象</span></span><br><span class="line"><span class="comment">        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line"><span class="comment">        connection.flushAll();</span></span><br><span class="line"><span class="comment">        connection.flushDb();*/</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;fox&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h4><p><img src="https://i.loli.net/2021/08/08/skLK9pEQCtjqogU.png" alt="image-20210808153523713.png"></p>
<p><img src="https://i.loli.net/2021/08/08/Y1ByTrLKbf7IhOe.png" alt="image-20210808153633948.png"></p>
<h3 id="SpringBoot-Redis-Template"><a href="#SpringBoot-Redis-Template" class="headerlink" title="SpringBoot Redis Template"></a>SpringBoot Redis Template</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">//String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体需要序列化</p>
<h2 id="redis-conf-配置"><a href="#redis-conf-配置" class="headerlink" title="redis.conf  配置"></a>redis.conf  配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line"># 开始启动时必须如下指定配置文件</span><br><span class="line"># ./redis-server /path/to/redis.conf</span><br><span class="line"># </span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line"># </span><br><span class="line"># 存储单位如下所示</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"># 如果需要使用多配置文件配置redis，请用include(包含)</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"></span><br><span class="line">################################## MODULES ##################################### </span><br><span class="line"># modules手动设置加载模块（当服务无法自动加载时设置）</span><br><span class="line">#</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br><span class="line"></span><br><span class="line">################################## NETWORK (网络) #####################################</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1::1</span><br><span class="line"># </span><br><span class="line"># 设置绑定的ip</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 保护模式：不允许外部网络连接redis服务</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 设置端口号</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line"># </span><br><span class="line"># TCP 连接数，此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># Unix socket.</span><br><span class="line"># </span><br><span class="line"># 通信协议设置，本机通信使用此协议不适用tcp协议可大大提升性能</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line"># 定期检测cli连接是否存活</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"># 是否守护进程运行（后台运行）</span><br><span class="line">daemonize yes</span><br><span class="line"># 是否通过upstart和systemd管理Redis守护进程</span><br><span class="line">supervised no</span><br><span class="line"># 以后台进程方式运行redis，则需要指定pid 文件</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"># 日志级别</span><br><span class="line"># 可选项有： # debug（记录大量日志信息，适用于开发、测试阶段）； # verbose（较多日志信息）； # notice（适量日志信息，使用于生产环境）； </span><br><span class="line"># warning（仅有部分重要、关键信息才会被记录）。</span><br><span class="line">loglevel debug</span><br><span class="line"># 日志文件的位置</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"># 数据库的个数</span><br><span class="line">databases 16</span><br><span class="line"># 是否显示logo</span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING(快照) ################################</span><br><span class="line"># Save the DB on disk:</span><br><span class="line"># </span><br><span class="line"># 持久化操作设置 900秒内触发一次请求进行持久化，300秒内触发10次请求进行持久化操作，60s内触发10000次请求进行持久化操作</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 如果 bgsave 存储快照失败，那么 redis 将阻止数据继续写入 (false:不会停止对外服务)</span><br><span class="line">stop-writes-on-bgsave-error false</span><br><span class="line"></span><br><span class="line"># 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># dbfilename的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># dbfilename文件的存放位置</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">################################# REPLICATION(复制) #################################</span><br><span class="line"># replicaof(复制) 即slaveof 设置主结点的ip和端口</span><br><span class="line"># replicaof <span class="tag">&lt;<span class="name">masterip</span>&gt;</span> <span class="tag">&lt;<span class="name">masterport</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 集群节点访问密码</span><br><span class="line"># masterauth(主) <span class="tag">&lt;<span class="name">master-password</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 从结点断开后是否仍然提供数据</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 设置从节点是否只读</span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"># 是或否创建新进程进行磁盘同步设置</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># master节点创建子进程前等待的时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># replicas发送PING到master的间隔，默认值为10秒。</span><br><span class="line"># repl-ping-replica-period 10</span><br><span class="line"># </span><br><span class="line"># repl-timeout 60</span><br><span class="line"># </span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># min-replicas-to-write 3</span><br><span class="line"># min-replicas-max-lag 10</span><br><span class="line">#</span><br><span class="line"># replica-announce-ip 5.5.5.5</span><br><span class="line"># replica-announce-port 1234</span><br><span class="line"></span><br><span class="line">################################## SECURITY(安全) ###################################</span><br><span class="line"># 设置连接时密码</span><br><span class="line"># requirepass 一定要有密码</span><br><span class="line"></span><br><span class="line">################################### CLIENTS(客户端) ####################################</span><br><span class="line"># 最大连接数</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">############################## MEMORY MANAGEMENT(内存管理) ################################</span><br><span class="line"></span><br><span class="line"># redis配置的最大内存容量</span><br><span class="line"># maxmemory <span class="tag">&lt;<span class="name">bytes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 内存达到上限的处理策略</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"># ---------------------------------6种策略---------------------------------------------- </span><br><span class="line">1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line">2、allkeys-lru ： 删除lru算法的key   </span><br><span class="line">3、volatile-random：随机删除即将过期key   </span><br><span class="line">4、allkeys-random：随机删除   </span><br><span class="line">5、volatile-ttl ： 删除即将过期的   </span><br><span class="line">6、noeviction ： 永不过期，返回错误</span><br><span class="line"></span><br><span class="line"># 处理策略设置的采样值 </span><br><span class="line"># 清理时会根据用户配置的maxmemory-policy来做适当的清理（一般是LRU或TTL），这里的LRU或TTL策略并不是针对redis的所有key，而是以配置文件中的maxmemory-samples个key作为样本池进行抽样清理。</span><br><span class="line"># 如果增加，会提高LRU或TTL的精准度，redis作者测试的结果是当这个配置为10时已经非常接近全量LRU的精准度了</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line"># 是否开启 replica 最大内存限制</span><br><span class="line"># replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line">############################# LAZY FREEING ####################################</span><br><span class="line"># 惰性删除或延迟释放</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE(aof) ###############################</span><br><span class="line"># 是否使用AOF持久化方式 默认使用RDB持久化 aof大部分没有rdb效率高</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># appendfilename的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 持久化策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec # 每秒 会丢失当前一秒的数据</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 持久化时（RDB的save | aof重写）是否可以运用Appendfsync，用默认no即可，保证数据安全性</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 设置重写的基准值</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 指定当发生AOF文件末尾截断时，加载文件还是报错退出</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 开启混合持久化，更快的AOF重写和启动时数据恢复</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line"># 是否开启集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群结点信息文件</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 等待节点回复的时限</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 结点重连规则参数</span><br><span class="line"># cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># cluster-replica-no-failover no</span><br></pre></td></tr></table></figure>

<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进入redis </span><br><span class="line">config get requirepass</span><br><span class="line">config <span class="built_in">set</span> requirepass 123456</span><br><span class="line">auth <span class="string">&quot;密码&quot;</span> <span class="comment"># 登录</span></span><br><span class="line">save <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure>

<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="RDB-redis-Datebase"><a href="#RDB-redis-Datebase" class="headerlink" title="RDB (redis Datebase)"></a>RDB (redis Datebase)</h3><p>一般RDB 放在丛机上备份使用一般默认用这个</p>
<ul>
<li>使用dump.rdb 保存</li>
<li>如果rdb文件有问题可以check redis-check-rdb </li>
<li>rdb 就是一个快照的概念</li>
<li>在redis操作过程中 fork出一个子进程去写一个临时的rdb文件 写完后 替换原来的快照文件 子进程结束 流程如图<ol>
<li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB&#x2F;AOF子进程，如果存在bgsave命令直接返回。</li>
<li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。</li>
<li>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</li>
<li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。</li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项。</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/29/KU8sDpf35nEMcld.png" alt="image.png"></p>
<ul>
<li><p>缺点: 当前次写入快照操作时 可能会丢失数据  fork进程会占内存</p>
</li>
<li><p>优点 : 高效 易用</p>
</li>
</ul>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save 规则满足</li>
<li>手动执行 flushall</li>
</ol>
<p><img src="https://s2.loli.net/2022/05/29/jgrwvxO287YcAkU.png" alt="image-20220529172852144"></p>
<h3 id="AOF-append-only-file-追加文件"><a href="#AOF-append-only-file-追加文件" class="headerlink" title="AOF(append only file) 追加文件"></a>AOF(append only file) 追加文件</h3><p>使用日志的方式 去存储 每一次写操作 </p>
<ul>
<li>如果aof文件有问题可以自动修复 redis-check-aof –fix</li>
<li>缺点:相对于数据文件aof大于rdb 读取速度也慢</li>
<li>aof 效率比rdb慢</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/29/CqdpmGh7yEK1HbA.png" alt="image-20220529171829508"></p>
<p><img src="https://s2.loli.net/2022/05/29/cr2nFvxdW5NpJOy.png" alt="image.png"></p>
<p>aof重写:  如果文件太大 会新fork一个进程去重写</p>
<h2 id="redis-发布订阅"><a href="#redis-发布订阅" class="headerlink" title="redis 发布订阅"></a>redis 发布订阅</h2><p>redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发布者发送消息，订阅者接收消息。</p>
<p><img src="https://s2.loli.net/2022/06/13/EWIC7nrpHYJAcVb.png" alt="image.png"></p>
<h2 id="redis-主从复制"><a href="#redis-主从复制" class="headerlink" title="redis 主从复制"></a>redis 主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>主从复制:</strong> 是指将一台redis服务器的数据复制到其他的Redis服务器.前者称为主节点(master&#x2F;leader), 后者称为从节点(slave&#x2F;follower); 数据的复制是单向的, 只能由主节点到从节点.  所以,主节点写为主,从节点读为主</p>
<p>默认情况 , 每台redis 服务器都是主节点;而且一个主节点可以有0或多个从节点.</p>
<p>主从复制的作用:</p>
<ol>
<li>数据冗余: 主节点复制实现了数据的热备份,是持久化之外的数据冗余方式.</li>
<li>故障恢复: 主节点出问题 从节点仍然可以提供服务,实现快速的故障恢复; –服务冗余</li>
<li>负载均衡:从主从复制的基础上 加上读写分离, 由主节点写 从节点提供读的服务; 分担服务器压力,尤其是读多写少的情况</li>
<li>高可用的基础: 除了上述作用,主从复制还是 哨兵和集群都能够实施的基础, 因此说主从复制是redis高可用的基础</li>
</ol>
<blockquote>
<p>主从复制, 读写分离; 架构中很常用 </p>
</blockquote>
<p>一般来说 redis 不会只有一个节点:</p>
<ol>
<li>从结构上,单个redis 易发生故障且不易处理</li>
<li>单个redis服务器内存容量优先, 不可能将一台服务器的全部内存作为reids内存 单台redis内存超过20g就应该考虑主从复制了</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/13/5vXYeKVu3w2gSaF.png" alt="image.png"></p>
<blockquote>
<p>主机写入自动写到从机 从机不能写 会error</p>
<p>从机重连会自动同步主机数据(全量复制)</p>
</blockquote>
<p>Slave 启动连接到master 会发送一个sync同步命令</p>
<p>Master接到命令,启动后台的存盘进程,同时收集所有接收到的用于修改数据集命令,在后台进程执行完毕后,master将传送整个数据文件到slave,完成同步</p>
<p>全量复制: slave在接收到数据后,将其存盘并加载到内存</p>
<p>增量复制: master 将新的所有收集的修改命令依次传给slave,完成同步</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><blockquote>
<p>redis默认自己是主库.所以只配置从库就行  配置了replicaof配置启动就是从机</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; info replication <span class="comment"># 查看信息</span></span><br></pre></td></tr></table></figure>

<h4 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; slaveof [老大的ip] [老大的端口] <span class="comment"># 从机命令配置</span></span><br><span class="line">&gt; slaveod no one <span class="comment"># 自己恢复成主机</span></span><br></pre></td></tr></table></figure>

<h3 id="主从复制的几种模式"><a href="#主从复制的几种模式" class="headerlink" title="主从复制的几种模式"></a>主从复制的几种模式</h3><p>主连从1连从2:  从2也会被同步  </p>
<p><a href="https://blog.csdn.net/wrongyao/article/details/104956111">0060-redis主从复制的几种模型_登峰小蚁的博客-CSDN博客_主从复制模型</a></p>
<p>实际情况的主从安排有很多种 之后遇到在处理 [todo]</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>(自动选举老大(主节点))</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术需要人工干预,费是费力 效率低,更多我们会使用哨兵模式来做. Redis2.8开始正式提供了Sentinel(哨兵)架构解决问题.</p>
<p>检测主机状态,自动选举主机.</p>
<p>哨兵模式是一种特殊的模式, 除了redis提供的哨兵命令 <code>redis-sentinel</code>, 哨兵是一个独立的进程,会独立运行.通过哨兵发送命令.等待redis服务器响应,从而监视多个redis的情况</p>
<p><img src="https://s2.loli.net/2022/06/14/ZeCsEizKdY8p1rL.png" alt="单节点哨兵"></p>
<p>哨兵的作用:</p>
<ol>
<li>通过发送命令,让redis 服务器返回运行状态, 包括主服务器和从服务器.</li>
<li>当哨兵检测到master宕机, 会自动将slave切换为master, 通过<strong>发布订阅</strong>通知其他的从机服务器,修改配置文件, 让他们切换主机.</li>
</ol>
<p>一个人哨兵进程对redis服务器进行监控. 可能会出现问题. 所以 我们可以使用多个哨兵进行监控. 每个哨兵之间还会进行监控,这就是多哨兵模式</p>
<p><img src="https://s2.loli.net/2022/06/14/B7LmcxwS4jo6Phn.png" alt="多哨兵模式"></p>
<p>执行方式:假设主服务器宕机,哨兵1先检测到结果,系统不会立刻进行failover过程,仅仅是哨兵1主管认为主服务器不可用.这个被称为<strong>主观下线</strong>.当后面的哨兵也检测到主服务器不可用时,并且到达一定数量.那么哨兵就会进行一次投票,投出一个哨兵发起failover[故障转移]操作.切换成功后,进行发布订阅模式,让哨兵自己监控的从服务器实现切换主机,这个过程为<strong>客观下线</strong></p>
<p>投票算法(todo)</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁止保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line">sentinel monitor [myMasterName] [ip] [port] 2</span><br><span class="line"><span class="comment"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动哨兵进程</span></span><br><span class="line">./redis-sentinel ../sentinel.conf</span><br></pre></td></tr></table></figure>

<h3 id="哨兵模式的其他配置项"><a href="#哨兵模式的其他配置项" class="headerlink" title="哨兵模式的其他配置项"></a>哨兵模式的其他配置项</h3><table>
<thead>
<tr>
<th>配置项</th>
<th>参数类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>port</td>
<td>整数</td>
<td>启动哨兵进程端口 默认26379</td>
</tr>
<tr>
<td>dir</td>
<td>文件夹目录</td>
<td>哨兵进程服务临时文件夹，默认为&#x2F;tmp，要保证有可写入的权限</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds</td>
<td>[服务名称] [毫秒数（整数）]</td>
<td>指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td>
</tr>
<tr>
<td>sentinel parallel-syncs</td>
<td>[服务名称] [服务器数（整数）]</td>
<td>指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td>
</tr>
<tr>
<td>sentinel failover-timeout</td>
<td>[服务名称] [毫秒数（整数）]</td>
<td>指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td>
</tr>
<tr>
<td>sentinel notification-script</td>
<td>[服务名称] [脚本路径]</td>
<td>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td>
</tr>
<tr>
<td>sentinel monitor</td>
<td>[master-name(字母A-z、数字0-9 “.-_”)]  [ip] [redis-port] [quorum]</td>
<td>哨兵sentinel监控的redis主节点的 ip port<br/>quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</td>
</tr>
<tr>
<td>sentinel auth-pass</td>
<td>[master-name] [password]设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</td>
<td>当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</td>
</tr>
<tr>
<td>sentinel client-reconfig-script</td>
<td>[master-name] [script-path]</td>
<td>客户端重新配置主节点参数脚本<br/>一般都是由运维来配置！</td>
</tr>
</tbody></table>
<p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>
<p>详细解释:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。 </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<ol>
<li>配置麻烦 </li>
<li>redis 扩容会更麻烦</li>
</ol>
<h2 id="redis-缓存穿透和雪崩"><a href="#redis-缓存穿透和雪崩" class="headerlink" title="redis 缓存穿透和雪崩"></a>redis 缓存穿透和雪崩</h2><h3 id="缓存穿透在-96"><a href="#缓存穿透在-96" class="headerlink" title="缓存穿透在&#96;"></a>缓存穿透在&#96;</h3><p>简单说就是用户访问缓存数据(例redis) 但是缓存中不存在 就需要去查询数据库. 流程上正常,如果恶意攻击,或者数据量太大,数据库就会出问题(缓存就没有意义了)</p>
<p> 解决方案</p>
<ol>
<li><p>布隆过滤器 加到缓存层</p>
<p>对控制层数据进行检测 不符合情况直接返回.</p>
</li>
<li><p>缓存空对象 </p>
<p>第一次访问缓存不存在.查询数据库如果不存在会在缓存层添加一个空对象</p>
<p>占用空间</p>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>举例 微博服务器宕机</p>
<blockquote>
<p>和缓存穿透性质差不多, 但是是某一个热点key在扛着大量的访问流量,这个热点key’突然失效了,就会直接打到数据库,大量访问以及数据会写导致宕机.就像在 一个围墙上击穿出现了个洞.比如数据过期</p>
<p>缓存击穿 是热点缓存数据失效. 缓存穿透 是因为空数据 查不到</p>
</blockquote>
<p>解决方案</p>
<ol>
<li><p>热点数据不过期</p>
<p>占空间 redis会清理  </p>
</li>
<li><p>分布式锁</p>
<p>保证对每个key同时只有一个线程去查询后端数据库,其他线程没有获得锁的权限.因此只需要等待.将压力转移到了分布式锁上面.</p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存数据 大批集体失效.过期或者.缓存服务器宕机,直接打到后端数据库 会有问题</p>
<p>双十一: 停掉一些服务保证高可用</p>
<p>解决方案:</p>
<ol>
<li>redis 高可用 多搞几个 (异地多活)</li>
<li>限流降级</li>
<li>预热 先加载数据</li>
</ol>
<h1 id="文章资料"><a href="#文章资料" class="headerlink" title="文章资料"></a>文章资料</h1><p>官网:<a href="https://www.redis.io/">https://www.redis.io/</a></p>
<p>中文官网:<a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>布隆过滤器 <a href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏_李子捌的博客-CSDN博客_布隆过滤器</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>我的hexo博客搭建配置更改</title>
    <url>/2021/07/25/other/%E6%88%91%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%94%B9/</url>
    <content><![CDATA[<h1 id="从0开始搭建hexo博客-win10"><a href="#从0开始搭建hexo博客-win10" class="headerlink" title="从0开始搭建hexo博客(win10)"></a>从0开始搭建hexo博客(win10)</h1><h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><blockquote>
<p>安装node.js <a href="https://nodejs.org/en/">Node.js官网下载地址</a></p>
<p>安装git <a href="https://git-scm.com/downloads">git官方下载地址</a></p>
<p>在git&#x2F;gitee 新建库并且以你的名字命名 git:yourName.github.io gitee:yourName</p>
<p>安装hexo$ npm install -g hexo-cli win会有警告 忽略就好</p>
<p>新建: (<strong>找到你的文件夹</strong>)执行 hexo init $ cd $ npm install</p>
<p>配置:</p>
<blockquote>
<p>可以参考 <a href="https://hexo.io/zh-cn/docs/configuration">这里</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建议配置:</span><br><span class="line">**url**: https://gitee.com/xxx/xxx.git 你的博客访问地址</span><br><span class="line">**per_page**:改为6的倍数 6,12,18</span><br><span class="line"> **# Site** 此处 有更多关于首页配置</span><br><span class="line">**title**: 博客名字</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>hexo的目录配置</p>
<p>markdown</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|-- demo//项目跟目录名</span><br><span class="line">|-- .gitignore//git时忽略的文件或目录</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- package.json//应用程序的信息</span><br><span class="line">|-- <span class="emphasis">_config.yml//网站的配置信息</span></span><br><span class="line"><span class="emphasis">|-- scaffolds//模板文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。</span></span><br><span class="line"><span class="emphasis">| |-- draft.md</span></span><br><span class="line"><span class="emphasis">| |-- page.md</span></span><br><span class="line"><span class="emphasis">| |-- post.md//博文模板</span></span><br><span class="line"><span class="emphasis">|-- source//资源文件夹，存放用户资源</span></span><br><span class="line"><span class="emphasis">| |-- _</span>posts//博文目录</span><br><span class="line">| |-- hello-world.md//博文</span><br><span class="line">|-- themes//主题文件夹，Hexo 会根据主题来生成静态页面</span><br><span class="line">|-- landscape.//默认主题</span><br></pre></td></tr></table></figure>

<h2 id="配置git和gitee库"><a href="#配置git和gitee库" class="headerlink" title="配置git和gitee库"></a>配置git和gitee库</h2><ol>
<li><p>首先你要有这两个仓库</p>
</li>
<li><p>修改[^ _config.yml ] 此文件的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: &#x27;git&#x27;</span><br><span class="line">repo:</span><br><span class="line">   github: https://github.com/xxxx/xxxx.github.io.git</span><br><span class="line">   gitee: https://gitee.com/xxxx/xxxx.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行 hexo d 就能在你的链接访问啦</p>
</li>
<li><p>提示</p>
<p>：gitee要启动一下gitee Pages</p>
<p>自你的库-服务- gitee pages</p>
<p>每次更新后要重新更新一下gitee Pages</p>
<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><ul>
<li>执行 hexo server &#x3D;&#x3D; hexo s 默认为 <a href="http://localhost:4000/">http://localhost:4000/</a></li>
<li><ul>
<li>-p 选项，指定服务器端口，默认为 4000</li>
<li></li>
<li>-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</li>
<li></li>
<li>-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</li>
</ul>
</li>
<li>hexo generate 命令用于生成静态文件，一般可以简写为 hexo g</li>
<li>hexo d 发布到 git&#x2F;gitee库</li>
<li><strong>说明</strong> ：部署前需要修改 _config.yml 配置文件，下面以 git&#x2F;gitee 为例进行</li>
<li>hexo clean 命令用于清理缓存文件，是一个比较常用的命令</li>
<li>根目录命令行输入hexo new &lt;模板&gt; &lt;文章名&gt; 新建博客</li>
<li>末班在scaffold文件夹下</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">功能</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">post</td>
<td align="left">新建文章</td>
<td align="left">&#x2F;source&#x2F;_posts&#x2F;</td>
</tr>
<tr>
<td align="left">draft</td>
<td align="left">新建草稿</td>
<td align="left">&#x2F;source&#x2F;_drafts&#x2F;</td>
</tr>
<tr>
<td align="left">page</td>
<td align="left">新建页面（标签页，分类页等）</td>
<td align="left">&#x2F;source&#x2F;</td>
</tr>
</tbody></table>
<h2 id="主题安装配置"><a href="#主题安装配置" class="headerlink" title="主题安装配置"></a>主题安装配置</h2><p>有很多优秀好看的主题 next等 不想折腾就用next吧 用的多排坑的也多</p>
<p>我的是Matery 我的主页下方有下载地址[^ Theme Matery ] 或者戳<a href="https://github.com/blinkfox/hexo-theme-matery">这里</a></p>
<p>(下载的主题有说明文档)😜</p>
<h2 id="主题更换-Butterfly"><a href="#主题更换-Butterfly" class="headerlink" title="主题更换 Butterfly"></a>主题更换 Butterfly</h2><p><a href="https://butterfly.js.org/">Butterfly地址</a></p>
<h3 id="图片墙"><a href="#图片墙" class="headerlink" title="图片墙"></a>图片墙</h3><div class="gallery-group-main">
<figure class="gallery-group">
  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">
  <figcaption>
  <div class="gallery-group-name">OH MY GIRL</div>
  <p>關於OH MY GIRL的圖片</p>
  <a href='/Gallery/ohmygirl'></a>
  </figcaption>
  </figure>
  
</div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-76.最小覆盖子串</title>
    <url>/2021/07/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="leetcode每日一题-76-最小覆盖子串"><a href="#leetcode每日一题-76-最小覆盖子串" class="headerlink" title="leetcode每日一题:76.最小覆盖子串"></a>leetcode每日一题:76.最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76.最小覆盖子串</a></p>
<p><img src="https://sunxinan12138.github.io/images/76.png" alt="img"></p>
<p><strong>img</strong></p>
<p>代码和注释:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mainTest</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(minWindow(<span class="string">&quot;ADOBECODEBANC&quot;</span>, <span class="string">&quot;ABC&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 滑动窗口</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 左右指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 存储s和t出现次数</span></span><br><span class="line">       <span class="type">int</span>[] snum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">       <span class="type">int</span>[] tnum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">tlen</span> <span class="operator">=</span> t.length();</span><br><span class="line">       <span class="comment">// t串存入</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tlen; i++) &#123;</span><br><span class="line">           tnum[t.charAt(i)]++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">minLenth</span> <span class="operator">=</span> s.length() + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (right &lt; s.length()) &#123;<span class="comment">// 右指针移动</span></span><br><span class="line">           <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">           snum[ch]++;<span class="comment">// 将s出现的次数存入数组</span></span><br><span class="line">           <span class="comment">// 如果满足 当前字符是t字符里的 并且在当前范围只出现一次</span></span><br><span class="line">           <span class="keyword">if</span> (tnum[ch] &gt; <span class="number">0</span> &amp;&amp; tnum[ch] &gt;= snum[ch]) &#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当长度满足t时</span></span><br><span class="line">           <span class="keyword">while</span> (count == tlen) &#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">               <span class="comment">// 从左到右移动left 指针直到count长度不足</span></span><br><span class="line">               <span class="keyword">if</span> (tnum[c] &gt; <span class="number">0</span> &amp;&amp; tnum[c] &gt;= snum[c]) &#123;</span><br><span class="line">                   count--;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 找到最短长度 将初始和结尾储存</span></span><br><span class="line">               <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLenth) &#123;</span><br><span class="line">                   minLenth = right - left + <span class="number">1</span>;</span><br><span class="line">                   min = left;</span><br><span class="line">                   max = right + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               snum[c]--;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(min, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/07/25/JavaBase/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式-大话设计模式"><a href="#代理模式-大话设计模式" class="headerlink" title="代理模式 - 大话设计模式"></a>代理模式 - 大话设计模式</h1><p>*<strong>每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心。*</strong></p>
<p>啊哈<a href="https://sunxinan12138.github.io/2020/05/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/%E6%88%91%E5%8F%AF%E7%9C%9F%E8%83%BD%E6%8B%96">^ &#x3D;.&#x3D; </a>:expressionless:</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p><strong>为其他对象提供一种代理 以控制对这个对象的访问(DP).</strong></p>
<ul>
<li>角色:<ol>
<li>抽象角色: 用接口或者抽象类来实现(真实对象和代理对象的共同方法)</li>
<li>真实角色: 被代理的角色</li>
<li>代理角色: 代理真是角色 当然可以扩展其他业务</li>
<li>客户端: 具体操作 通过代理类访问代理对象</li>
</ol>
</li>
<li>好处<ol>
<li>可以使真实角色的业务更纯粹! 其他的公共业务和扩展业务不用考虑</li>
<li>实现了业务的分工 – 公共业务交给代理类</li>
<li>公共业务发生扩展时, 方便管理 (解耦)</li>
</ol>
</li>
<li><strong>静态代理缺点</strong>显然很明显: 代理只能服务一个类, 要是想代理很多类就要构建多个代理类</li>
</ul>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2020/09/14/RLpAM1TtmGndJFD.png" alt="代理模式实现"></p>
<p><strong>代理模式实现</strong></p>
<p>代码部分</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">/* 公用接口类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>; <span class="comment">// 定义 RealSubject和Proxy的公共方法</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 代理类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 保存一个引用 使得代理可以访问实体 , 继承了同一个接口 所以可以实现真实实体的所有请求</span></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject; <span class="comment">// 组合形式获取</span></span><br><span class="line">    <span class="comment">// 在Spring框架中推荐使用 set方法来获取对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        realSubject.method(); <span class="comment">// 调用真实的方法</span></span><br><span class="line">        <span class="comment">// 当然可以加点东西</span></span><br><span class="line">        log();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩展的业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了日志方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">          <span class="comment">/* 真实实体类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类代理的真实实体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Proxy</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">    p.method(); <span class="comment">// 通过代理访问真实的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<ul>
<li>远程代理<ol>
<li>就是为一个对象在不同的地址空间提供据不同代表. 这样可以隐藏一个对象存在于不同地址空间的事实</li>
</ol>
</li>
<li>虚拟代理<ol>
<li>是根据需要创建开销很大的对象. 通过它存放实例化需要很长时间的对象.</li>
</ol>
</li>
<li>安全代理<ol>
<li>用来控制真实对象访问时的权限.</li>
</ol>
</li>
<li>只能指引<ol>
<li>是指当调用真实对象时, 代理处理另外一些事</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote>
<p>当然以上是静态代理的实现</p>
<p><strong>静态代理缺点</strong>显然很明显: 代理只能服务一个类, 要是想代理很多类就要构建多个代理类</p>
<blockquote>
<ul>
<li>用反射机制构建动态代理</li>
<li>动态代理的代理类是动态生成的</li>
<li>动态代理分为两大类 – 基于接口 – 基于类<ol>
<li>基于接口: JDK动态代理</li>
<li>基于类: cglib</li>
<li>java字节码实现: javasist</li>
</ol>
</li>
<li>需要 Proxy 和InvocationHandler 两个类来创建动态代理类</li>
</ul>
</blockquote>
<blockquote>
<p><strong>JDK动态代理</strong>: 和静态代理共同的是都要有<strong>真实实体类和接口</strong></p>
</blockquote>
<p>实体类和接口:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>; <span class="comment">// 定义 RealSubject和需要被代理的方法方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 真实实体类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="comment">// 代理类代理的真实实体</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;实际的请求&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>动态代理实现:</p>
<blockquote>
<p><strong>InvocationHandler</strong>是个接口: 只有一个invoke方法 此方法在生成了一个 $Proxy.class 文件中被调用– (具体源码)[<a href="https://www.cnblogs.com/liuyun1995/p/8157098.html]">https://www.cnblogs.com/liuyun1995/p/8157098.html]</a></p>
<p><strong>Proxy</strong>提供了创建动态代理类的静态方法</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建动态代理工具 -- 实现接口</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyInvocationHandlerTemplate</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Object target; <span class="comment">// 目标接口 -- 改为可复用的Obj类</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">// 三个参数 1. 类加载器 2. 反射回去接口 3. InvocationHandler(就是本身)</span></span><br><span class="line">         <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">         A();<span class="comment">// 扩展业务</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">         <span class="keyword">return</span> o;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 扩展业务</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        p.method(); // 通过代理访问真实的方法</span></span><br><span class="line">        <span class="comment">// 动态代理</span></span><br><span class="line">        <span class="comment">// 实例动态代理工具</span></span><br><span class="line">        <span class="type">MyProxyInvocationHandlerTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyProxyInvocationHandlerTemplate</span>();</span><br><span class="line">        <span class="comment">// 实例真真实角色</span></span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        template.setTarget(subject);</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">sub</span> <span class="operator">=</span> (Subject) template.getProxy();<span class="comment">//创建代理类</span></span><br><span class="line">        sub.method();<span class="comment">// 执行公共接口的方法</span></span><br><span class="line">        <span class="comment">// 也会有附加业务的调用</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/25/JavaBase/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式-大话设计模式"><a href="#单例模式-大话设计模式" class="headerlink" title="单例模式 - 大话设计模式"></a>单例模式 - 大话设计模式</h1><p>*<strong>每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心。*</strong></p>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h2><blockquote>
<p>保证一个类仅有一个实例, 并提供一个访问的全局访问点[^ DP]</p>
<p>为了不实例化出多个对象,让类自身<strong>负责</strong>保存他的唯一实例. 这个类可以保证没有其他实例可以被创建, 并且他可以提供一个访问该实例的方法</p>
<p><img src="https://i.loli.net/2020/06/02/epTE4LbXZkhvYFW.png" alt="单例模式"></p>
<p><strong>单例模式</strong></p>
<p>单例模式因为Singleton类封装了他唯一的实现类, 可以严格控制客户怎样访问以及何时访问它.—对唯一实例的受控访问</p>
<p>示例代码:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// private的实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you win!!!&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">// 私有的构造方法 让其他类不能访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 如果实例为空则创建</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="多线程单例模式"><a href="#多线程单例模式" class="headerlink" title="多线程单例模式"></a>多线程单例模式</h2><blockquote>
<p>在多个线程中, 单例模式会出现多个线程同时访问Singleton类, 会出现创建了多个实例的情况. 所以我们给他加<strong>锁</strong></p>
</blockquote>
<h2 id="双重锁定"><a href="#双重锁定" class="headerlink" title="双重锁定"></a>双重锁定</h2><blockquote>
<p>当然加锁后每个线程想访问Singleton类都要等待了, 所以我们优化一下 — 双重锁定</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton intance; <span class="comment">// private的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">synchronizedLOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="comment">//只有static的成员才能在没有创建对象时进行初始化。且类的静态成员在类第一次被使用时初始化后就不会再被初始化，保证了单例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you win!!!&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">// 私有的构造方法 让其他类不能访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getIntance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (synchronizedLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    intance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125; <span class="comment">// 如果实例为空则创建</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="饿汉-x2F-懒汉单例类"><a href="#饿汉-x2F-懒汉单例类" class="headerlink" title="饿汉&#x2F;懒汉单例类"></a>饿汉&#x2F;懒汉单例类</h2><blockquote>
<ul>
<li><p>饿汉</p>
<ol>
<li>静态初始化的方式在自己被加载时就将自己实例化</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonHungry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonHungry</span> <span class="variable">intance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonHungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingletonHungry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creat new !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title function_">getIntance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉</p>
<ol>
<li>在第一次被引用时,才会将自己实例化</li>
</ol>
</li>
<li><p>优缺点: 饿汉类一加载就实例出对象, 会提前占用系统资源. 懒汉面临多线程访问的单圈问题,要加双重锁定. 具体用哪个取决于实际需求</p>
</li>
<li><p><strong>具体用哪个取决于实际需求</strong></p>
</li>
</ul>
</blockquote>
<h3 id="懒汉下防止指令重排序"><a href="#懒汉下防止指令重排序" class="headerlink" title="懒汉下防止指令重排序"></a>懒汉下防止指令重排序</h3><p>创建实例的方式intance &#x3D; new Singleton(); 这不是一个原子性的操作</p>
<p>执行实例化时有三步的</p>
<ol>
<li>分配内存空间</li>
<li>执行构造方法,初始化对象</li>
<li>将对象指向分配的空间</li>
</ol>
<blockquote>
<p>如果指令2和3重排 那么创建的就是空对象…</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton intance; <span class="comment">// 加入volatile防止重排</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>防止反射破坏单例模式</p>
</blockquote>
<p>使用 一个加密的 开关参数(可以破译)</p>
<p>使用枚举 反射源码不允许创建枚举的实例 枚举是一个继承了Enum的类</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2021/07/25/JavaBase/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>[toc]</p>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200923231111293.png" alt="image-20200923231111293"></p>
<p><strong>image-20200923231111293</strong></p>
<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h2><blockquote>
<p>λ表达式:</p>
<p>本质上也是函数式编程:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(params) -&gt; expression[表达式]</span><br><span class="line">(params) -&gt; statement[语句]</span><br><span class="line">(params) -&gt; &#123;statements&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用原因<ol>
<li>避免匿名内部类过多</li>
<li>代码看上去简洁</li>
<li>去掉了冗余的代码,留下核心逻辑</li>
</ol>
</li>
<li>使用前提:<ol>
<li>一定是Function Interface(函数式接口) — Function Interface定义: 任何接口如果只包含唯一一个抽象方法, 那么这就是个函数式接口. 例如 Runnable</li>
</ol>
</li>
</ul>
</blockquote>
<p>例子:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个函数式接口</span></span><br><span class="line"><span class="keyword">public</span> Interface TestInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testmethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lamda创建接口对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类实现 ,(我觉得Lamda表达式是匿名内部类的简化)</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TestInterface</span>()&#123;</span><br><span class="line">        <span class="comment">// 重写方法</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testmethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 代码.....    </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;.testmethod();<span class="comment">//当然有参数的就可以添加参数</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------*/</span>  </span><br><span class="line">    <span class="comment">// Lamda表达式</span></span><br><span class="line">   <span class="comment">//Interface test1 = (参数)-&gt;&#123;方法体&#125;;</span></span><br><span class="line">     <span class="type">Interface</span> <span class="variable">test1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">         <span class="comment">// 代码....</span></span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        a.testmethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java四个函数式接口"><a href="#java四个函数式接口" class="headerlink" title="java四个函数式接口"></a>java四个函数式接口</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">函数式接口</th>
<th align="left">参数类型</th>
<th align="left">返回值</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Consumer 消费型接口</td>
<td align="left">T(泛型)</td>
<td align="left">void</td>
<td align="left">对类型为T的对象应用操作</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Supplier 供给型接口</td>
<td align="left">无</td>
<td align="left">T</td>
<td align="left">安徽类型为T的对象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Function&lt;T, K&gt; 函数型</td>
<td align="left">T</td>
<td align="left">R</td>
<td align="left">参数有两个T和R – R.apply(T t)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Prediction 判断断定型接口</td>
<td align="left">T</td>
<td align="left">Boolen</td>
<td align="left">确定类型为T的对象是否满足约束,并且返回Boolean值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">BiFunction&lt;T,U,R&gt; 可以传递两个参数的函数型接口</td>
<td align="left">T,U</td>
<td align="left">R</td>
<td align="left">可以传递两个参数</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">UnaryOperator Function的子接口</td>
<td align="left">T</td>
<td align="left">T</td>
<td align="left">对类型为T的对象进行操作 返回 操作后的T</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">BinaryOperator BiFunction子接口</td>
<td align="left">T, T</td>
<td align="left">T</td>
<td align="left">二元运算</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">BiConsumer&lt;T, U&gt;</td>
<td align="left">T U</td>
<td align="left">void</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">ToIntFunction ToLongFunction ToDoubleFunction</td>
<td align="left">T</td>
<td align="left">int Long double</td>
<td align="left">传参数返回不同类型数值</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">IntFunction LongFunction DoubleFunction</td>
<td align="left">int Long double</td>
<td align="left">R</td>
<td align="left">不同参数类型返回R</td>
</tr>
</tbody></table>
<p>Java巧用lambda，使用函数式接口 和lambda 可以让程序异步执行 (另外写一下) <a href="https://www.jianshu.com/p/8a7aa7f93ddc?utm_campaign=hugo">可以看这里</a></p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><blockquote>
<p>若lambda体中的方法内容被实现了 就可以用<strong>方法引用</strong>的方式实现</p>
</blockquote>
<ul>
<li>对象::实例方法名</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p><strong>使用 方法引用的方法的 &#x3D;&#x3D;方法的参数和返回值&#x3D;&#x3D; 一定要和对应接口中 &#x3D;&#x3D;方法的参数和返回值&#x3D;&#x3D;相等</strong></p>
<p>构造方法: 类A::new 会根据接口的 返回值和参数 自动匹配构造器</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(StreamDemo::_TEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">_TEST</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;操作1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(MyFunction s)</span> &#123;</span><br><span class="line">        System.out.println(s.apply(<span class="keyword">new</span> <span class="title class_">Object</span>()).toString() + <span class="string">&quot;real&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="comment">/*操作1</span></span><br><span class="line"><span class="comment">000real*/</span></span><br></pre></td></tr></table></figure>

<h2 id="stream流计算"><a href="#stream流计算" class="headerlink" title="stream流计算"></a>stream流计算</h2><blockquote>
<p>流式计算</p>
</blockquote>
<p>在项目中数据存储在数据库 集合等地方. 数据的处理就要交给流来计算</p>
<blockquote>
<p>操作步骤</p>
</blockquote>
<ol>
<li>创建Stream流</li>
</ol>
<p>根据数据源 集合 数组中创建</p>
<ol>
<li>根据API操作数据</li>
</ol>
<p>一个操作链进行选择排序,,,</p>
<ol>
<li>结束&#x2F;终止操作</li>
</ol>
<p>执行操作了链条产生结果 可以使用java7的try-with-resources</p>
<p><a href="https://www.runoob.com/java/java8-streams.html">API看这里</a></p>
<p>举个🌰</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id,age,name.major</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">12</span>, <span class="string">&quot;sjs&quot;</span>, <span class="string">&quot;jsj&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">13</span>, <span class="string">&quot;zs&quot;</span>, <span class="string">&quot;dzx&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">14</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;dzx&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">15</span>, <span class="string">&quot;ww&quot;</span>, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="number">16</span>, <span class="string">&quot;lb&quot;</span>, <span class="string">&quot;dzx&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">6</span>, <span class="number">17</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;jsj&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(s1, s2, s3, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 根据集合创建一个流并操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 去重</span></span><br><span class="line"><span class="comment">         * 找到id是偶数的</span></span><br><span class="line"><span class="comment">         * age 大于14的</span></span><br><span class="line"><span class="comment">         * 逆序排列</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Stream&lt;Student&gt; stream = students.stream().</span><br><span class="line">                distinct().</span><br><span class="line">                filter((a) -&gt; a.getId() % <span class="number">2</span> == <span class="number">0</span>).</span><br><span class="line">                filter(a -&gt; a.getAge() &gt; <span class="number">14</span>).</span><br><span class="line">                map(a -&gt; a.setName(a.getName().toUpperCase())).</span><br><span class="line">                sorted((a, b) -&gt; b.getId() - a.getId());</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ol>
<li>时间</li>
</ol>
<p><img src="https://gitee.com/sunxinan/img/raw/master/img/202112301652760.png" alt="image-20211230165223713"></p>
<p><img src="https://gitee.com/sunxinan/img/raw/master/img/202112301652134.png" alt="image-20211230165237091"></p>
<p><img src="https://gitee.com/sunxinan/img/raw/master/img/202112301655373.png" alt="image-20211230165522323"></p>
<p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API： Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间的时区转换。</p>
<p>其他关键API ●Instant 它代表的是时间戳，比如2021-12-04T10:18:12.232Z，这可以从java.time.Clock类中获取，像这样： Instant current &#x3D; Clock.system(ZoneId.of(“Asia&#x2F;Tokyo”)).instant(); ●LocalDate 它表示的是不带时间的日期，比如2021-12-04。它可以用来存储生日，周年纪念日，入职日期等。 ●LocalTime - 它表示的是不带日期的时间，比如12:00:00 ●LocalDateTime - 它包含了时间与日期，不过没有带时区的偏移量 ●ZonedDateTime - 这是一个带时区的完整时间，它根据UTC&#x2F;格林威治时间来进行时区调整</p>
<p>​    Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。对比老的API存在以下优势：</p>
<p>新的时间与日期API中的所有类都是不可变且线程安全的，这与之前的Date与Calendar API中的恰好相反。</p>
<p>Instant 的精确度更高，可以精确到纳秒级。</p>
<p>Duration 可以便捷得到时间段内的天数、小时数等。</p>
<p>LocalDateTime 能够快速地获取年、月、日、下一月等。</p>
<p>TemporalAdjusters 类中包含许多常用的静态方法，避免自己编写工具类</p>
<p>LocalDate</p>
<p>&#x2F;&#x2F; 获取当前年月日 LocalDate localDate &#x3D; LocalDate.now(); &#x2F;&#x2F; 构造指定的年月日 LocalDate localDate1 &#x3D; LocalDate.of(2021, 12, 4);</p>
<p>&#x2F;&#x2F; 获取年、月、日、星期几 int year &#x3D; localDate.getYear(); int year1 &#x3D; localDate.get(ChronoField.YEAR);</p>
<p>Month month &#x3D; localDate.getMonth(); int month1 &#x3D; localDate.get(ChronoField.MONTH_OF_YEAR); int day &#x3D; localDate.getDayOfMonth(); int day1 &#x3D; localDate.get(ChronoField.DAY_OF_MONTH);</p>
<p>DayOfWeek dayOfWeek &#x3D; localDate.getDayOfWeek(); int dayOfWeek1 &#x3D; localDate.get(ChronoField.DAY_OF_WEEK);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算值</span><br><span class="line">localDate.plusDays(1);</span><br><span class="line">localDate.plusMonths(1);</span><br><span class="line">localDate.plusYears(1);</span><br></pre></td></tr></table></figure>

<p>LocalDate localDate &#x3D; LocalDate.of(2021, 12, 4); String s1 &#x3D; localDate.format(DateTimeFormatter.BASIC_ISO_DATE); String s2 &#x3D; localDate.format(DateTimeFormatter.ISO_LOCAL_DATE); System.out.println(“s1：” + s1); System.out.println(“s2：” + s2); LocalDateTime localDateTime &#x3D; LocalDateTime.now(); System.out.println(“获取当前时间：” + localDateTime); DateTimeFormatter formatter &#x3D; DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:MM:SS”); String s &#x3D; localDateTime.format(formatter); System.out.println(“格式化当前时间：” + s); s1：20211204 s2：2021-12-04 获取当前时间：2021-12-04T10:32:36.520 格式化当前时间：2021-12-04 10:32:36</p>
<p>LocalTime</p>
<p>&#x2F;&#x2F; 创建 LocalTime LocalTime localTime &#x3D; LocalTime.of(10, 18, 12); LocalTime localTime1 &#x3D; LocalTime.now();</p>
<p>&#x2F;&#x2F; 获取小时 int hour &#x3D; localTime.getHour(); int hour1 &#x3D; localTime.get(ChronoField.HOUR_OF_DAY);</p>
<p>&#x2F;&#x2F; 获取分 int minute &#x3D; localTime.getMinute(); int minute1 &#x3D; localTime.get(ChronoField.MINUTE_OF_HOUR);</p>
<p>&#x2F;&#x2F; 获取秒 int second &#x3D; localTime.getMinute(); int second1 &#x3D; localTime.get(ChronoField.SECOND_OF_MINUTE);</p>
<p>LocalDateTime</p>
<p>&#x2F;&#x2F; 创建 LocalDateTime LocalDateTime localDateTime &#x3D; LocalDateTime.now(); LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2021, Month.SEPTEMBER, 10, 14, 46, 56); LocalDateTime localDateTime2 &#x3D; LocalDateTime.of(localDate, localTime); LocalDateTime localDateTime3 &#x3D; localDate.atTime(localTime); LocalDateTime localDateTime4 &#x3D; localTime.atDate(localDate); &#x2F;&#x2F; 获取LocalDate LocalDate localDate2 &#x3D; localDateTime.toLocalDate(); &#x2F;&#x2F; 获取LocalTime LocalTime localTime2 &#x3D; localDateTime.toLocalTime();</p>
<p>Instant </p>
<p>&#x2F;&#x2F; 创建Instant对象 Instant instant &#x3D; Instant.now(); &#x2F;&#x2F; 获取秒数 long currentSecond &#x3D; instant.getEpochSecond(); &#x2F;&#x2F; 获取毫秒数 long currentMilli &#x3D; instant.toEpochMilli();</p>
<p>ZonedDateTime</p>
<p>ZonedDateTime类，用于处理带时区的日期和时间。ZoneId表示不同的时区。 Set<String> allZoneIds&#x3D;ZoneId.getAvailableZoneIds();</p>
<p>创建时区： ZoneId zoneId&#x3D;ZoneId.of(“Asia&#x2F;Shanghai”); 把LocalDateTime转换成特定的时区： ZonedDateTime zonedDateTime&#x3D;ZonedDateTime.of(LocalDateTime.now(), zoneId);</p>
<p>获取当前时区： ZoneId z&#x3D;ZoneId.systemDefault(); 获取日期时间： ZonedDateTime dd &#x3D; ZonedDateTime.now(); ZonedDateTime date1 &#x3D; ZonedDateTime.parse(“2021-12-04T10:15:30+05:30[Asia&#x2F;Shanghai]”);</p>
<p>Duration</p>
<p>&#x2F;&#x2F; Duration.between()方法创建 Duration 对象 LocalDateTime from &#x3D; LocalDateTime.of(2021, Month.JANUARY, 1, 00, 0, 0); LocalDateTime to &#x3D; LocalDateTime.of(2021, Month.SEPTEMBER, 12, 14, 28, 0); </p>
<p>Duration duration &#x3D; Duration.between(from, to);     &#x2F;&#x2F; 表示从 from 到 to 这段时间 long days &#x3D; duration.toDays();              &#x2F;&#x2F; 这段时间的总天数 long hours &#x3D; duration.toHours();            &#x2F;&#x2F; 这段时间的小时数 long minutes &#x3D; duration.toMinutes();        &#x2F;&#x2F; 这段时间的分钟数 long seconds &#x3D; duration.getSeconds();       &#x2F;&#x2F; 这段时间的秒数 long milliSeconds &#x3D; duration.toMillis();    &#x2F;&#x2F; 这段时间的毫秒数 long nanoSeconds &#x3D; duration.toNanos();      &#x2F;&#x2F; 这段时间的纳秒数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbstractProcessor（注解处理器）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反射机制</title>
    <url>/2021/07/25/JavaBase/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><h3 id="动静态语言"><a href="#动静态语言" class="headerlink" title="动静态语言"></a>动静态语言</h3><blockquote>
<ul>
<li>动态语言<ol>
<li>运行时可以改变其结构的语言:Object-c, C#, JavaScript, PHP, Python等</li>
</ol>
</li>
<li>静态语言<ol>
<li>运行时结构不可变的语言:Java,C,C++</li>
</ol>
</li>
</ul>
<p>但是! Java虽不是动态语言, 但可以称为<strong>“准动态语言”</strong>. 因为Java有一定的动态性,可以利用Java的<strong>反射机制</strong>获得动态语言的特性. 可以让编程更灵活</p>
</blockquote>
<h3 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h3><blockquote>
<p><strong>Reflection(反射)</strong> 是Java被视为动态语言的关键.反射机制是程序执行期间借助于Reflection API获取到<strong>任何类的内部信息,并能直接操作任意对象的内部属性和方法</strong></p>
<p>加载完类之后, 在堆内存的方法去中就产生了一个Class类型的对象(对于每个类是唯一一个), 这个对象包含了<strong>完整的类的结构信息</strong>. 通过这个对象看到类的结构. 这个对象像个镜子, 透过这个镜子看到了类的结构 ,所以我们叫反射</p>
<p><img src="https://i.loli.net/2020/06/06/1YROeXfwlsizrCS.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</blockquote>
<h3 id="JAVA反射机制的优缺点"><a href="#JAVA反射机制的优缺点" class="headerlink" title="JAVA反射机制的优缺点"></a>JAVA反射机制的优缺点</h3><blockquote>
<ul>
<li>优点: 很明显它实现了动态创建和编译, 大大增加灵活性</li>
<li>缺点: 对性能有影响,. 因为反射是一个解释操作, 告诉JVM,我们需要做什么来完成操作. 肯定慢于直接操作</li>
</ul>
</blockquote>
<h2 id="1-类加载和初始化的"><a href="#1-类加载和初始化的" class="headerlink" title="1. 类加载和初始化的"></a>1. 类加载和初始化的</h2><blockquote>
<p>想要了解反射机制先了解到底类加载是怎么运行的还有初始化时JVM发什么什么</p>
</blockquote>
<h3 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h3><blockquote>
<ul>
<li><p>Jvm中的内存部分:</p>
<ol>
<li><p>堆:</p>
<p>存放new的对象和数组 (垃圾收集器,监控的就是这部分对象)</p>
<ol>
<li>可被所有线程共享, 不会存放别的对象引用</li>
</ol>
</li>
<li><p><strong>栈:</strong> 存放基本变量类型(会包含这个基本类型的具体数值),引用对象的变量(存的是这个引用在堆里的地址)</p>
</li>
<li><p><strong>方法区:</strong> 可悲线程共享&#x2F; 包含所有的calss和static变量</p>
</li>
</ol>
</li>
<li><p>类加载的过程</p>
<p>当程序主动使用某个类, 如果该类还未被夹在到内存中, 则会发生下面的步骤:</p>
<p><img src="https://i.loli.net/2020/06/07/hqkj6iWFR1vc9Ga.png" alt="类加载的过程"></p>
<p><strong>类加载的过程</strong></p>
<ol>
<li><p><strong>加载:</strong> 将class文件字节码加载到内存,将静态数据转换成方法去的运行时数据结构,然后生成一个java.lang.Class对象(堆).</p>
</li>
<li><p>链接:</p>
<p>将二进制(字节码)代码合并到JVM运行状态中</p>
<ol>
<li>&#x3D;&#x3D;验证&#x3D;&#x3D;:确保加载的信息符合JVM规范</li>
<li>&#x3D;&#x3D;准备&#x3D;&#x3D;:正式为类变量(static)分配内存,并设置初值– Java对象变量的默认值</li>
<li>&#x3D;&#x3D;解析&#x3D;&#x3D;:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)</li>
</ol>
</li>
<li><p><strong>初始化:</strong> 执行类构造器的()方法的过程: 下面细说</p>
</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="类的初始化-–-赋初值"><a href="#类的初始化-–-赋初值" class="headerlink" title="类的初始化 – 赋初值"></a>类的初始化 – 赋初值</h3><blockquote>
<ul>
<li><p>初始化: 顺序是: *<strong>先静态对象，后非静态对象，且静态初始化动作只进行一次*</strong></p>
<ol>
<li>类构造器()方法是由编译器自动收集类中<strong>所有</strong>的<strong>类变量</strong>赋值和<strong>静态</strong>代码块的操作(类构造器是构造类的, 不是构造该对象的)</li>
<li>如果初始化时发现父类没有初始化,则初始化父类</li>
<li>虚拟机会保证()方法在多线程中能正确加锁和同步</li>
</ol>
<blockquote>
<p>clinit 只有静态才会生效 而且只有一次 init 在实例化时生效</p>
</blockquote>
<ul>
<li>实例化步骤为：先为属性分配空间，再执行赋默认值，然后按照顺序执行代码块或赋初始值，最后执行构造方法</li>
</ul>
</li>
<li><p>类什么时候初始化:</p>
<ol>
<li>类的主动引用(一定发生初始化)<ol>
<li>一定初始化main方法所在的类</li>
<li>new对象</li>
<li>通过类调用静态成员(除了final)和静态方法</li>
<li>反射调用(forName(“”))</li>
<li>如果初始化时发现父类没有初始化,则初始化父类</li>
</ol>
</li>
<li>类的被动引用(不会发生初始化)<ol>
<li>访问一个静态域时, 如果没有声明这个域的类(比如子类调用父类的静态变量)就不会初始化</li>
<li>通过数组定义引用 – 只会分配空间 (类A[] a &#x3D; new 类A[len])</li>
<li>引用常量不会触发此类的初始化 ( 常量在链接阶段就存入了常量池)</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2020/06/30/pJrK6LaXGIATNFd.png" alt="JVM.png"></p>
<p><strong>JVM.png</strong></p>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote>
<p>如果需要查找一个class对象的时候 先查找内存三种加载器一次查找 如果没有从底层加载器加载 如果都没有抛出ClassNotFoundException 或者调用自己加载器的findClass方法加装</p>
<ol>
<li>好处: 类不重复加载</li>
<li>不会产生核心类被后来的覆盖</li>
</ol>
<p><img src="https://i.loli.net/2020/09/14/FouWQYTv6GM8zdh.png" alt="双亲委派"></p>
<p><strong>双亲委派</strong></p>
</blockquote>
<blockquote>
<p>类加载器就是<strong>将class文件字节码内容加载到内存中</strong>,并将这些静态数据转换成方法去的运行时的数据结构,在堆中生成一个java.lang.class对象,作为访问入口</p>
<p>类缓存: 标准JavaSE类加载器,可以按要求查找类, 一旦某个类被夹在将有一段时间缓存</p>
<ol>
<li><p>引导类加载器: 底层由C++编写, java自带的加载器, <strong>负责java核心库(rt.jar)</strong>, 装在核心类库. 这个无法直接获取</p>
</li>
<li><p>扩展类加载器:负责jre&#x2F;lib&#x2F;ext下的jar包或者java.ext.dirs指定目录的jar加载</p>
<p><strong>sun.misc.Launcher$ExtClassLoader@1d4e2ba</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 系统类的父类  扩展类 </span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> loader.getParent();</span><br><span class="line">System.out.println(parent);</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统类加载器: 最常用的,负责java-classpath或java.class.path所指向的目录下的类与jar包的加载</p>
<p><strong>sun.misc.Launcher$AppClassLoader@dad5dc</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 获取系统类加载器  </span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>   系统类 -&gt; 扩展类 -&gt; 引导类 以及自定义加载器</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看系统内类加载器可以加载的路径</span></span><br><span class="line">  System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/06/07/Dlpi7uRVcFm3MoT.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</blockquote>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><blockquote>
<p>在Object类下有一个getClass()方法,返回值是一个Class类.所有类都默认继承Object类.public final Class getClass()</p>
<p>是Java反射的源头, 所以反射理解为: 可以通过对象反射找到对应的类</p>
<p><img src="https://i.loli.net/2020/06/06/9fyt2kRnvHcCihs.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</blockquote>
<h4 id="获取Class类的方法"><a href="#获取Class类的方法" class="headerlink" title="获取Class类的方法"></a>获取Class类的方法</h4><blockquote>
<ol>
<li><p>已知具体类, 通过class属性来获取, 该方法<strong>最为安全可靠</strong>,程序性能最高</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Cat&gt; c1 = Cat.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知某个类的实例,调用它的getClass方法获取Class对象</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> cat.getClass()</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知一个类的<strong>限定类名</strong>,且在类路径下, 可以通过Class的静态方法forName()获取</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.sjs.Reflect.Cat&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置基本数据类型可以直接调用<strong>类名.Type</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以用ClassLoader</p>
<blockquote>
<p>只要是获取到<strong>同一个类的Class对象都是一个对象</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(c1.hashCode());</span><br><span class="line">System.out.println(c2.hashCode());</span><br><span class="line">System.out.println(c3.hashCode());</span><br></pre></td></tr></table></figure>

<p>我们把上面的对象用hashCode()输出数据相同</p>
</blockquote>
</li>
</ol>
</blockquote>
<h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><blockquote>
<ol>
<li><strong>Class getSuperClass():</strong> 返回当前类的父类</li>
<li><strong>static ClassforName(String name):</strong> 返回指定类名name的Class对象</li>
<li><strong>Object newInstance():</strong> 调用缺省构造函数,返回Class对象的一个实例</li>
<li><strong>getName():</strong> 返回Class对象所表示的实体(类, 接口等)的名称</li>
<li><strong>Class[] getInterfaces():</strong> 返回当前Class对象的接口</li>
<li><strong>ClassLoader getClassLoader():</strong> 返回该类的类加载器</li>
</ol>
</blockquote>
<h2 id="2-获取类的运行时结构"><a href="#2-获取类的运行时结构" class="headerlink" title="2. 获取类的运行时结构"></a>2. 获取类的运行时结构</h2><blockquote>
<p>通过反射可以获取运行时的类的完整结构</p>
<p> 反射创建类的Class对象Class catCl &#x3D; Class.forName(“com.sjs.Reflect.Animal”);</p>
<ol>
<li><p>获取属性</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catCl.getFields(); <span class="comment">// 获取所有public属性</span></span><br><span class="line">catCl.getDeclaredFields();<span class="comment">// 获取所有属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取方法</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catCl.getMethods(); <span class="comment">// 获取包括父类的所有public方法</span></span><br><span class="line">catCl.getDeclaredMethods();<span class="comment">// 获取其他权限的方法</span></span><br><span class="line">   System.out.println(catCl.getDeclaredMethod(<span class="string">&quot;方法名字&quot;</span>, 参数类型.class)); <span class="comment">// 获取指定方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取构造器</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取构造器</span></span><br><span class="line">     catCl.getConstructors();<span class="comment">// 获取 public所有构造器</span></span><br><span class="line">     catCl.getDeclaredConstructors();<span class="comment">// 获取 public所有构造器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等等,,,能获取到类的完整结构(接口,注解, 父类………)</p>
</li>
</ol>
</blockquote>
<h2 id="动态创建对象-调用运行时类中的结构"><a href="#动态创建对象-调用运行时类中的结构" class="headerlink" title="动态创建对象,调用运行时类中的结构"></a>动态创建对象,调用运行时类中的结构</h2><blockquote>
<ul>
<li><p>动态创建:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">aninmalIns</span> <span class="operator">=</span> (Animal) animal.newInstance(); <span class="comment">// 反射获得的类实例创建实例</span></span><br><span class="line"><span class="comment">/*************************************************************************/</span></span><br><span class="line"> <span class="comment">//调用指定构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; constructor = animal.getDeclaredConstructor(String.class);<span class="comment">// 用参数来确定构造方法</span></span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>); <span class="comment">//设置访问权限拦截(true不拦截) 因为这个构造是私有的</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;参数&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用运行时的方法</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> (Animal) animal.newInstance(); <span class="comment">// 创建出声明类实例</span></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="comment">// 创建出Method对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> animal.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);<span class="comment">// 方法参数名字和类型</span></span><br><span class="line">setName.invoke(animal1, <span class="string">&quot;参数&quot;</span>); <span class="comment">// 参数对象是声明类的实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用属性</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 访问和修改属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> animal.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">// 属性名称</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);<span class="comment">// 由于是私有修改拦截方式</span></span><br><span class="line">name.set(animal1, <span class="string">&quot;tuyi&quot;</span>); <span class="comment">// set 将对象和参数传入</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>class对象可以创建类的对象, 可以访问所有权限的方法和属性</li>
<li><strong>invoke(Object obj, Object args[])方法</strong> 用反射创建出Method对象,用此方法调用 ,参数是类的对象和参数</li>
<li>setAccessible(boolen par)<ol>
<li>Method, Field, Constructor对象都有setAccessible()方法</li>
<li>是用来启动或者禁用访问安全检查的开关</li>
<li>true为取消java语言访问检察<ol>
<li><strong>提高反射效率</strong>, 如果必须用反射, 设置为true</li>
<li>可以访问私有结构</li>
</ol>
</li>
<li>false则为反射的对象开启Java语言访问检察</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="练习-通过注解和反射完成简单的类和表结构的映射关系-ORM"><a href="#练习-通过注解和反射完成简单的类和表结构的映射关系-ORM" class="headerlink" title="练习:通过注解和反射完成简单的类和表结构的映射关系(ORM)"></a>练习:通过注解和反射完成简单的类和表结构的映射关系(ORM)</h2><p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解类</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 库名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldsSJS &#123;</span><br><span class="line">    String <span class="title function_">column</span><span class="params">()</span>; <span class="comment">// 列明</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>; <span class="comment">// 数据类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">len</span><span class="params">()</span>; <span class="comment">// 长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pojo类</span></span><br><span class="line"><span class="meta">@DBAnnotation(&quot;student&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@FieldsSJS(column = &quot;id&quot;, type = &quot;int&quot;, len = 2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@FieldsSJS(column = &quot;id&quot;, type = &quot;varChar&quot;, len = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ORMExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentDB</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.sjs.Exercise.Student&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) studentDB.newInstance();</span><br><span class="line">        <span class="type">DBAnnotation</span> <span class="variable">dbAnnotation</span> <span class="operator">=</span> (DBAnnotation) studentDB.getAnnotation(DBAnnotation.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前表是: &quot;</span> + dbAnnotation.value());</span><br><span class="line"></span><br><span class="line">        Field[] fields = studentDB.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="type">FieldsSJS</span> <span class="variable">fieldsjs</span> <span class="operator">=</span> field.getAnnotation(FieldsSJS.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;类中的参数是:&quot;</span> + field.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;列名字:&quot;</span> + fieldsjs.column() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;长度:&quot;</span> + fieldsjs.len() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;类型:&quot;</span> + fieldsjs.type() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/06/08/euOnThtcEdpokG4.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>clinitclinit</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA注解</title>
    <url>/2021/07/25/JavaBase/JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><blockquote>
<ul>
<li>Annotation(注解):<ol>
<li>作用:<ol>
<li>对程序作出解释(和注释(comment)一样)</li>
<li>可以被其他程序读取(编译器等)</li>
</ol>
</li>
<li>格式 – @注释名(参数)</li>
<li>作用于package&#x2F;class&#x2F;method&#x2F;field等上, 给他们添加了额外的辅助信息,可以通过反射机制对这些元数据进行访问</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="部分常见注解"><a href="#部分常见注解" class="headerlink" title="部分常见注解"></a>部分常见注解</h2><blockquote>
<ol>
<li><p><strong>@Override:</strong> 重写超累的方法</p>
</li>
<li><p><strong>@Deprecated:</strong> 定义为废弃的,不推荐使用, 或者有更好的选择</p>
</li>
<li><p>SuppressWarnings:</p>
<p>用来抑制编译时 的警告信息(强迫症福利??) 有参数:</p>
<ol>
<li>(“all”)&#x2F;(“Unchecked”)&#x2F;(value &#x3D; {“unchecked”,”deprecation”})</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote>
<p>元注解(Meta-Annotation) 用来注解其他注解, java提供了四个标准元注解</p>
<ul>
<li><p>这些类型和支持的类在(java.lang.annotation)包中</p>
<ol>
<li><strong>@Target:</strong> 描述作用范围</li>
<li><strong>@Retention:</strong> 表示保存注释的级别, 描述注释的生命周期(SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong>)</li>
<li><strong>@Document:</strong> 说明该注释被包含在javadoc中</li>
<li><strong>@Inherited:</strong> 说明子类可以<strong>继承</strong>父类的注释</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述作用域(ElementTYpe)</span></span><br><span class="line"><span class="comment">//    TYPE, //接口、类、枚举、注解</span></span><br><span class="line"><span class="comment">//    FIELD,//字段、枚举的常量</span></span><br><span class="line"><span class="comment">//    METHOD,  //方法</span></span><br><span class="line"><span class="comment">//    PARAMETER,  //方法参数</span></span><br><span class="line"><span class="comment">//    CONSTRUCTOR,   //构造函数</span></span><br><span class="line"><span class="comment">//    LOCAL_VARIABLE,  //局部变量</span></span><br><span class="line"><span class="comment">//    ANNOTATION_TYPE, //注解</span></span><br><span class="line"><span class="comment">//    PACKAGE   //包</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">// 生命周期(RetentionPolicy)</span></span><br><span class="line"><span class="comment">//    SOURCE, // 源码</span></span><br><span class="line"><span class="comment">//    CLASS,  // 类</span></span><br><span class="line"><span class="comment">//    RUNTIME // 运行时</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// 在javaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 子类可继承</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote>
<p>使用**@interface**来声明自定义注解,public @interface name{内容}</p>
<ul>
<li>自动继承Annotation接口</li>
<li>对于参数<ol>
<li>格式: <strong>类型 名称();</strong></li>
<li>内部每一个方法其实是个参数 返回值类型就是参数类型(只能是基本类)</li>
<li>可以通过default来默认参数</li>
<li>如果只有一个参数成员, 一般命名为Value</li>
<li>注解元素必须要有值,通常使用默认为: 空字符串和0</li>
</ol>
</li>
</ul>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ 定义作用域</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">// 定义生命周期</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Demo1 &#123;</span><br><span class="line">    <span class="comment">// 参数格式: 类型 名字();</span></span><br><span class="line">    <span class="comment">// 如果只有一个参数建议使用value 因为填写参数时可以省略(value = )</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>; <span class="comment">// 设置默认值 如果为-1 则不存在</span></span><br><span class="line"></span><br><span class="line">    String[] tel() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>元注解灵活使用</p>
<p>通过反射来动态获取注解的参数</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> User.calss;</span><br><span class="line">AnnotationName name= userClass.getAnnotation(annotationName.class);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>pe系统盘解锁密码(开启安全引导后密码错误)</title>
    <url>/2021/07/25/other/pe%E7%B3%BB%E7%BB%9F%E7%9B%98%E8%A7%A3%E9%94%81%E5%AF%86%E7%A0%81-%E5%BC%80%E5%90%AF%E5%AE%89%E5%85%A8%E5%BC%95%E5%AF%BC%E5%90%8E%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="pe系统盘解锁密码-开启安全引导后密码错误"><a href="#pe系统盘解锁密码-开启安全引导后密码错误" class="headerlink" title="pe系统盘解锁密码(开启安全引导后密码错误)"></a>pe系统盘解锁密码(开启安全引导后密码错误)</h1><blockquote>
<blockquote>
<p>经历呢就是为了删掉<strong>某垃圾管家</strong>顽固的残留文件, 百度很多都说可以更改安全引导; 然后就登陆不进去了:sob:</p>
</blockquote>
<ul>
<li>登录的用户id变成了我的微软账户名; 输入什么密码都不对(贴吧很多人说是微软密码; 但是无法联网,也没法验证对不对)</li>
</ul>
<blockquote>
<p><strong>于是贴吧里的一个帖子:</strong> 博主名字:<a href="https://tieba.baidu.com/p/6619675494?red_tag=3379245281">山月</a></p>
<p><a href="https://tieba.baidu.com/p/6619675494?red_tag=3379245281"><img src="https://tb1.bdstatic.com/tb/cms/nickemoji/3-34.png" alt="img"><strong>img</strong></a></p>
</blockquote>
<ul>
<li>找出一个U盘，把U盘文件备份</li>
<li>用另一台电脑，插入U盘，下载微pe系统到U盘，具体可见百度经验<a href="https://jingyan.baidu.com/article/6fb756ec44a2cb241858fbfe.html">https://jingyan.baidu.com/article/6fb756ec44a2cb241858fbfe.html</a></li>
<li>你的那台忘记密码的电脑，重启，进入bios菜单，进入满屏幕英文—然后选择USB storage device，回车</li>
<li>进入微pe系统界面，点dism+，，出现什么都点接受，然后进入专家模式，选择<strong>另一个盘</strong>，——恢复功能，引导修复</li>
<li>你会神奇的发现—它能用PIN码进入了</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的JUC</title>
    <url>/2021/07/25/JavaBase/JAVA%E7%9A%84JUC/</url>
    <content><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="JUC是啥-x2F-为什么要用JUC"><a href="#JUC是啥-x2F-为什么要用JUC" class="headerlink" title="JUC是啥 &#x2F; 为什么要用JUC"></a>JUC是啥 &#x2F; 为什么要用JUC</h2><p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200903222641670.png" alt="image-20200903222641670"></p>
<p><strong>image-20200903222641670</strong></p>
<blockquote>
<p>JUC是在线程的基础上 为了高效解决并发问题 并且充分利用cpu</p>
</blockquote>
<p>并发: 多个线程操作一个<strong>共同资源</strong> – cpu, 模拟出来多个线程, 只要切换执行的<strong>快</strong> 那就是牛逼!!!! (本质是交替执行)</p>
<p>并行: 和串行相反 大家并排一起走 – 多核cpu</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java代码看一下自己的 处理器数量</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/08/26/nUcurRmtT4aFlHe.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h2 id="线程的基础"><a href="#线程的基础" class="headerlink" title="线程的基础"></a>线程的基础</h2><p><a href="https://sunxinan12138.github.io/2020/06/05/JAVA%E7%9A%84JUC/#">可以看这里</a></p>
<h2 id="LOCK锁"><a href="#LOCK锁" class="headerlink" title="LOCK锁"></a>LOCK锁</h2><p>例子:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用lock代替synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 关闭锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用过程:</p>
<ol>
<li>创建锁的实例</li>
<li>加锁</li>
<li>finally中释放锁</li>
</ol>
<blockquote>
<p>Synchronized和Lock</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1B7411L7tE?p=6">P6、Synchronized和Lock区别</a></p>
<h2 id="生产者-x2F-消费者"><a href="#生产者-x2F-消费者" class="headerlink" title="生产者 &#x2F; 消费者"></a>生产者 &#x2F; 消费者</h2><p>在java线程中 利用 synchronized&#x2F;wait&#x2F;notify 实现了</p>
<blockquote>
<p>Condition 精准通知和唤醒线程</p>
</blockquote>
<p>Condition: 和obj 的wait notify notifyall 有对应方法</p>
<p>一个Condition 实例本质上绑定到一个锁.</p>
<p>– 利用Condition 实现精准唤醒</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让三个线程一次等待和唤醒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataClass</span> <span class="variable">dataClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataClass</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                dataClass.change1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                dataClass.change2();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                dataClass.change3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 创建监视器1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 创建监视器2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 创建监视器3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 修改数据为1 通知2号监视器</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition1.await();<span class="comment">// 和wait用处相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number + <span class="string">&quot;::&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition2.signal(); <span class="comment">// == notofy</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 关闭锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change2</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">// 修改nummber 为2; 通知3号监视器 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change3</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 修改nummber 为0; 通知1号监视器 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁-锁是啥-锁什么"><a href="#锁-锁是啥-锁什么" class="headerlink" title="锁: 锁是啥, 锁什么"></a>锁: 锁是啥, 锁什么</h2><blockquote>
<p>对象锁:</p>
</blockquote>
<p>就是锁对象: 每个对象一把锁</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">每对A进行一次对象创建 就新获取一把锁 所以 同一个对象的锁会阻塞</span><br><span class="line">-------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类锁</p>
</blockquote>
<p>就是锁对象: 每个对象一把锁</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">不管有多少个对象 只要是使用 <span class="keyword">static</span> <span class="keyword">synchronized</span> 锁 那就是同一把锁 就会阻塞</span><br><span class="line">    <span class="comment">// 测试了一下 synchronized static 和static synchronized 是一样的 </span></span><br><span class="line">-------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类锁和 对象锁没有直接关系 并不是通一把锁</p>
</blockquote>
<p>现在有典型的八锁问题如果理解了就会很简单:</p>
<blockquote>
<p>　 ①两个普通同步方法，两个线程，标准打印， 打印? &#x2F;&#x2F;one</p>
<p>　　②新增 Thread.sleep() 给 one() ,打印?&#x2F;&#x2F;one</p>
<p>　　③新增普通方法 three() , 打印? &#x2F;&#x2F;three one two</p>
<p>　　④两个普通同步方法，两个 Data对象，打印? &#x2F;&#x2F;two one</p>
<p>　　⑤修改 one() 为静态同步方法，打印? &#x2F;&#x2F;two one</p>
<p>　　⑥修改两个方法均为静态同步方法，一个Data对象? &#x2F;&#x2F;one two</p>
<p>　　⑦一个静态同步方法，一个非静态同步方法，两个 Data对象? &#x2F;&#x2F;two one</p>
<p>　　⑧两个静态同步方法，两个 Data对象? &#x2F;&#x2F;one two</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        date1.one();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">// 睡眠一秒</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        date1.two();</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">one</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">two</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">three</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><blockquote>
<p>ReadWriteLock</p>
<p>读时可以多个线程同时读, 写的时候只有一个线程去写</p>
</blockquote>
<p>独占锁: 读锁: 只允许一个线程持有锁</p>
<p>共享锁: 多个线程共享的一个锁</p>
<p>例子:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写一个类似缓存的东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();</span><br><span class="line">        <span class="comment">// 创建20个线程写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i; <span class="comment">// lambda 需要final传递变量</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; cache.write(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建10个线程读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; cache.read(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> HashMap&lt;String, String&gt; cacacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写操作 独占锁 用写锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;==写入&quot;</span> + i);</span><br><span class="line">                cacacheMap.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;==成功&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读操作 共享的所以用读锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">            readWriteLock.readLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;==读&quot;</span> + i);</span><br><span class="line">                cacacheMap.get(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;==成功读&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发下的集合问题"><a href="#并发下的集合问题" class="headerlink" title="并发下的集合问题"></a>并发下的集合问题</h2><h3 id="COW写时拷贝"><a href="#COW写时拷贝" class="headerlink" title="COW写时拷贝"></a>COW写时拷贝</h3><p>要了解一个思想 叫做 COW 即 写时拷贝 (copy - on - write)</p>
<blockquote>
<p>计算机程序设计领域的一种优化策略;</p>
</blockquote>
<p>当然也有 用读写分离的手法解决</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>众所周知, ArrayList是线程不安全的所以如果并发修改或者添加 就会产生<strong>并发修改异常</strong>(ConcurrentModifyException) <code>java.util.ConcurrentModificationException</code></li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试异常的代码</span></span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123; <span class="comment">// 50个线程写入</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">3</span>));<span class="comment">// 随机一个3位的id</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;, i.toString()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法:</p>
<ul>
<li>使用线程安全的集合 vector:</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector 加了synchronized 锁</span></span><br><span class="line">源码:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用一个集合工具类实现安全线程Collections.synchronizedXXX</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br></pre></td></tr></table></figure>

<ul>
<li>使用JUC的安全集合 CopyOnWriteAArrayLis();</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了COW</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol>
<li>collections的线程安全方法</li>
<li>cowSet</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>set底层实现是根据Hashmap实现的 (key唯一, value 是一个固定的对象) map具体的实现方式</p>
<p><a href="https://sunxinan12138.github.io/2020/06/05/JAVA%E7%9A%84JUC/#">关于Hashmap</a></p>
<h2 id="并发使用-ConcurrentHashMap"><a href="#并发使用-ConcurrentHashMap" class="headerlink" title="并发使用 ConcurrentHashMap"></a>并发使用 ConcurrentHashMap</h2><blockquote>
<p>挖坑 为什么好用 实现方式 并发安全方式</p>
</blockquote>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">  V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于Runnable 其实例都是可能由另一个线程执行设计的.但是Callable 有返回结果&lt;这个Type就是返回类型&gt; 有一个异常</p>
<ul>
<li>Thread没有Callable接口的直接实现 要通过Runnable 的FutureTask 实现</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDEmo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MYhread</span> <span class="variable">mYhread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MYhread</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mYhread);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;222&quot;</span>).start();</span><br><span class="line">        System.out.println(futureTask.get()); <span class="comment">// get 方法可能阻塞</span></span><br><span class="line">        <span class="comment">//     会有缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYhread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;====Back&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;back&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个辅助类"><a href="#三个辅助类" class="headerlink" title="三个辅助类"></a>三个辅助类</h3><blockquote>
<p>CountDownLatch</p>
</blockquote>
<p>一个倒计数工具</p>
<p><code>构造方法</code>有一个int 数据</p>
<ul>
<li>countDown() 计数减一</li>
<li>await() 调用此方法会让该当前线程等待 计数器直到计数器归零</li>
</ul>
<blockquote>
<p>CyclicBarrier</p>
</blockquote>
<p>和上面的相反 是正向计数</p>
<p><code>构造方法</code> 1. int a 2, int a, Runnable 线程</p>
<p>也有await方法 ： 同一个线程内的方法</p>
<blockquote>
<p>Semaphore 信号量</p>
</blockquote>
<p>可以理解为限流 构造方法 有线程数</p>
<p>如果位置数量为3 线程数为6就需要排队</p>
<p>acquire() 获取&#x2F;release() 释放</p>
<p>在 semaphore.acquire() 和 semaphore.release()之间的代码，同一时刻只允许指定个数的线程进入，其他线程等待</p>
<hr>
<ul>
<li>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</li>
<li>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的</li>
</ul>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BlockingQueue</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/27/3cyaRXPigpKCjA6.png" alt="阻塞队列"></p>
<p><strong>阻塞队列</strong></p>
<p>四种不同应用场合的API</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">抛出异常</th>
<th align="left">有返回值</th>
<th align="left">阻塞</th>
<th align="left">等待阻塞()</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加</td>
<td align="left">add</td>
<td align="left">offer</td>
<td align="left">put</td>
<td align="left">offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="left">remove</td>
<td align="left">poll</td>
<td align="left">take</td>
<td align="left">poll(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="left">检测队首元素</td>
<td align="left">element</td>
<td align="left">peek</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<blockquote>
<p>原理(待完成)</p>
</blockquote>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SynchronousQueue</span><br></pre></td></tr></table></figure>

<ul>
<li>不存储数据</li>
<li>添加一个等待取出一个</li>
</ul>
<h2 id="线程池-重要"><a href="#线程池-重要" class="headerlink" title="线程池(重要)"></a>线程池(重要)</h2><blockquote>
<p>池化技术(一种思想)</p>
</blockquote>
<p>程序运行使用系统的资源. 对其优化 就使用<strong>池化技术</strong></p>
<p>将资源创建好 需要的化就来取. 用完也不销毁 而是放回池子中</p>
<p>线程池, 连接池, 内存池, 对象池….</p>
<ul>
<li>优点和好处</li>
</ul>
<ol>
<li>降低资源的消耗</li>
<li>提高响应的速度</li>
<li>方便统一管理 ……</li>
</ol>
<p>&#x3D;&#x3D;线程复用 , 可以控制更大的并发量 ,&#x3D;&#x3D;</p>
<blockquote>
<p>线程池的 <code>四(五)个创建方法</code>, <code>七大参数</code>,<code>四种策略</code></p>
</blockquote>
<h3 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h3><p>线程池工具类: Exectors</p>
<ul>
<li><code>newCachedThreadPool</code> <strong>灵活的</strong>创建一个可缓存的线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li><code>newFixedThreadPool(int nThreads)</code> 创建一个定长线程池，可控制线程最大并发数，**<em>*<em>超出的线程会在队列中等待</em></em></li>
<li><code>newScheduledThreadPool</code> 创建一个定长线程池，<strong>支持定时及周期性任务执行</strong></li>
<li><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池</li>
</ul>
<p>在阿里的开发者手册中提到线程池的创建建议</p>
<p><img src="https://i.loli.net/2020/09/28/8XBYQKzxUTm5fsq.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h3 id="七个参数"><a href="#七个参数" class="headerlink" title="七个参数"></a>七个参数</h3><p>上面四种创建方法都是用ThreadPoolExecutor创建的 所以可以直接用ThreadPoolExecutor来创建</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,     // 核心线程大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,    // 最大核心线程数  </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,    // 超时时间设置</span></span><br><span class="line"><span class="params">                          TimeUnit unit,        // 单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,  // 阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,          // 线程工厂    </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>   <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure>

<ul>
<li>图解一下这七个参数</li>
</ul>
<p>蓝色正常不会打开 而需要时才会开启</p>
<p><img src="https://i.loli.net/2020/09/29/8swyPAmX467x9Lg.png" alt="正常状态"></p>
<p><strong>正常状态</strong></p>
<p><img src="https://i.loli.net/2020/09/29/lFGKJ1zEs6Nf2OR.png" alt="拒绝策略"></p>
<p><strong>拒绝策略</strong></p>
<p>如果线程池和队列满了就会执行拒绝策略</p>
<h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><p>RejectedExecutionHandler 拒绝策略接口</p>
<ul>
<li>DiscardPolicy 默认的拒绝策略。直接抛出 java.util.concurrent.RejectedExecutionException异常</li>
<li>CallerRunsPolicy 将任务返还给调用者线程执行</li>
<li>DiscardPolicy 直接抛弃无法处理的任务，不予处理不抛异常。如果业务汇总<strong>允许任务丢失</strong>，这是最好的策略</li>
<li>DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<blockquote>
<p>线程池代码</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POLL_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM_POLL_SIZE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVWTIME</span> <span class="operator">=</span> <span class="number">20L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BlockingQueue</span> <span class="variable">workQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">getThreadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POLL_SIZE,</span><br><span class="line">                MAX_NUM_POLL_SIZE,</span><br><span class="line">                KEEP_ALIVWTIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                workQueue,</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        threadPoolExecutor = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTest</span> <span class="variable">threadPoolTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTest</span>();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> threadPoolTest.getThreadPoolExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;===&quot;</span> + finalI);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调优部分"><a href="#调优部分" class="headerlink" title="调优部分"></a>调优部分</h4><blockquote>
<p>如何定义这个最大的的线程数呢</p>
</blockquote>
<ol>
<li>cpu密集型 : 几核就用几个最大线程数 cpu利用率最大</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取机器核数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">processors</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<ol>
<li>IO密集型: 大于 number(程序中十分消耗IO的线程数)的数量 (可以是number的两倍);</li>
</ol>
<h2 id="ForkJoin-大数据量"><a href="#ForkJoin-大数据量" class="headerlink" title="ForkJoin(大数据量)"></a>ForkJoin(大数据量)</h2><p>将 大任务分解为多个小任务 然后进行处理 – 递归</p>
<blockquote>
<p>工作窃取 利用(双端队列)</p>
<p>A, B 两个线程 A线程执行结束</p>
<p>B线程还有任务 A就窃取B的任务去处理</p>
</blockquote>
<p>例子</p>
<ol>
<li>通过forkjoinpool来执行</li>
<li>将任务 forkjoinpool.execute&#x2F;forkjoinpool.submit(ForkJoinTask task(任务))</li>
<li>任务类 要继承 ForkJoinTask(RecursiveTask是其中一个子类)</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;   </span><br><span class="line">    <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000L</span>;<span class="comment">//临界值</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - st) &lt; temp) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> st; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> st + (end - st) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(st, l);</span><br><span class="line">            d1.fork();</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(l + <span class="number">1</span>, end);</span><br><span class="line">            d2.fork();</span><br><span class="line">            <span class="keyword">return</span> d1.join() + d2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种方法实现 1 - 40亿的相加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> test2();</span><br><span class="line">        <span class="type">long</span> <span class="variable">x1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum&quot;</span> + sum + <span class="string">&quot;time:&quot;</span> + (x1 - x));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">40_0000_0000L</span>; i++) sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="number">0L</span>, <span class="number">40_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = pool.submit(demo);</span><br><span class="line">        <span class="keyword">return</span> submit.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream 并行流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">40_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<blockquote>
<p>数据量越大越能体现出区别</p>
<ol>
<li><strong>for循环相加:</strong> time:3427</li>
<li><strong>ForkJoin:</strong> time:13310 &#x2F;time:10786(更改了临界值) 和这个也有关系</li>
<li>stream并行流计算(内部实现的是ForkJoin)time:7933</li>
</ol>
</blockquote>
<p>这里发现 for循环 要比其他的快 : 其实ForkJoin 和并行流都是并发的操作 根据CPU的性能决定的 但是就算你的任务拆分了 系统性能不支持 并行操作 &#x2F; 或者说没有那么多资源满足你的操作 那么速度当然会比单线程的慢</p>
<p>并不是所有操作中并发操作一定效率高</p>
<h2 id="JAVA异步通信"><a href="#JAVA异步通信" class="headerlink" title="JAVA异步通信"></a>JAVA异步通信</h2><p>在多线程中 获取现成的返回值 或者返回状态(成功 失败 异常…) (AJAX的方式很像)</p>
<ul>
<li>为了实现 回调 &#x2F; 异步编程</li>
</ul>
<p><a href="https://www.jianshu.com/p/6f3ee90ab7d3/">CompletableFuture几个方法</a></p>
<p>Future(父) new CompletableFuture()(子类);</p>
<p>runAsync(Runnable) 无返回值的异步调用</p>
<p>supplyAsync(Runnable) 有返回值</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><ul>
<li>什么是JMM(java memory model)</li>
</ul>
<p>JMM: java内存模型, 一种规则, 概念, 约定. 主要规定了线程和内存之间的一些关系 为了解决多线程和共享内存进行通信是的问题.</p>
<p><strong>约定:</strong></p>
<ol>
<li>线程解锁前, 必须把共享变量&#x3D;&#x3D;立即&#x3D;&#x3D;刷新回主存</li>
<li>线程加锁前, 必须读取主存中的最新值到工作内存</li>
<li>线程 有工作内存, 主内存</li>
</ol>
<p>JMM和JVM没有什么关系 但都提供了系统的可移植性</p>
<ul>
<li>JMM的实现:</li>
</ul>
<p><img src="https://i.loli.net/2020/10/03/312ni4afCugcPwT.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ul>
<li>问题的出现</li>
</ul>
<p><img src="https://i.loli.net/2020/10/03/rN9vclqCeQuGZxW.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">// 线程一</span></span><br><span class="line">            <span class="comment">// 如果不作处理</span></span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">// 确保上面的线程可以先执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">// 线程二</span></span><br><span class="line">            num = <span class="number">0</span>; <span class="comment">// 线程一不知道被修改了</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注: 并不是所有条件下都会出现问题 和系统环境有关系 但是加上volatile一定不会出现问题</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Volatile是java虚拟机提供的<strong>轻量级的同步机制</strong></p>
<ol>
<li>保证了内存可见性</li>
</ol>
<p>上面的多线程问题只要加上volatile关键字修饰变量就可以解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private volatile static int num = 1;</span><br></pre></td></tr></table></figure>

<ol>
<li>但是不保证原子性</li>
</ol>
<p>使用JUC自带的原子类和操作 就可以保证原子性</p>
<h3 id="3-禁止了指令重排序"><a href="#3-禁止了指令重排序" class="headerlink" title="3. 禁止了指令重排序"></a>3. 禁止了指令重排序</h3><blockquote>
<p>什么是指令重排</p>
</blockquote>
<ul>
<li>说白了就是 某些情况 计算机的CPU并不会哪找你写的程序的顺序去执行 他会自己重新优化排序</li>
<li>编译器 – 并行指令 – 内存系统 这些地方都会有重排的可能发生</li>
</ul>
<blockquote>
<p>volatile 避免指令重排</p>
</blockquote>
<ul>
<li>当有用Volatile关键字时 在执行时会加上内存屏障 防止指令的重排序</li>
<li>也保证了内存的可见性</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><blockquote>
<p>什么是CAS(CompareAndSet): 比较并交换</p>
</blockquote>
<p>举个例子 原子整形中 compareAndSet操作</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是期望值 那么久更新 否则就不更新 CAS是CPU执行并发的一种方式</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">20</span>);</span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">20</span>, <span class="number">21</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSet源码就会有unsafe类 这些原子操作都会用到这个类里面很多native的方法</p>
<p><img src="https://i.loli.net/2020/10/03/wqRsgcjhiNWrHO5.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ul>
<li><p>因为java无法操作内存 但是可以调用C++来操作内存 (本地的native方法)</p>
</li>
<li><p>用自旋锁循环判定是否满足条件</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">   <span class="type">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自旋锁产生的ABA问题"><a href="#自旋锁产生的ABA问题" class="headerlink" title="自旋锁产生的ABA问题"></a>自旋锁产生的ABA问题</h3><p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201003195829532.png" alt="image-20201003195829532"></p>
<p><strong>image-20201003195829532</strong></p>
<p>这就是ABA问题</p>
<ul>
<li>循环时间太长开销也会变得很大: 加入pause 指令<ol>
<li>延迟流水线执行指令(de-pipeline), 使cpu不会消耗过多的资源</li>
<li>可以避免退出循环的时候 因内存顺序冲突(Memory Order Violation) 引起的CPU流水线被清空</li>
</ol>
</li>
</ul>
<h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>乐观锁的思想</p>
<p>使用原子引用来解决这个问题</p>
<p>引入一个版本号的思想:</p>
<p><img src="https://i.loli.net/2020/10/03/vguV8iRorBGez6P.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>截取一部分</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;String&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;2222&quot;</span>, <span class="number">1</span>);<span class="comment">// 初始值和版本戳</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">        System.out.println(<span class="string">&quot;A-stamp: &quot;</span> + stamp);</span><br><span class="line">        atomicReference.compareAndSet(<span class="string">&quot;2222&quot;</span>, <span class="string">&quot;21&quot;</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        System.out.println(atomicReference.getReference()); <span class="comment">// 修改成功 就是21</span></span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;注意:&#x3D;&#x3D; 在Java的CAS底层实现中 比较两个值是否相等时用的是**&#x3D;&#x3D;** 对于自动装箱的包装类(Integer等) 会出现不相等的问题 (自动装箱的缓存问题, 我就不细说了)</p>
</blockquote>
<h2 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h2><p><strong>锁的类型:</strong></p>
<ul>
<li><p>可重入锁(递归所)（synchronized和ReentrantLock）：在<strong>执行对象中</strong>通用一把锁的方法<strong>不用再次获得锁</strong>(synchronized 和 Lock 都是可重入锁)</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 和 Lock区别</span><br><span class="line">Lock锁 加锁解锁是成对的 获取道A的锁时 默认也获取到了B的锁</span><br><span class="line"><span class="comment">// -------------------</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="title function_">A</span><span class="params">()</span>&#123;B();&#125;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="title function_">B</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// 如果有线程获取到A方法的锁就默认也获取了B方法的锁 所以 A没有执行结束 B方法是被锁住的状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可中断锁（synchronized就不是可中断锁，而Lock是可中断锁）：在等待获取锁过程中可中断</p>
</li>
<li><p>公平锁&#x2F;<strong>非公平锁</strong>（ReentrantLock和ReentrantReadWriteLock）： 按照先来后到排队 &#x2F; <strong>按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利</strong>(默认都是非公平锁)</p>
</li>
<li><p>读写锁（ReadWriteLock和ReentrantReadWriteLock）：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写</p>
</li>
<li><p>自旋锁 循环判断锁的状态</p>
</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SjsLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 大概写一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;==get LOCK ing...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;锁被拿走了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;==GET success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        threadAtomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁的排查"><a href="#死锁的排查" class="headerlink" title="死锁的排查"></a>死锁的排查</h3><p>死锁四要素 <a href="https://www.cnblogs.com/bopo/p/9228834.html">https://www.cnblogs.com/bopo/p/9228834.html</a></p>
<p><code>JPS - l</code>(查看进程) : <a href="https://blog.csdn.net/u013250071/article/details/80496623">https://blog.csdn.net/u013250071/article/details/80496623</a></p>
<p><code>jstack - 进程号</code>(查看堆栈信息) 来排查:</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2021/07/25/JavaBase/Spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务说明"><a href="#事务说明" class="headerlink" title="事务说明"></a>事务说明</h2><blockquote>
<p>什么是事务</p>
</blockquote>
<p>事务式代表单个工作单元的一组SQL语句.</p>
<p>所有这些语句都应该成功完成, 否则事务会运行失败.</p>
<p>我们在需要对数据库进行多次更改的情况下使用事务</p>
<blockquote>
<p>四大特性(ACID)</p>
</blockquote>
<ol>
<li><p>Atomicity: 原子性 每个事物不可分割</p>
</li>
<li><p><strong>Consistency: 一致性 :</strong> 使用事务 数据库始终保持一致的状态</p>
<ul>
<li>完整约束</li>
</ul>
</li>
<li><p>Isolation: 隔离性 事物之间不可干扰</p>
<ul>
<li><p>锁行</p>
<p>如果多个事务想要更新相同的数据</p>
<p>受影响的行会被锁定</p>
<p>因此只有一个事务可以更新行</p>
</li>
</ul>
</li>
<li><p>Durability: 持续性 一旦提交 事务的更改是永久的</p>
</li>
</ol>
<blockquote>
<p>Mysql对事务处理</p>
</blockquote>
<p>mysql会封装我们写的sql 如果检查无误自动提交</p>
<p><img src="https://i.loli.net/2020/08/23/LaimKnoYh1dc2P5.png" alt="mysql自动提交属性"></p>
<p><strong>mysql自动提交属性</strong></p>
<p>mysql innodb引擎已经通过MVCC、间隙锁&amp;临键锁解决了可重复读隔离级别下的幻读问题</p>
<h2 id="事务实现技术-x2F-原理"><a href="#事务实现技术-x2F-原理" class="headerlink" title="事务实现技术&#x2F;原理"></a>事务实现技术&#x2F;原理</h2><p><img src="https://i.loli.net/2020/08/23/O1uMT6z3eIAVWS7.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h3 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h3><ol>
<li><p>事务的</p>
<p>原子性 通过undo log</p>
<p>实现</p>
<ul>
<li><del>undo log : 操作任何数据之前,将数据备份到一个地方 (Undo log). 然后进行数据修改. 如果出现错误或者执行RollBack语句. 系统用备份在undo log 下的数据进行回滚(sql执行相反操作delect – insetr update – 相反的update)</del></li>
</ul>
</li>
<li><p>事务的</p>
<p>持久性 通过redo log</p>
<p>实现</p>
<ul>
<li>和undo log 相反, redo 是记录是新数据的备份 系统崩溃时 可以根据redo 恢复?</li>
</ul>
</li>
<li><p>事务的隔离性 通过(<strong>读写锁+MVCC</strong>[多版本并发控制])来实现</p>
</li>
<li><p>&#x3D;&#x3D;事务一致性通过 原子性, 持久性, 隔离性实现!!!!!&#x3D;&#x3D;</p>
</li>
</ol>
<ul>
<li>bin log (binary log)</li>
</ul>
<h3 id="隔离性实现原理-锁"><a href="#隔离性实现原理-锁" class="headerlink" title="隔离性实现原理 : 锁"></a>隔离性实现原理 : <strong>锁</strong></h3><ol>
<li>Mysql 分为:<ul>
<li>共享锁(Shared): &#x3D;&#x3D;锁行&#x3D;&#x3D; 将数据对象变为<strong>只读</strong>形式, 不能进行更新 也是<strong>读写</strong>锁定. 多个事务共享但是 不能修改</li>
<li>排它锁(Exclusive): &#x3D;&#x3D;锁行&#x3D;&#x3D; <strong>不与其他锁共存</strong> 如果一个事务获取了排它锁. 其他事务就不能在获取锁了, 只有获取锁的事务对数据进行修改</li>
<li>还有个自增锁(对于自增列自增长的一个特殊的表级锁)</li>
</ul>
</li>
<li>锁得粒度(粒度越高效率低但是安全)<ul>
<li>记录</li>
<li>表</li>
<li>数据库</li>
</ul>
</li>
<li>锁的并发流程<ul>
<li>事务根据自己的草最获取对应的锁</li>
<li>申请的请求被发给 锁管理器 (是否冲突 是否可以获得)</li>
<li>若被授予锁 则继续 否则等待 直到其他的事务释放</li>
</ul>
</li>
</ol>
<h2 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h2><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION ;</span><br><span class="line"> <span class="operator">/</span><span class="operator">/</span> <span class="keyword">sql</span>语句...</span><br><span class="line"><span class="keyword">Commit</span>; <span class="comment">-- 提交</span></span><br><span class="line"><span class="keyword">RollBack</span> <span class="comment">-- 回滚</span></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> point_name</span><br><span class="line"><span class="keyword">RollBack</span>  <span class="keyword">to</span> point_name 回滚到保存点</span><br></pre></td></tr></table></figure>

<h2 id="并发和锁定"><a href="#并发和锁定" class="headerlink" title="并发和锁定"></a>并发和锁定</h2><blockquote>
<p>在真实场景中肯定会有多个用户去访问相同的数据 这就是 并发 如果正在访问被修改的数据 那就回出现问题</p>
</blockquote>
<ul>
<li>mysql 默认并发处理 – 锁行</li>
</ul>
<p>当一个事务修改行没有结束时 另一个事务再次对其修改会被锁住发生超时</p>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="number">1205</span> <span class="operator">-</span> Lock wait timeout exceeded; try restarting transaction</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 超过了锁定等待超时；尝试重新启动事务  <span class="comment">-- 事务会失效</span></span><br></pre></td></tr></table></figure>

<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation; 查看事务隔离级别</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>默认</p>
</li>
<li><p>Read UNCOMMITTED（未提交内容读）</p>
</li>
<li><p>Read Committed（提交内容读）</p>
</li>
<li><p>Repeatable Read（可重读）</p>
</li>
<li><p>Serializable（可串行化(可序列化)）</p>
<p><img src="https://i.loli.net/2020/08/23/42nrMJzVkWZ7Fp6.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>脏度:读取到了<strong>另一个事务未结束</strong>的数据(回滚前 或者更新前)</p>
<p>不可重复读: 再<strong>一次事务</strong>中, 两次查询不一致,可能在两次查询中更改了数据</p>
<p>幻读: 两次查询,第二次查到了新的行(多了一行)</p>
</li>
</ol>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session <span class="operator">/</span> globel transaction isolation level 级别 <span class="operator">/</span><span class="operator">/</span> 设置级别 </span><br><span class="line">session(当前会话) <span class="operator">/</span> globel (全局)</span><br></pre></td></tr></table></figure>

<h3 id="Read-UNCOMMITTED（未提交内容读）"><a href="#Read-UNCOMMITTED（未提交内容读）" class="headerlink" title="Read UNCOMMITTED（未提交内容读）"></a><del>Read UNCOMMITTED（未提交内容读）</del></h3><h3 id="Read-Committed（提交内容读）"><a href="#Read-Committed（提交内容读）" class="headerlink" title="Read Committed（提交内容读）"></a><del>Read Committed（提交内容读）</del></h3><h3 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a><del>Repeatable Read（可重读）</del></h3><h3 id="Serializable（可串行化-可序列化-）"><a href="#Serializable（可串行化-可序列化-）" class="headerlink" title="Serializable（可串行化(可序列化)）"></a><del>Serializable（可串行化(可序列化)）</del></h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>某两个或以上的事务 获取了其他事务执行时必要的锁 且不能释放 那么就会发生死锁</li>
</ul>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>传播特性</p>
<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/index-condition-pushdown.html">http://blog.codinglabs.org/articles/index-condition-pushdown.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>xx-net 访问Google</title>
    <url>/2021/07/25/other/xx-net-%E8%AE%BF%E9%97%AEGoogle/</url>
    <content><![CDATA[<h1 id="xx-net-访问Google"><a href="#xx-net-访问Google" class="headerlink" title="xx-net 访问Google"></a>xx-net 访问Google</h1><p>访问google</p>
<p>下载XX-net: <a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md">github地址</a></p>
<p>下载稳定版解压(尽量不要有中文)运行 Star.bat&#x2F;star.vbs</p>
<p>然后 提示安装证书 – 就入了浏览器 – 点击状态 – 如果未连接:</p>
<ul>
<li><p>设置ipv6(</p>
<p>也可以先造作这步骤</p>
<p>)</p>
<ol>
<li>打开 xx-Net&#x2F;code&#x2F;default&#x2F;gae_proxy&#x2F;local&#x2F;ipv6_tunnel 下的enable_ipv6 打开自动设置</li>
</ol>
</li>
</ul>
<p>如果状态时链接那么就可以使用了</p>
<hr>
<p>当然用的是共有的appid 会有限制 可以自己配置Google appid: <a href="https://github.com/XX-net/XX-Net/wiki/how-to-create-my-appids">点击这里是官方教程</a> 我没有信用卡就先将就了:sob:</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2021/07/25/JavaBase/%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="1-Maven是啥"><a href="#1-Maven是啥" class="headerlink" title="1.Maven是啥"></a>1.Maven是啥</h3><ul>
<li><p>Maven还是很强大的:</p>
<ul>
<li>项目继承(在多个模块的项目中很好用的)</li>
<li>解决jar冲突</li>
<li>自动导入jar(从本地库寻找如果没有–会自动去中央仓库下载)<ul>
<li><a href="https://mvnrepository.com/">依赖配置地址</a></li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/7642256-c967b2c1faeba9ce.png" alt="Maven生命周期"></p>
<p><strong>Maven生命周期</strong></p>
</li>
</ul>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p><a href="https://blog.csdn.net/daffordil/article/details/89419252">安装看这个</a> 把镜像和本地库地址配置了就好</p>
<h3 id="3-自动配置"><a href="#3-自动配置" class="headerlink" title="3. 自动配置"></a>3. 自动配置</h3><ul>
<li>常用的三中模式</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、cocoon-<span class="number">22</span>-archetype-webapp   -- </span><br><span class="line"><span class="number">2</span>、maven-archetype-quickstart   -- <span class="number">7</span></span><br><span class="line"><span class="number">3</span>、maven-archetype-webapp       -- <span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.csdn.net/sirdean/article/details/81636658">其他的可以看这里</a></p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;groupId&#x27;</span>: 公司名</span><br><span class="line"><span class="string">&#x27;artifactId&#x27;</span>: 项目名字</span><br><span class="line"><span class="string">&#x27;version&#x27;</span>: 版本 (默认是 <span class="number">1.0</span>-SNAPSHOT)</span><br><span class="line"><span class="string">&#x27;package&#x27;</span>: com.sjs:包名</span><br></pre></td></tr></table></figure>

<p>Maven通过’groupId’, ‘artifactId’, ‘version’来定位 项目&#x2F;类库 坐标</p>
<h3 id="4-cmd配置-命令自动生成"><a href="#4-cmd配置-命令自动生成" class="headerlink" title="4. cmd配置(命令自动生成)"></a>4. cmd配置(命令自动生成)</h3><p>创建:</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate指令直接创建项目</span><br><span class="line">    mvn archetype:generate -DgroupId=公司名 -DartifactId=工程名 -Dviersion=<span class="number">1.0</span>-SNAPSHOT -Dpackage=包名</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">maven -v</span><br><span class="line">mvn test: 测试 (会有测试报告日止)</span><br><span class="line">mvn clean: clean</span><br><span class="line">mvn <span class="keyword">package</span>: 将当前这个项目打包成jar，或者是war，pom</span><br><span class="line">mvn install: 首先将pom.xml中需要的jar包安装到本地仓库上，并且，将自己打包然后安装到本地仓库上。</span><br><span class="line">mvn compile: 编译源代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>scope(定义依赖的范围)的6中属性值：</strong></li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile：默认的范围，编译测试运行都有效</span><br><span class="line">provided：编译和测试有效</span><br><span class="line">runtime：测试和运行时有效</span><br><span class="line">test：只在测试时有效</span><br><span class="line">system：在编译和测试时有效，移植性低，与本机系统相关联</span><br><span class="line"><span class="keyword">import</span>：导入范围，她只使用在dependencyManagement中，表示从其他的pom中导入dependency的配置</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>待做</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/07/25/JavaBase/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者例子"><a href="#观察者例子" class="headerlink" title="观察者例子"></a>观察者例子</h2><p>一个气象台 想要<strong>几个显示器</strong> , 数据从<strong>weather对象</strong>中获取 如果 weather 数据更新 显示器要更新对应数据</p>
<blockquote>
<p>显示器就是观察者 而气象台的数据weather 就是通知者(<strong>主题对象</strong>)</p>
</blockquote>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SunJusong</span></span><br><span class="line"><span class="comment"> * 观察者部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年 08月27日 23:17:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obs</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisPlay &#123;</span><br><span class="line">    <span class="type">float</span> temp; <span class="comment">// 温度</span></span><br><span class="line">    <span class="type">float</span> humidity; <span class="comment">// 湿度</span></span><br><span class="line">    <span class="type">float</span> pressur; <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> Subject weather; <span class="comment">// 天气对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Obs</span><span class="params">(Subject sub)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weather = sub;</span><br><span class="line">        sub.RegistObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现update 方法来显示</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temp = temp;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressur = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(temp + <span class="string">&quot;==&quot;</span> + humidity + <span class="string">&quot;==&quot;</span> + pressur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------观察者接口-------------------------</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------显示功能接口-----------------------</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DisPlay</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------主方法--------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建主体对象</span></span><br><span class="line">        <span class="type">Weather</span> <span class="variable">weather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weather</span>();</span><br><span class="line">        <span class="comment">// 创建观察者 当然 也可以是多个不同的类</span></span><br><span class="line">        <span class="type">Obs</span> <span class="variable">obs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obs</span>(weather);</span><br><span class="line">        <span class="type">Obs</span> <span class="variable">obs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obs</span>(weather);</span><br><span class="line">        <span class="type">Obs</span> <span class="variable">obs3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obs</span>(weather);</span><br><span class="line">        weather.setMessage(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        weather.RemoveObserver(obs2);</span><br><span class="line">        weather.setMessage(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SunJusong</span></span><br><span class="line"><span class="comment"> * 主体对象部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年 08月27日 23:14:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers; <span class="comment">// 观察者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Weather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RegistObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RemoveObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        observers.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temp, humidity, pressur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jdk自带 </span></span><br><span class="line"><span class="comment">    观察者要继承Observable 观察者实现 Observer</span></span><br><span class="line"><span class="comment">     public void change() &#123;</span></span><br><span class="line"><span class="comment">         // 封裝了通知和changed方法</span></span><br><span class="line"><span class="comment">         setChanged();</span></span><br><span class="line"><span class="comment">         notifyObservers();</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     public float getTemp() &#123;</span></span><br><span class="line"><span class="comment">         return temp;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     public float getHumidity() &#123;</span></span><br><span class="line"><span class="comment">         return humidity;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     public float getPressur() &#123;</span></span><br><span class="line"><span class="comment">         return pressur;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 传入更新的数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temp = temp;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressur = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体对象接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">RegistObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">RemoveObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="comment">// 更新信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/08/18/GRxYKhX5bvAluLs.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h2 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>定义了一种一对多的依赖关系, 让多个观察者对象同时监听某个<strong>主题对象</strong>. 这个主体对象发生变化时会通知所有的<strong>观察者</strong>, 使得他们自己可以更新自己</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/18/LPSEpFO87CcHmkB.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h2 id="观察者监听"><a href="#观察者监听" class="headerlink" title="观察者监听"></a>观察者监听</h2><p>观察者list</p>
<p>被观察者event</p>
<p>初始化和成就事件触发检测需要被移除的观察者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件监听list(在初始化时监听) -- 当事件触(发送时间event.fire) --  obs类根据条件遍历发送消息到对应的对象 -- 对象接收时间判断.... 是否取消监听...</span><br></pre></td></tr></table></figure>

<h2 id="java中lambda实现委托"><a href="#java中lambda实现委托" class="headerlink" title="java中lambda实现委托"></a>java中lambda实现委托</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托是一种引用方法类型, 一旦为委托分配了方法,委托与该方法有完全相同的行为. 委托方法使用和其他方法一样.委托可以看做对函数的抽象, 是函数的”类”, 委托的实例代表的一个具体的函数,</p>
<p>委托能搭载的方法必须有相同的参数列表和返回值 和java8中方法引用的实现方式相同</p>
<p><strong>代码实现:</strong></p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyAction&lt;Integer&gt; delegate; <span class="comment">// 委托事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------主方法--------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">        <span class="type">MyDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDelegate</span>();</span><br><span class="line">        <span class="comment">// 一:</span></span><br><span class="line">        delegate.delegate = (Integer i) -&gt; &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;;</span><br><span class="line">        delegate.delegate.action(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 二:</span></span><br><span class="line">        delegate.delegate = MyDelegate::action;</span><br><span class="line">        delegate.delegate.action(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;::&quot;</span> + <span class="string">&quot;--&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------委托类型接口(消费形)------------------</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyAction</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用委托实现观察者模式</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2021/07/25/JavaBase/Mysql/</url>
    <content><![CDATA[<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="Mysql介绍"><a href="#Mysql介绍" class="headerlink" title="Mysql介绍"></a>Mysql介绍</h2><ul>
<li>java企业级开发离不开数据库</li>
<li><strong>数据是所有软件体系中核心存在</strong> (DBA职位)</li>
</ul>
<blockquote>
<p>只会写代码,学好数据库,混饭吃</p>
<p>操作系统,数据结构 ! 不错的程序猿</p>
<p>离散数学,数字电路, 体系结构, 编译原理 + 经验 大佬</p>
</blockquote>
<h3 id="1-数据库-DB-DataBase"><a href="#1-数据库-DB-DataBase" class="headerlink" title="1. 数据库(DB, DataBase)"></a>1. 数据库(DB, DataBase)</h3><p>数据的仓库</p>
<p>SQL: 可以存储大量数据 500万以下都没问题</p>
<h4 id="数据库分类-SQL-x2F-NOSQL"><a href="#数据库分类-SQL-x2F-NOSQL" class="headerlink" title="数据库分类(SQL&#x2F;NOSQL)"></a>数据库分类(SQL&#x2F;NOSQL)</h4><ul>
<li>关系型数据库(SQL)<ul>
<li>Mysql, Oracle, Sql Server, DB2, SQLlite</li>
<li>通过表和表之间, 行和列之间的关系进行数据存储.</li>
</ul>
</li>
<li>菲关系型数据库(NOSQL)<ul>
<li>Redis, MongDB</li>
<li>存储对象,通过对象的自身属性. 而且使用key-value的关系存储的</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;DBSM(数据库管理系统)&#x3D;&#x3D;</p>
<ul>
<li>数据库的管理软件, 管理和维护我们的数据</li>
<li>MySql 就是DBMS</li>
</ul>
<h3 id="Mysql操作语句"><a href="#Mysql操作语句" class="headerlink" title="Mysql操作语句"></a>Mysql操作语句</h3><table>
<thead>
<tr>
<th align="left">操作语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mysqld - install</td>
<td align="left">安装数据库(在bin目录下)</td>
</tr>
<tr>
<td align="left">mysqld –initialize-insecure –user&#x3D;mysql</td>
<td align="left">初始化数据文件</td>
</tr>
<tr>
<td align="left">flush privileges;</td>
<td align="left">刷新权限</td>
</tr>
<tr>
<td align="left">net start mysql</td>
<td align="left">启动Mysql服务</td>
</tr>
<tr>
<td align="left">net stop mysql</td>
<td align="left">结束Mysql服务</td>
</tr>
<tr>
<td align="left">exit</td>
<td align="left">退出Mysql</td>
</tr>
</tbody></table>
<h3 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h3><ul>
<li>现在都是默认使用InnoDB</li>
<li>MySAM 比较老,以前用</li>
</ul>
<blockquote>
<p>区别:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">MySAM</th>
<th align="left">INNODB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 事务</td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>(ACID)</td>
</tr>
<tr>
<td align="left">2. 数据锁定方式</td>
<td align="left">表锁定</td>
<td align="left"><strong>行锁定,表锁定</strong></td>
</tr>
<tr>
<td align="left">3. 外键约束</td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong></td>
</tr>
<tr>
<td align="left">4. 全文索引</td>
<td align="left"><strong>支持</strong></td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">5, 表空间大小</td>
<td align="left">小</td>
<td align="left">大,约为MySAM的两倍</td>
</tr>
<tr>
<td align="left">6. 索引</td>
<td align="left">b+树</td>
<td align="left">b+树</td>
</tr>
</tbody></table>
<blockquote>
<p>在物理空间:</p>
</blockquote>
<p>所有数据库都是以文件形式存储在data目录下,一组文件对应一个数据库,本质还是文件存储</p>
<p>Mysql引擎</p>
<ul>
<li>INNODB在数据库上只有一个*.frm, 以及上级目录的ibdata1文件</li>
<li>MySAM<ul>
<li>*.frm 表结构</li>
<li>*.myd 数据文件(data)</li>
<li>*.MYI 索引文件(index)</li>
</ul>
</li>
</ul>
<h2 id="数据库操作语句"><a href="#数据库操作语句" class="headerlink" title="数据库操作语句"></a>数据库操作语句</h2><blockquote>
<p>书写顺序</p>
<p>select – from – where – group by – order by</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看有什么数据库</span></span><br><span class="line"><span class="keyword">show</span> database;</span><br><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line">creat database;</span><br><span class="line"><span class="comment">-- 使用库</span></span><br><span class="line"><span class="keyword">user</span> 库名;</span><br><span class="line"><span class="comment">-- 展示表</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="comment">-- 显示结构</span></span><br><span class="line"><span class="keyword">describe</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(列名 类型(长度));</span><br><span class="line"><span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>  <span class="keyword">column</span>  列名 类型();</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>  列名 类型();</span><br><span class="line"><span class="comment">--------------------------------------------------</span></span><br><span class="line"><span class="comment">--查看数据库建库语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 库;</span><br><span class="line"><span class="comment">-- 查看表的定义语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表;</span><br><span class="line"><span class="comment">-- 展示表结构</span></span><br><span class="line"><span class="keyword">desc</span> 表;</span><br></pre></td></tr></table></figure>

<h2 id="数据库聚合函数"><a href="#数据库聚合函数" class="headerlink" title="数据库聚合函数"></a>数据库聚合函数</h2><blockquote>
<p>聚合函数: 他们只运行非空值,如果有空值将不会计算在内</p>
<p>而且默认重复值会被取到</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本计算</span></span><br><span class="line"><span class="built_in">MAX</span>()</span><br><span class="line"><span class="built_in">MIN</span>()</span><br><span class="line"><span class="built_in">AVG</span>()</span><br><span class="line"><span class="built_in">SUM</span>()</span><br><span class="line"><span class="built_in">COUNT</span>()</span><br><span class="line"><span class="built_in">count</span>(参数) 一共多少行</span><br><span class="line">如果是<span class="operator">*</span> 那就是总数</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">DISTINCT</span> 参数)  除去重复</span><br><span class="line"><span class="comment">-- 去重</span></span><br><span class="line"><span class="keyword">DISTINCT</span> 名字</span><br><span class="line"><span class="comment">--日期</span></span><br><span class="line">    <span class="comment">-- 格式化日期</span></span><br><span class="line">    data _format(获取的日期,<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    <span class="comment">-- 当前时间</span></span><br><span class="line">    CURDATE()</span><br><span class="line"><span class="comment">-- 正则表达式 </span></span><br><span class="line">regexp()</span><br><span class="line">    <span class="comment">-- 模糊查询不用%</span></span><br><span class="line">    <span class="comment">-- ^a 表示以a开始</span></span><br><span class="line">    <span class="comment">-- a$ 以a结尾</span></span><br><span class="line">    <span class="comment">-- |  逻辑与</span></span><br><span class="line">    <span class="comment">-- [abc] 包括其中任一个</span></span><br><span class="line">    <span class="comment">-- [a-b] - 表示a到b的任一个</span></span><br><span class="line">LAST_INSERT_ID() <span class="comment">-- 最后一个INSERT或 UPDATE 自增长(AUTO_INCREMENT)列的ID</span></span><br><span class="line"><span class="comment">-- 分组</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 列<span class="number">1</span>,列<span class="number">2.</span>..</span><br><span class="line"><span class="comment">-- 在聚合函数(分组)后使用 的条件筛选</span></span><br><span class="line"><span class="keyword">having</span>条件 .. <span class="keyword">and</span> 条件<span class="number">2</span></span><br><span class="line"><span class="comment">-- WITH ROLLUP运算</span></span><br><span class="line">用来统计当前列的总和， 统计的是聚合函数的列  </span><br><span class="line">计算的结果是聚合函数的方式 sum是和， AVG是平均数</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列<span class="number">1</span>,列<span class="number">2.</span>.. <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">having</th>
<th align="left">where</th>
</tr>
</thead>
<tbody><tr>
<td align="left">只能判断select过的列名</td>
<td align="left">能判断所有列名</td>
</tr>
<tr>
<td align="left">其他差不多</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 家早va的并且 订单总额大于100</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.customer_id,</span><br><span class="line">    c.first_name,</span><br><span class="line">    c.last_name,</span><br><span class="line">    <span class="built_in">SUM</span>( oi.quantity <span class="operator">*</span> oi.unit_price ) <span class="keyword">AS</span> spend </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders o</span><br><span class="line">    <span class="keyword">JOIN</span> customers c <span class="keyword">USING</span> ( customer_id )</span><br><span class="line">    <span class="keyword">JOIN</span> order_items oi <span class="keyword">USING</span> ( order_id ) </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    c.state <span class="operator">=</span> <span class="string">&#x27;VA&#x27;</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    c.customer_id,</span><br><span class="line">    c.first_name,</span><br><span class="line">    c.last_name</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    spend <span class="operator">&gt;</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>

<h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><p>增删改查</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="查询-x2F-排序"><a href="#查询-x2F-排序" class="headerlink" title="查询&#x2F;排序"></a>查询&#x2F;排序</h4><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自动那个提交状态</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span></span><br><span class="line"><span class="comment">-- 条件查询</span></span><br><span class="line"><span class="keyword">where</span> ... <span class="keyword">and</span> ... <span class="keyword">or</span> ... ;</span><br><span class="line">    <span class="comment">-- 是否存在 可以代替and操作</span></span><br><span class="line">    <span class="keyword">in</span> (a,b,c)</span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">in</span> (a,b,c)</span><br><span class="line">    <span class="comment">--  是否存在</span></span><br><span class="line">    exist (返回的是 <span class="literal">true</span><span class="operator">/</span><span class="literal">false</span>) </span><br><span class="line">    <span class="comment">-- 在...之间</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">-- 空, 非空</span></span><br><span class="line">    <span class="keyword">is</span> <span class="keyword">null</span> <span class="operator">/</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>  </span><br><span class="line"><span class="comment">-- 模糊查询 like %表示任意数量字符 _表示单个任意字符 可以有多个_</span></span><br><span class="line"><span class="keyword">where</span> 列 <span class="keyword">like</span> <span class="string">&#x27;%val%&#x27;</span></span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;___啊&#x27;</span></span><br><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列  <span class="keyword">desc</span> 降序 <span class="keyword">asc</span> 升序</span><br><span class="line"><span class="comment">-- 截取</span></span><br><span class="line">limit x 表示从头截取x个</span><br><span class="line">limit y,x 表示从y开始截取x个 (分页会用)</span><br></pre></td></tr></table></figure>

<h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询:"></a>内连接查询:</h4><blockquote>
<p>复合主键: 表中主键数量超过一列</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- inner可以省略</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">1</span> <span class="keyword">on</span> 条件</span><br><span class="line"><span class="comment">-- 跨数据库链接</span></span><br><span class="line"><span class="keyword">join</span> a库.a表</span><br><span class="line"><span class="comment">-- 多表查询</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> ... <span class="keyword">join</span> 表<span class="number">3</span> <span class="keyword">on</span> ... ...</span><br><span class="line"><span class="comment">-- 复合链接: 知识点:复合主键 就是多了一个判断条件</span></span><br><span class="line"><span class="keyword">join</span> 表 <span class="keyword">on</span> ... <span class="keyword">and</span> ...</span><br><span class="line"><span class="comment">-- 隐式链接 </span></span><br><span class="line">把 <span class="keyword">join</span> <span class="keyword">on</span> 用 <span class="keyword">where</span> 代替 尽量不使用<span class="keyword">where</span></span><br></pre></td></tr></table></figure>

<h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询:"></a>外连接查询:</h4><blockquote>
<p>内连接如果不满足 on 的条件不会返回</p>
<p>外连接会以 left&#x2F;right 为主表 不满足也会返回</p>
<p>outer join (outer可以省略)</p>
<ul>
<li>两种:<ul>
<li>左连接: left join (一般情况使用左连接)</li>
<li>右链接: right join</li>
</ul>
</li>
</ul>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 多表连接</span></span><br><span class="line">例子:</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    o.order_date,</span><br><span class="line">    o.order_id,</span><br><span class="line">    c.first_name <span class="keyword">AS</span> customer,</span><br><span class="line">    s.`name` <span class="keyword">AS</span> shipper,</span><br><span class="line">    os.NAME <span class="keyword">AS</span> <span class="string">&#x27;status&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders o</span><br><span class="line">    <span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> c.customer_id</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> shippers s <span class="keyword">ON</span> s.shipper_id <span class="operator">=</span> o.shipper_id</span><br><span class="line">    <span class="keyword">JOIN</span> order_statuses os <span class="keyword">ON</span> os.order_status_id <span class="operator">=</span> o.`status`</span><br><span class="line"><span class="comment">-- using(列1,列2...)</span></span><br><span class="line"><span class="keyword">using</span>(列<span class="number">1</span>,列<span class="number">2.</span>..)</span><br><span class="line">可以替换掉 <span class="keyword">on</span> 但是要求要查询的两个表的的列明相等 当然也可以给多个参数用, 隔开</span><br></pre></td></tr></table></figure>

<h4 id="其他链接查询"><a href="#其他链接查询" class="headerlink" title="其他链接查询"></a>其他链接查询</h4><ul>
<li>自然连接 natural join:<br>数据库引擎自动匹配 不建议使用</li>
<li>交叉连接:</li>
</ul>
<blockquote>
<p>将两个表的数据交叉组合(三种饮料和三种杯子尺寸 交叉连接出所有状态)</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表<span class="number">1</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> (建议使用)</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span>, 表<span class="number">2</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>联合查询(UNION)</li>
</ul>
<blockquote>
<p>将多个查询结构集,合成一个 列数要相同, 列明取第一个查询语句</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1.</span>.. <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1.</span>.. <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1.</span>.. ...</span><br></pre></td></tr></table></figure>

<h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 子查询（嵌套查询)</span></span><br><span class="line">一个查询语句的结果是另一个的条件</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> a <span class="operator">=</span> （ <span class="keyword">select</span> ..） </span><br></pre></td></tr></table></figure>

<h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在嵌套查询中有用到嵌套外的数据 (缺点: 慢,内存消耗高)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 a <span class="keyword">where</span> val <span class="operator">&gt;</span> (<span class="keyword">select</span> val <span class="keyword">from</span> 表 b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id)  </span><br></pre></td></tr></table></figure>

<h5 id="子查询在-select-和-from中使用"><a href="#子查询在-select-和-from中使用" class="headerlink" title="子查询在 select 和 from中使用"></a>子查询在 select 和 from中使用</h5><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算和和平均值做差  在select中</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.client_id,</span><br><span class="line">    ( <span class="keyword">SELECT</span> <span class="built_in">SUM</span>( invoice_total ) <span class="keyword">FROM</span> invoices <span class="keyword">WHERE</span> c.client_id <span class="operator">=</span> client_id  ) <span class="keyword">AS</span> sum1_total,</span><br><span class="line">    ( <span class="keyword">SELECT</span> <span class="built_in">AVG</span>( invoice_total ) <span class="keyword">FROM</span> invoices ) <span class="keyword">AS</span> avg_total,</span><br><span class="line">    ( <span class="keyword">SELECT</span> sum1_total ) <span class="operator">-</span> ( <span class="keyword">SELECT</span> avg_total ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `invoices` i,</span><br><span class="line">    clients c </span><br><span class="line">    <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure>

<h3 id="插入-x2F-复制"><a href="#插入-x2F-复制" class="headerlink" title="插入&#x2F;复制"></a>插入&#x2F;复制</h3><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加数据</span></span><br><span class="line"><span class="comment">-- defaut 表示默认</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">value</span>( defaut ,字段值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>) ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,名<span class="number">2</span>名<span class="number">3</span>) <span class="keyword">value</span>(字段值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>) ;</span><br><span class="line"><span class="comment">-- 多行插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(字段...) <span class="keyword">values</span> (值...),(值...) ... 插入多个数据</span><br><span class="line"><span class="comment">-- 多表 插入</span></span><br><span class="line">LAST_INSERT_ID() <span class="comment">-- 最近插入ID</span></span><br><span class="line"><span class="comment">-- 复制表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表 select... <span class="comment">-- 创建一个你查询出来的表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 select...  <span class="comment">-- 插入一个你查询的表</span></span><br></pre></td></tr></table></figure>

<h3 id="更新-x2F-删除"><a href="#更新-x2F-删除" class="headerlink" title="更新&#x2F;删除"></a>更新&#x2F;删除</h3><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 字段<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2.</span>.. <span class="keyword">where</span> 字段位置 <span class="operator">=</span> 值;</span><br><span class="line"><span class="comment">-- 多行更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span><span class="operator">+</span><span class="number">50</span>,字段<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2.</span>.. <span class="keyword">WHERE</span> 条件 <span class="comment">-- 条件可以选定多行数据</span></span><br><span class="line"><span class="comment">-- 在update中使用 select</span></span><br><span class="line">嵌套查询结果集</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> <span class="keyword">WHERE</span> 列<span class="number">1</span><span class="operator">=</span>( <span class="keyword">select</span> 语句)</span><br><span class="line"><span class="comment">--------------删除--------------</span></span><br><span class="line"><span class="keyword">delete</span> <span class="operator">/</span> <span class="keyword">truncate</span> <span class="keyword">table</span> 表名;  删除全表</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="operator">=</span> 字段值;</span><br><span class="line">当然可以嵌套<span class="keyword">select</span>语句:</span><br><span class="line"><span class="keyword">delete</span> 表名 <span class="keyword">WHERE</span> 列<span class="number">1</span><span class="operator">=</span>( <span class="keyword">select</span> 语句)</span><br></pre></td></tr></table></figure>

<h2 id="一些函数、关键字"><a href="#一些函数、关键字" class="headerlink" title="一些函数、关键字"></a>一些函数、关键字</h2><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 判断空</span></span><br><span class="line">IFNULL(a,b) 如果第一个a是空那么返回b</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in/not in</span></span><br><span class="line"><span class="keyword">in</span> <span class="operator">/</span> <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">当子查询是一个集合 就用 <span class="keyword">in</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> a <span class="keyword">in</span> （ <span class="keyword">select</span> ..） </span><br><span class="line"><span class="comment">-- ALL 查询</span></span><br><span class="line"><span class="comment">-- 表示括号里的全部  (&gt; ALl) 大于全部</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段 <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4.</span>...);</span><br><span class="line"><span class="comment">-- = ANY / SOME  (= ANY  和  IN 等效)</span></span><br><span class="line"><span class="comment">-- 返回一个集合中所有条件的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段 <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4.</span>...);</span><br><span class="line"><span class="comment">-- explain + 语句</span></span><br><span class="line">查看性能 <span class="keyword">sql</span>优化</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p>视图数据是同步的(数据同步的)</p>
<p>创建视图时 <strong>不使用</strong> Distinct &#x2F; union 以及 sum &#x2F; group by … 聚合函数 的view 就是可更新表</p>
<p>视图可以减小数据库设计改动的影响 简化查询操作</p>
</blockquote>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> clients_balance <span class="keyword">AS</span> <span class="keyword">select</span> ... 把查询的东西存进去</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace  或者用这个语句 </span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> name</span><br><span class="line"><span class="comment">-- 修改视图 防止数据被删掉</span></span><br><span class="line">在创建视图后加上</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option</span><br></pre></td></tr></table></figure>

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建函数(存储过程) </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_invoices_and_balance() <span class="comment">-- 参数 相当于函数的参数</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    invoices </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ( invoice_total <span class="operator">-</span> payment_total ) <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- 定义结束符号</span></span><br><span class="line">DELIMITER $$ </span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 添加参数 当然查询时也要加参数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> name ( valName1 TYPE1,valName2 TYPE2 ) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="comment">-- 如果要判断条件</span></span><br><span class="line">IF valName1 <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> valName2 <span class="keyword">is</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>





<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 执行过程</span></span><br><span class="line"><span class="keyword">CALL</span> get_invoices_and_balance;</span><br><span class="line"><span class="comment">-- 删除过程 If exists 判断是否存在 可以不加</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> If <span class="keyword">exists</span> name;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>sql 可以存的格式</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Data and Time</li>
<li>Blob</li>
<li>Spatial</li>
</ul>
<h3 id="1-常见的String"><a href="#1-常见的String" class="headerlink" title="1. 常见的String"></a>1. 常见的String</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Name</th>
<th align="left">MAX</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">char()</td>
<td align="left">固定长度</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">varChar()</td>
<td align="left">65000 Characters(~64kb)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">mediumText</td>
<td align="left">16MB</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">longT&#96;ext</td>
<td align="left">4GB</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">TinyText</td>
<td align="left">255 bytes</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Text</td>
<td align="left">64kb</td>
</tr>
</tbody></table>
<h3 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Data type</th>
<th align="left">Bytes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">TINYINT</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SMALLINT</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">MEDIUMINT</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">INTEGER</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">BIGINT</td>
<td align="left">8</td>
</tr>
</tbody></table>
<h3 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3. 浮点数"></a>3. 浮点数</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Data type</th>
<th align="left">explain</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Decimal(P, S)</td>
<td align="left">p: 位数 s: 小数 位 (比较精准)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Dec&#x2F;Numeric&#x2F;Fixed</td>
<td align="left">和上面名字不同</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Float &#x2F; Double</td>
<td align="left">科学计数 不是特别精准</td>
</tr>
</tbody></table>
<h3 id="4-时间"><a href="#4-时间" class="headerlink" title="4. 时间"></a>4. 时间</h3><p>存储时间</p>
<ol>
<li>Data:</li>
<li>Time:</li>
<li>Datetime: 8b</li>
<li>Timestamp: 4b (因为4b所以会有2038问题(时间存储会出问题) 好奇可以搜索一下)</li>
<li>Year</li>
</ol>
<h3 id="5-blob类型"><a href="#5-blob类型" class="headerlink" title="5. blob类型"></a>5. blob类型</h3><p>存储所有的二进制结构的文件: 图片 pdf word 等等</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Data type</th>
<th align="left">size</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">TinyBlob</td>
<td align="left">225b</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Blob</td>
<td align="left">65kb</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">mediumBlob</td>
<td align="left">16mb</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">LongBlob</td>
<td align="left">4gb</td>
</tr>
</tbody></table>
<p><strong>因为将数据库中存入文件会将数据库变得很大. 而且读取效率 备份时间 以及开发代码 都会变得多 所以考虑存储文件前 线考虑这些问题</strong></p>
<h3 id="6-Json"><a href="#6-Json" class="headerlink" title="6 Json"></a>6 Json</h3><p>mysql 8 以后开始支持</p>
<ul>
<li><p>Json</p>
</li>
<li><p>写: Json_Object(json对象)</p>
</li>
<li><p>查询</p>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, properties <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$. name.childName&#x27;</span> <span class="keyword">from</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">where</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> properties <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;$. name.childName&#x27;</span> : 值读取值</span><br></pre></td></tr></table></figure>

<ul>
<li>json函数 很多都比较方便 可以试试</li>
</ul>
</li>
</ul>
<h3 id="布尔-集合和枚举"><a href="#布尔-集合和枚举" class="headerlink" title=". 布尔, 集合和枚举"></a>. 布尔, 集合和枚举</h3><ol>
<li><p>bool &#x2F; boolean: T&#x2F;F (1&#x2F;0)</p>
</li>
<li><p>set 并不是很好用</p>
</li>
<li><p>enum(A,B,C) 也不是很建议使用: 是固定的 而且</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2></li>
</ol>
<p>这一部分只是大概介绍一下： 因为需要很多实践就不放在这里了</p>
<p>如果需要设计一个数据库：</p>
<ol>
<li>Understand the requirements（了解需求是很重要的）</li>
<li>建立 <strong>概念，逻辑，实体</strong> 模型</li>
</ol>
<h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><p>数据库概念模型实际上是现实世界到机器世界的一个中间层次。侧重于具体的功能在实际世界的实现，</p>
<p>逻辑模型在概念模型的基础上更细化。 更侧重于数据库的实现</p>
<p><img src="https://i.loli.net/2020/12/20/USWmxrKMesuA5To.png" alt="概念模型和概念模型"></p>
<p><strong>概念模型和概念模型</strong></p>
<p>实体模型：具体的数据库模型</p>
<p>主键：数据库标识（唯一的） 还可以复合主键</p>
<p>外键： 如果一个字段X在A表中是主关键字，而在另外一张表B表中不是主关键字，则字段X称为表二的外键；</p>
<ul>
<li><p>外键约束： 虽说主键尽量不可修改 但是外键有 对应修改和删除的操作：</p>
<p>&#x3D;&#x3D;<strong>on delete&#x2F;update 规则：</strong>&#x3D;&#x3D;</p>
<ol>
<li><p>CASCADE：级联</p>
<p>（1）所谓的级联删除，就是删除主键表的同时，外键表同时删除。</p>
</li>
<li><p>NO ACTION(非活动，默认)、RESTRICT：约束&#x2F;限制</p>
<p>当取值为No Action或者Restrict时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除。（即外键表约束主键表）</p>
<p><strong>NO ACTION</strong>和<strong>RESTRICT</strong>的区别：只有在及个别的情况下会导致区别，前者是在其他约束的动作之后执行，后者具有最高的优先权执行。</p>
</li>
<li><p>SET NULL</p>
<p>当取值为Set Null时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（一样是外键表约束主键表，不过这就要求该外键允许取null）。</p>
</li>
</ol>
</li>
</ul>
<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>数据库七大约束中三范式最为重要 ： 保证了数据库的不冗余， 便捷等</p>
<h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ol>
<li>表的每一列都是<strong>不可分割的原子数据</strong></li>
<li>非主键必须<strong>完全依赖于主键</strong></li>
<li>非主键必须<strong>直接</strong>依赖主键(不能有传递和间接关系)</li>
</ol>
<h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><p>其实这些范式我记的并不全面，而且实际应用当中 <em>并不一定严格准守这些约束</em> 尽可能的消除冗余就好了。</p>
<ol>
<li>但是 尽量先建立模型 ， 在建立数据库， 否则会很糟糕。</li>
<li>但是 并不一定都需要建模， 因为建模可能和实际不符合，并且过于复杂且无用，值需要为当下确定一个可行方案， 而不是想要设计一个永远不出问题的模型</li>
</ol>
<ul>
<li>模型正向工程： 我们创建了模型 – 将模型转换为脚本 – 执行 （可以同步修改表和模型）</li>
<li>模型逆向工程： 将数据库转换为 模型</li>
</ul>
<p><img src="https://i.loli.net/2020/12/21/WtrYFqwLo5fkzS9.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ul>
<li>练习 <a href="https://sunxinan12138.github.io/2020/07/07/Mysql/todo">航空系统</a> 链接</li>
</ul>
<h2 id="数据库保护"><a href="#数据库保护" class="headerlink" title="数据库保护"></a>数据库保护</h2><p>因为一直在本地运行，如果在真实项目要考虑安全问题</p>
<h3 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h3><p>CURD 管理可访问到数据库的用户</p>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> join11 <span class="variable">@172</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123123&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> join11 IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123123&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span>    <span class="operator">*</span> <span class="keyword">FROM</span>    mysql.`<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> join11 <span class="variable">@172</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">权限：</span><br><span class="line"><span class="keyword">GRANT</span> 权限 <span class="keyword">on</span> tablename <span class="keyword">from</span> name <span class="comment">-- 增加</span></span><br><span class="line">ROvoke 。。。 <span class="comment">-- 撤销</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_30892763/article/details/95682481">Mysql所有权限</a></p>
<table>
<thead>
<tr>
<th align="left">Privilege</th>
<th align="left">Column</th>
<th align="left">Context</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td>
<td align="left"><code>Create_priv</code></td>
<td align="left">databases, tables, or indexes</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td>
<td align="left"><code>Drop_priv</code></td>
<td align="left">databases, tables, or views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td>
<td align="left"><code>Grant_priv</code></td>
<td align="left">databases, tables, or stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td>
<td align="left"><code>Lock_tables_priv</code></td>
<td align="left">databases</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td>
<td align="left"><code>References_priv</code></td>
<td align="left">databases or tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td>
<td align="left"><code>Event_priv</code></td>
<td align="left">databases</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td>
<td align="left"><code>Alter_priv</code></td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td>
<td align="left"><code>Delete_priv</code></td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td>
<td align="left"><code>Index_priv</code></td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td>
<td align="left"><code>Insert_priv</code></td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td>
<td align="left"><code>Select_priv</code></td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td>
<td align="left"><code>Update_priv</code></td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td>
<td align="left"><code>Create_tmp_table_priv</code></td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td>
<td align="left"><code>Trigger_priv</code></td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td>
<td align="left"><code>Create_view_priv</code></td>
<td align="left">views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td>
<td align="left"><code>Show_view_priv</code></td>
<td align="left">views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td>
<td align="left"><code>Alter_routine_priv</code></td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td>
<td align="left"><code>Create_routine_priv</code></td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td>
<td align="left"><code>Execute_priv</code></td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_file"><code>FILE</code></a></td>
<td align="left"><code>File_priv</code></td>
<td align="left">file access on server host</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td>
<td align="left"><code>Create_tablespace_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td>
<td align="left"><code>Create_user_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_process">PROCESS</a></td>
<td align="left"><code>Process_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_proxy">PROXY</a></td>
<td align="left">see <code>proxies_priv</code> table</td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_reload">RELOAD</a></td>
<td align="left"><code>Reload_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_replication-client">REPLICATION CLIENT</a></td>
<td align="left"><code>Repl_client_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_replication-slave">REPLICATION SLAVE</a></td>
<td align="left"><code>Repl_slave_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_show-databases">SHOW DATABASES</a></td>
<td align="left"><code>Show_db_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_shutdown">SHUTDOWN</a></td>
<td align="left"><code>Shutdown_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_super">SUPER</a></td>
<td align="left"><code>Super_priv</code></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left">[ALL <a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_all">PRIVILEGES]</a></td>
<td align="left"></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_usage">USAGE</a></td>
<td align="left"></td>
<td align="left">server administration</td>
</tr>
</tbody></table>
<hr>
<h2 id="InnoDB和MySAM"><a href="#InnoDB和MySAM" class="headerlink" title="InnoDB和MySAM"></a>InnoDB和MySAM</h2><ul>
<li>现在都是默认使用InnoDB</li>
<li>MySAM 比较老,以前用</li>
</ul>
<blockquote>
<p>区别:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">MySAM</th>
<th align="left">INNODB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事务</td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong></td>
</tr>
<tr>
<td align="left">数据锁定方式</td>
<td align="left">表锁定</td>
<td align="left"><strong>行锁定</strong></td>
</tr>
<tr>
<td align="left">外键约束</td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong></td>
</tr>
<tr>
<td align="left">全文索引</td>
<td align="left"><strong>支持</strong></td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">表空间大小</td>
<td align="left">小</td>
<td align="left">大,约为MySAM的两倍</td>
</tr>
<tr>
<td align="left">聚集索引</td>
<td align="left">比普通索引多了个约束</td>
<td align="left">叶子节点就是数据节点</td>
</tr>
</tbody></table>
<blockquote>
<p>在物理空间:</p>
</blockquote>
<p>所有数据库都是以文件形式存储在data目录下,一组文件对应一个数据库,本质还是文件存储</p>
<p>Mysql引擎</p>
<ul>
<li>INNODB在数据库上只有一个*.frm, 以及上级目录的ibdata1文件</li>
<li>MySAM<ul>
<li>*.frm 表结构</li>
<li>*.myd 数据文件(data)</li>
<li>*.MYI 索引文件(index)</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>IO次数和数据结构的次数有关(树 – 就是高度) , 如果没有索引那就是一个数据一次IO</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><a href="https://zhuanlan.zhihu.com/p/29118331">https://zhuanlan.zhihu.com/p/29118331</a></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>mysql的索引分为单列索引(主键索引(聚集索引),唯一索引(UNIQUE INDEX),普通索引(INDEX ))和组合索引.</p>
<p>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.</p>
<p>组合索引:一个组合索引包含两个或两个以上的列,</p>
<hr>
<p>聚集索引: 数据行的物理顺序与列值的<strong>顺序相同</strong></p>
<p>非聚集索引: 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。(普通索引，唯一索引，全文索引)</p>
<p>回表查询解决方式: 复合索引（覆盖索引）</p>
<p>sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 组合</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX IndexName <span class="keyword">On</span> `TableName`(`字段名`(length),`字段名`(length),...);</span><br></pre></td></tr></table></figure>

<p>覆盖索引: select 的 和查找的都是索引</p>
<blockquote>
<p>索引的数据结构:</p>
</blockquote>
<p>哈希:</p>
<p>B树</p>
<p>B+树</p>
<blockquote>
<p>索引</p>
<p><a href="https://www.jianshu.com/p/2879225ba243">https://www.jianshu.com/p/2879225ba243</a></p>
</blockquote>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p><em>TODO：</em></p>
<ul>
<li>P52 - p63 一些函数和语句: 我跳了</li>
<li>P74 - P84 存储过程的其他东西 和 触发器 我跳了</li>
<li>还差索引</li>
<li>整理</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/jiadajing267/article/details/81269067">Mysql调优 – explain</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2021/07/25/JavaBase/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><blockquote>
<p>什么是分布式系统</p>
<p>建立在网络之上的软件系统</p>
</blockquote>
<p>在《分布式系统原理与范型》一书中定义:<strong>分布式系统是若干独立计算机的集合, 这些计算机对于用户来说就像单个相关系统</strong></p>
<p>分布式系统是由一组通过网络进行通信, 为了完成共同任务而协调工作的计算机节点组成的系统, 分布式系统的出现是为了用廉价的, 普通的机器完成单个计算机无法完成的计算, 存储任务. 其目的是&#x3D;&#x3D;利用更多的机器, 处理更多的数据&#x3D;&#x3D;</p>
<blockquote>
<p>分布式的进化过程</p>
</blockquote>
<ol>
<li>刚开始是: 单一应用架构ORM</li>
<li>垂直应用架构MVC</li>
<li>分布式服务框架**(RPC, 并发)**</li>
</ol>
<p><img src="https://i.loli.net/2020/08/24/u8tkBrvRU2ps4Gy.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li>流动计算架构 <strong>提高机器利用率的资源调度和治理中心</strong>(SOA)</li>
</ol>
<blockquote>
<p>分布式的高性能体现</p>
</blockquote>
<ol>
<li>并行性(parallelism)</li>
<li>容错性 (fault - tolerance)<ul>
<li>可用性: 因为系统是相对隔离的所以尽管出现了一些故障 还是可以运行的</li>
<li>可恢复性: 其中一个服务器坏了 修好了还能正常一样运行 减少一些不必要的重启</li>
<li>复制技术: 将数据做多个副本, 就算出现问题也能保证数据不出问题</li>
</ul>
</li>
<li>在物理层面实现 ( 不同地方的计算机实现数据交互 )</li>
<li>实现了系统的隔离 会相对的安全 : (功能分开 利用网络通信来链接 其中一个服务崩溃 不会影响总体的服务)</li>
<li>可扩展性: 两倍的计算机 可以拥有两倍的处理性能(并行处理)或吞吐量 (理想条件)</li>
</ol>
<h2 id="分布式架构的问题"><a href="#分布式架构的问题" class="headerlink" title="分布式架构的问题"></a>分布式架构的问题</h2><p>虽然分布式大大增加了系统的性能但是需要解决的问题也多了 数据一致性啊 传输速度和方案啊 因为服务器数量增加了 单一服务器出现的小概率问题 也会显现出来</p>
<blockquote>
<p>一致性</p>
</blockquote>
<ul>
<li><p>强一致性 (每次修改数据同步所有服务器节点)(高消耗) : 因为数据同步时需要网络传输 如果每次操作都需要将所有服务器都同步 开销很大的</p>
<p>如果创建了副本 副本肯定不在同一个地方 这样的化通信时间也是问题</p>
</li>
<li><p>若一致性(修改数据不需要同步所有节点. 要有一些策略来保证获得数据时的正确性): 还是比较优秀的</p>
<p>还有一种处理方式 在获取数据时 : 多获取几个版本的 做到数据一致性</p>
</li>
</ul>
<blockquote>
<p>非易失性存储(Non-Volatile-Storage)</p>
</blockquote>
<p>非易失性存储的数据更新时的代价很高</p>
<p>非易失性存储的管理技巧: LOG WAL Redo&#x2F;Undo</p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>2003年谷歌用来实现分布式计算海量数据的计算的一个技术 当然也是一种思想</p>
<h3 id="Map和Reduce"><a href="#Map和Reduce" class="headerlink" title="Map和Reduce"></a>Map和Reduce</h3><p>看了知乎的一篇文章解释的很到位</p>
<p>Map的本质实际上是拆解，比如说有辆红色的小汽车，有一群工人，把它拆成零件了，这就是Map。</p>
<p><img src="https://pic3.zhimg.com/80/v2-60294db5923f28063681a47e8b4be66e_720w.jpg" alt="img"></p>
<p><strong>img</strong></p>
<p>那什么是Reduce呢？Reduce就是组合，我们有很多汽车零件，还有很多其他各种装置零件，把他们一阵拼装，变成变形金刚，这就是Reduce。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d32f853d005bacd372128679b9fa05ad_720w.jpg" alt="img"></p>
<p><strong>img</strong></p>
<ul>
<li>MapReduce就是把文件输入拆解分类 然后按照你需要的方式传出结果(排序,筛选….)</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>大致分为六部: Input, Split, Map, Shuffle, Reduce(归约函数), Finalize</p>
<blockquote>
<p>举个例子 处理文件中相同数据的个数</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/05/yTobZcFjs7IlLm9.png" alt="MapReduce"></p>
<p><strong>MapReduce</strong></p>
<p>当然 处理结果也可以作为下一步操作的输入文件</p>
<p>shuffle 传递时会产生流量 实际上这是大量的数据</p>
<h3 id="真实情况下MapReduce怎么用众多服务器实现呢"><a href="#真实情况下MapReduce怎么用众多服务器实现呢" class="headerlink" title="真实情况下MapReduce怎么用众多服务器实现呢"></a>真实情况下MapReduce怎么用众多服务器实现呢</h3><p>job: 处理业务逻辑的一个整体</p>
<p>task: 调用执行MapReduce叫一个Task</p>
<p>Worker: 程序申请时 由Master worker来负责调度 由不同的worker来进行map&#x2F;Reduce 当然可以是不同的服务器</p>
<p><img src="https://i.loli.net/2020/10/05/7IgflH1xGoDCSdp.png" alt="MapReduce架构"></p>
<p><strong>MapReduce架构</strong></p>
<h1 id="雪花算法-–-分布式中确保唯一id的算法"><a href="#雪花算法-–-分布式中确保唯一id的算法" class="headerlink" title="雪花算法 – 分布式中确保唯一id的算法"></a>雪花算法 – 分布式中确保唯一id的算法</h1><p><img src="https://i.loli.net/2020/10/02/3CITvUSjqGHdsnA.png" alt="image-20200912161729887.png"></p>
<p><strong>image-20200912161729887.png</strong></p>
<ol>
<li>加锁获取id 下面三组数据与运算</li>
</ol>
<blockquote>
<p>private long sequenceMask &#x3D; -1L ^ (-1L &lt;&lt; sequenceBits); 一个long类型的最大值(12位的1) 4096</p>
<p>-1L二进制全是一(反码的补码) 左移 sequenceBits(12) 位 得到 <strong>12位的1</strong></p>
</blockquote>
<ul>
<li>时间戳 左移22位 <code>如果序列号加一 与上 sequenceMask (12位的1)为0</code> 那么进入下一毫秒<code>tilNextMillis</code></li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>机房号(左移17位) 和 机位id (左移12位) (一共1024个)</li>
<li>序列号 sequence</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask; <span class="comment">// 正好12位的值</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123; <span class="comment">// 证明数值超出了</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">lastTimestamp = timestamp;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/32172999">深入浅出MapReduce</a></p>
<p><a href="https://blog.csdn.net/qq_35078688/article/details/83240661">mapreduce Java实现</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2021/07/25/net/Netty/</url>
    <content><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty是一个由JBoss提供的java开源框架,</p>
<p>Netty是一个异步的, 基于事件驱动的网络应用框架, 用于快速开发高性能, 高可用的网络IO程序.</p>
<p>Netty主要针对在TCP协议下, 面向client端的高并发应用, 或者Peer-to-Peer场景下的大量数据持续传输应用.</p>
<p>Netty 主要基于NIO</p>
<ul>
<li><h2 id="四种IO"><a href="#四种IO" class="headerlink" title="四种IO"></a>四种IO</h2></li>
</ul>
<blockquote>
<p>netty 是基于 NIO 那先简单介绍一下IO</p>
</blockquote>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><ol>
<li>I&#x2F;O模型: 简单理解就是用什么方式进行数据的发送和接收, 决定了通信的性能</li>
<li>三种IO模型:</li>
</ol>
<h4 id="BIO-同步并阻塞"><a href="#BIO-同步并阻塞" class="headerlink" title="BIO(同步并阻塞)"></a>BIO(同步并阻塞)</h4><p>一个连接创建一个线程, 客户端有连接请求时服务器端就需要启动一个线程处理, 如果连接不进行操作还会造成<strong>不必要的开销</strong></p>
<p><img src="https://i.loli.net/2020/08/25/Ttdh36PEOjWy2vC.png" alt="BIO"></p>
<p><strong>BIO</strong></p>
<ul>
<li>BIO例子</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serverBIo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lianjie...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环链接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            accept = socket.accept();</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">finalAccept</span> <span class="operator">=</span> accept;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                handler(finalAccept);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">returnMsg</span><span class="params">(Socket finalAccept, String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return&quot;</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> finalAccept.getOutputStream();</span><br><span class="line">        outputStream.write(s.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//  outputStream.close();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket accept)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stream = accept.getInputStream();</span><br><span class="line">            System.out.println(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stream.read(bytes);</span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">String</span>(bytes) + <span class="string">&quot;:::&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">if</span> (i != -<span class="number">1</span>) System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stream.close();</span><br><span class="line">                returnMsg(accept, s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MainDemo</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainDemo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.serverBIo();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点:</strong></p>
<ul>
<li>需要独立的线程 并发大时 &#x3D;&#x3D;需要大量的线程进行处理&#x3D;&#x3D; 并且 如果没有读写操作 线程会阻塞在Read上 造成资源浪费</li>
</ul>
<h4 id="NIO-同步非阻塞"><a href="#NIO-同步非阻塞" class="headerlink" title="NIO(同步非阻塞)"></a>NIO(同步非阻塞)</h4><p>和BIO相比 实现了一个<strong>多路复用</strong>的功能 服务器可以用一个线程处理多个连接, 多路复用器进行轮询如果有IO请求就处理</p>
<p><img src="https://i.loli.net/2020/08/25/LQHDTZR8NGntb76.png" alt="NIO"></p>
<p><strong>NIO</strong></p>
<blockquote>
<p>三大核心: Selector Channel Buffer</p>
</blockquote>
<p>具体方式:</p>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200825235215229.png" alt="image-20200825235215229"></p>
<p><strong>image-20200825235215229</strong></p>
<p>NIO的通讯:</p>
<ul>
<li>客户端</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">//服务器地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//得到选择器</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接远程服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//注册选择器并设置为 read</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到客户端 IP 地址和端口信息，作为聊天用户名使用</span></span><br><span class="line">        userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userName + <span class="string">&quot; is ok ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器端发送数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//如果控制台输入 exit 就关闭通道，结束聊天</span></span><br><span class="line">        <span class="keyword">if</span> (info.equalsIgnoreCase(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            socketChannel = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        info = userName + <span class="string">&quot; 说: &quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//往通道中写数据</span></span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从服务器端接收数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readyChannels &gt; <span class="number">0</span>) &#123; <span class="comment">//有可用通道</span></span><br><span class="line">                <span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">keyIterator</span> <span class="operator">=</span> selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> (SelectionKey) keyIterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到关联的通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) sk.channel();</span><br><span class="line">                        <span class="comment">//得到一个缓冲区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buff</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取数据并存储到缓冲区</span></span><br><span class="line">                        sc.read(buff);</span><br><span class="line">                        <span class="comment">//把缓冲区数据转换成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buff.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    keyIterator.remove(); <span class="comment">//删除当前 SelectionKey，防止重复处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//会检测到没有可用的channel ，可以退出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;没有可用channel ...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception  &#123;</span><br><span class="line">        <span class="comment">//创建一个聊天客户端对象</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123; <span class="comment">//单独开一个线程不断的接收服务器端广播的数据</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123; <span class="comment">//间隔 3 秒</span></span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在控制台输入数据并发送到服务器端</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(msg.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenerChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 打开监听通道</span></span><br><span class="line">            listenerChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">            listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 将选择器绑定到监听通道并监听 accept 事件</span></span><br><span class="line">            listenerChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            printInfo(<span class="string">&quot;服务器 ok.......&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//不停轮询</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();<span class="comment">//获取就绪 channel</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">// 监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenerChannel.accept();</span><br><span class="line">                            <span class="comment">//非阻塞模式</span></span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//注册到选择器上并监听 read</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//System.out.println(sc.getRemoteAddress().toString().substring(1) + &quot;online ...&quot;);</span></span><br><span class="line">                            System.out.println(sc.socket().getRemoteSocketAddress().toString().substring(<span class="number">1</span>) + <span class="string">&quot; 上线 ...&quot;</span>);</span><br><span class="line">                            <span class="comment">//将此对应的 channel 设置为 accept,接着准备接受其他客户端请求</span></span><br><span class="line">                            key.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//监听到 read</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readData(key); <span class="comment">//读取客户端发来的数据</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//一定要把当前 key 删掉，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;waitting ...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到关联的通道</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//设置 buffer 缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//从通道中读取数据并存储到缓冲区中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//如果读取到了数据</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓冲区数据转换为字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line"></span><br><span class="line">                printInfo(msg);</span><br><span class="line">                <span class="comment">//将关联的 channel 设置为 read，继续准备接受数据</span></span><br><span class="line">                key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                sendInfoToOtherClients(channel, msg); <span class="comment">//向所有客户端广播数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//当客户端关闭 channel 时，进行异常如理</span></span><br><span class="line">                <span class="comment">//printInfo(channel.getRemoteAddress().toString().substring(1) + &quot;offline...&quot;);</span></span><br><span class="line">                printInfo(channel.socket().getRemoteSocketAddress().toString().substring(<span class="number">1</span>) + <span class="string">&quot; 离线了 ...&quot;</span>);</span><br><span class="line">                key.cancel(); <span class="comment">//取消注册</span></span><br><span class="line">                channel.close(); <span class="comment">//关闭通道</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(SocketChannel except, String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器进行消息转发 ...&quot;</span>);</span><br><span class="line">        <span class="comment">//转发数据到所有的 SocketChannel 中</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetchannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自身</span></span><br><span class="line">            <span class="keyword">if</span> (targetchannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetchannel != except) &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetchannel;</span><br><span class="line">                <span class="comment">//把数据存储到缓冲区中</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//往通道中写数据</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String str)</span> &#123; <span class="comment">//显示消息</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息 时间: [&quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date()) + <span class="string">&quot;] -&gt; &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://sunxinan12138.github.io/2020/10/02/netty/#">细节的NIO在这</a></li>
</ul>
<h4 id="AIO-异步非阻塞-一般用于长稳定的连接"><a href="#AIO-异步非阻塞-一般用于长稳定的连接" class="headerlink" title="AIO(异步非阻塞)一般用于长稳定的连接"></a>AIO(异步非阻塞)一般用于长稳定的连接</h4><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><h3 id="什么是Reactor"><a href="#什么是Reactor" class="headerlink" title="什么是Reactor"></a>什么是Reactor</h3><p>wiki上reactor的解释</p>
<ul>
<li>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</li>
<li>说人话就是来处理一个或者多个输入请求的事件处理模式(基于事件驱动). 采用IO复用监听事件</li>
<li>服务器端将传入的请求分派到相应的线程进行处理所以也是Dispatcher模式</li>
</ul>
<blockquote>
<p>先看一下传统的模型:</p>
</blockquote>
<p><img src="https://i.loli.net/2020/09/10/8nVLgUWyYIswPbD.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p><strong>问题分析</strong></p>
<ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</li>
</ol>
<blockquote>
<p>Reactor模型(IO复用)</p>
</blockquote>
<p><img src="https://i.loli.net/2020/09/10/yTOxXHjq3LoAdCP.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li>Reactor 模式，通过一个或多个输入同时传递给<strong>服务处理器</strong>的模式(基于事件驱动)</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此Reactor模式也叫 Dispatcher模式</li>
<li>Reactor 模式使用IO复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键</li>
</ol>
<h3 id="三种reactor实现"><a href="#三种reactor实现" class="headerlink" title="三种reactor实现"></a>三种reactor实现</h3><blockquote>
<p>单reactor单线程实现方式</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/18/6McxaiBhpH218Xw.png" alt="单线程"></p>
<p><strong>单线程</strong></p>
<ul>
<li>select：通过一个阻塞对象监听多路连接请求</li>
<li>实现流程：</li>
</ul>
<p>客户端的请求由Reactor中的select监听请求类型 :</p>
<ol>
<li>建立连接（Accept来创建handler对象处理业务）2. 其他请求由handler来处理</li>
</ol>
<ul>
<li>因为是的单线程所以请求多或者业务处理耗时很大时还是会发生<strong>阻塞</strong>情况</li>
</ul>
<blockquote>
<p>单reactor多线程</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/18/5l9JyYQf6Tu2Hoc.png" alt="多线程"></p>
<p><strong>多线程</strong></p>
<ul>
<li>流程：</li>
</ul>
<p>还是由reactor监听分发 但是handler<strong>不做业务处理只作事件的响应</strong> 分发给对应的worker线程池中的worker来处理(可以继续响应消息), worker返回结果由handler发送回客户端</p>
<ul>
<li>由于业务在线程池中处理 性能高于单线程 但是多线程的数据处理很麻烦 而且reactor是在单线程情况下 还是会有性能瓶颈的</li>
</ul>
<blockquote>
<p>主从reactor</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/18/fAW4twYm7JOXiHg.png" alt="主从reactor"></p>
<p><strong>主从reactor</strong></p>
<ul>
<li>我们可以让 Reactor 在多线程中运行</li>
<li>reactor的主线程监听到消息由MainReactor分发 并且只是处理连接(Accept)请求</li>
<li>其他的请求分发到子Reactor(SubReactor), SubReactor处理客户端(除连接)的请求,并且等待worker线程处理结果发回客户端</li>
<li>主线可以对应多个子线程 每个子线程可以对应多个worker线程</li>
</ul>
<p><strong>Scalable</strong> <strong>IO in</strong> <strong>Java</strong> 对 <strong>Multiple</strong> <strong>Reactors</strong> 的原理图解：</p>
<p><img src="https://i.loli.net/2020/10/18/D6uZxUe9aM2lAH3.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p><strong>主从reactor的优点</strong></p>
<ol>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
</ol>
<h2 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h2><p>上面说了主从reactor Netty是一个主从多线程模型的支持</p>
<h3 id="netty模型简单介绍"><a href="#netty模型简单介绍" class="headerlink" title="netty模型简单介绍"></a>netty模型简单介绍</h3><p>和reactor的主从模型很像 在此基础上实现了多个”Reactor”</p>
<p><img src="https://i.loli.net/2020/10/18/Zxitv1FETIgbhQA.png" alt="netty"></p>
<p><strong>netty</strong></p>
<p><img src="https://i.loli.net/2020/10/18/oHSMmUwI83rt6lp.png" alt="netty模型"></p>
<p><strong>netty模型</strong></p>
<h3 id="netty详细模型"><a href="#netty详细模型" class="headerlink" title="netty详细模型"></a>netty详细模型</h3><p><img src="https://i.loli.net/2021/01/23/xFJ7CIuD2P1defG.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h3 id="客户端-服务端实现（Netty的TCP实现）"><a href="#客户端-服务端实现（Netty的TCP实现）" class="headerlink" title="客户端-服务端实现（Netty的TCP实现）"></a>客户端-服务端实现（Netty的TCP实现）</h3><p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SunJusong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年 11月08日 21:24:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * step:</span></span><br><span class="line"><span class="comment">         *      1. 创建一个线程组：接收客户端连接</span></span><br><span class="line"><span class="comment">         *      2. 创建一个线程组：处理网络操作</span></span><br><span class="line"><span class="comment">         *      3. 创建服务端启动助手，配置参数</span></span><br><span class="line"><span class="comment">         *          1. 设置两个线程组</span></span><br><span class="line"><span class="comment">         *          2. 使用NioServerSocketChannel作为服务器端通道的实现</span></span><br><span class="line"><span class="comment">         *          3. 设置线程队列中等待的连接个数</span></span><br><span class="line"><span class="comment">         *          4. 保持活动连接状态</span></span><br><span class="line"><span class="comment">         *          5. 向PipleLine中添加handler</span></span><br><span class="line"><span class="comment">         *     4. 绑定端口bind</span></span><br><span class="line"><span class="comment">         *     5. 记得关闭连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap.group(bossGroup, workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;server is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义handler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SunJusong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年 11月22日 18:44:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server:&quot;</span> + ctx);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发来的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端发送&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;服务端发：hello client(&gt;^ω^&lt;)喵123123&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  step:</span></span><br><span class="line"><span class="comment">         *      1. 创建线程组</span></span><br><span class="line"><span class="comment">         *      2. 创建客户端启动助手，以及配置</span></span><br><span class="line"><span class="comment">         *          1. 设置线程组</span></span><br><span class="line"><span class="comment">         *          2. 设置客户端通道实现类</span></span><br><span class="line"><span class="comment">         *          3. 创建通道初始化</span></span><br><span class="line"><span class="comment">         *          4. 网Pipeline中加入handler</span></span><br><span class="line"><span class="comment">         *      3. 启动客户端</span></span><br><span class="line"><span class="comment">         *      4. 关闭</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;init kehu&quot;</span>);</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;client is ready&quot;</span>);</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">        sync.channel().closeFuture().sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello  clientHandler&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接收到的是：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务队列-TaskQueue"><a href="#任务队列-TaskQueue" class="headerlink" title="任务队列 - TaskQueue"></a>任务队列 - TaskQueue</h3><p>当很耗时的任务在PipeLine中可以将这个任务异步到处理队列（TaskQueue）</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>用户程序自定义普通任务</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>().run);</span><br></pre></td></tr></table></figure>

<ol>
<li>用户自定义定时任务 - ScheduleTaskQueue</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(() -&gt; &#123;&#125;, <span class="number">5</span>, TimeUnit.HOURS);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>非当前Reaactor线程调用Channel的方法</p>
<p>推送系统：根据客户的标识，找到Channel引用，调用Write类方法向用户推送消息，就会进入到这种场景里面，Write会提交到任务队列中被异步消费。</p>
</li>
</ol>
<blockquote>
<p>对上述方案说明</p>
<ol>
<li>Netty抽象出两组<strong>线程池</strong>， BossGroup站门负责接收客户端的连接，WorkGroup负责网络的读写。</li>
<li>NioEventLoop表示一个不断循环执行处理任务的线程，每个NioEventLoop有一个select，用于监听绑定在socket上的网联络通道。</li>
<li>NioEventLoop采用串行设计。(读取-&gt;解码-&gt;编码-&gt;发送)。</li>
</ol>
<ul>
<li>NioEventLoopGroup下有多个NioEventLoop</li>
<li>每个NioEventLoop中包含一个Select，一个NioChannel</li>
<li>每个NioChannel只会绑定在唯一的NioEventLoop上，并且都有自己的一个ChannelPipeline</li>
</ul>
</blockquote>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><ul>
<li>Listen_result(不需要等待)，Bind，Write，Connect都是异步监听操作。返回一个ChannelFuture用来监听</li>
<li>调用时不会立即有结果，通过Future-Listener机制，用户可以主动获取。</li>
<li>Netty的异步模型在future（Future-Listener机制体现）和callback（回调）之上。</li>
</ul>
<p>&#x3D;&#x3D;链式模型&#x3D;&#x3D;</p>
<p><img src="https://i.loli.net/2021/01/24/tvCHJ6eaBhD285M.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>&#x3D;&#x3D;Future-Listener机制&#x3D;&#x3D;</p>
<ol>
<li>当Future对象创建时，处于非完成状态，返回一个ChannelFuture获取操作的状态，注册监听函数来执行完成后的操作。</li>
<li><ul>
<li>isDone &#x2F; isSuccess &#x2F; getCause &#x2F; ……操作</li>
</ul>
</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链接的状态</span></span><br><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">           System.out.println(newDate() + <span class="string">&quot;: 端口[&quot;</span>+ port + <span class="string">&quot;]绑定成功!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           System.err.println(<span class="string">&quot;端口[&quot;</span>+ port + <span class="string">&quot;]绑定失败!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Http-服务"><a href="#Http-服务" class="headerlink" title="Http 服务"></a>Http 服务</h2><p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 事件循环组，就是死循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//仅仅接受连接，转给workerGroup，自己不做处理</span></span><br><span class="line">        EventLoopGroup bossGroup=<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">//真正处理</span></span><br><span class="line">        EventLoopGroup workerGroup=<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//很轻松的启动服务端代码</span></span><br><span class="line">            ServerBootstrap serverBootstrap=<span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//childHandler子处理器,传入一个初始化器参数TestServerInitializer（这里是自定义）</span></span><br><span class="line">            <span class="comment">//TestServerInitializer在channel被注册时，就会创建调用</span></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).</span><br><span class="line">                    childHandler(<span class="keyword">new</span> <span class="title class_">TestServerInitializer</span>());</span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成一个ChannelFuture对象</span></span><br><span class="line">            ChannelFuture channelFuture=serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭的监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//循环组优雅关闭</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">//这是一个回调的方法，在channel被注册时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//一个管道，里面有很多ChannelHandler，这些就像拦截器，可以做很多事</span></span><br><span class="line">        ChannelPipeline pipeline=ch.pipeline();</span><br><span class="line">        <span class="comment">//增加一个处理器，neety提供的.名字默认会给，但还是自己写一个比较好</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意这些new的对象都是多例的，每次new出来新的对象,因为每个连接的都是不同的用户</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//HttpServerCodec完成http编解码，可查源码</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;httpServerCodec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        <span class="comment">//增加一个自己定义的处理器hander</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;testHttpServerHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">TestHttpServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承InboundHandler类，代表处理进入的请求，还有OutboundHandler,处理出去请求</span></span><br><span class="line"><span class="comment"> * 其中里面的泛型表示msg的类型，如果指定了HttpObject，表明相互通讯的数据被封装成HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 通过这个可以看到在服务器 每一个客户端对应一个 独立的handler</span></span><br><span class="line">    <span class="comment">//channelRead0读取客户端请求，并返回响应的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//如果不加这个判断使用curl 测试会报错，使用curl测试命令curl &quot;http://localhost:8899&quot;</span></span><br><span class="line">        <span class="comment">//判断这个是不是httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            System.out.println(msg.getClass());</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">            HttpRequest httpRequest= (HttpRequest) msg;</span><br><span class="line">            URI uri=<span class="keyword">new</span> <span class="title class_">URI</span>(httpRequest.uri());</span><br><span class="line">            <span class="comment">//判断url是否请求了favicon.ico, 可以不对此请求响应</span></span><br><span class="line"><span class="comment">//            if (&quot;/favicon.ico&quot;.equals(uri.getPath()))&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;请求了favicon.ico&quot;);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 上面这段代码是验证如果用浏览器访问</span></span><br><span class="line"><span class="comment">             * chrome浏览器发起了两次请求，一次是发起的端口，第二次是请求/favicon.ico图标</span></span><br><span class="line"><span class="comment">             * 具体可以查看360 浏览器的请求</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请求方法名:&quot;</span>+httpRequest.method().name());</span><br><span class="line">            <span class="comment">//ByteBuf,neety中极为重要的概念，代表响应返回的数据</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">content</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;Hello! 我是服务器&quot;</span> + (++count), CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http响应,HttpVersion.HTTP_1_1:采用http1.1协议，HttpResponseStatus.OK：状态码200</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            <span class="comment">//如果只是调用write方法，他仅仅是存在缓冲区里，并不会返回客户端</span></span><br><span class="line">            <span class="comment">//调用writeAndFlush可以</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理顺序如下：</span></span><br><span class="line"><span class="comment">     * handlerAdded</span></span><br><span class="line"><span class="comment">     * channelRegistered</span></span><br><span class="line"><span class="comment">     * channelActive</span></span><br><span class="line"><span class="comment">     * 请求方法名:GET（channelRead0）</span></span><br><span class="line"><span class="comment">     * （下面的表示的是断开连接后）</span></span><br><span class="line"><span class="comment">     * 1.如果是使用curl ：连接会立刻关闭</span></span><br><span class="line"><span class="comment">     * 2.如果是浏览器访问，http1.0：它是短连接，会立刻关闭。http1.1，是长连接，连接保持一段时间</span></span><br><span class="line"><span class="comment">     * channelInactive</span></span><br><span class="line"><span class="comment">     * channelUnregistered</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于HTTP协议的无状态</p>
<p>所以刷新会重置handler和对应的Pipeline</p>
<p><img src="https://i.loli.net/2021/01/24/Sc5uvKQETCkshtp.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>不知道为什么谷歌浏览器访问不到 todo</p>
<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RCP(Remote Procedure Call) 远程调用过程</p>
<p>远程调用过程? ()这玩应就跟把Socket翻译成套接字一样 说个锤子)</p>
<p>那有远程调用就有本地调用 – 本地就是在自己的服务里进行交互; 那很显然远调就是 自己的服务与别的服务进行交互</p>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200824230828180.png" alt="通信过程"></p>
<p><strong>通信过程</strong></p>
<p><img src="https://i.loli.net/2020/08/24/anKBl9hW1dHz8Ls.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h3 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h3><ol>
<li>普通架构计, 做一个加法计算 主函数调用 计算的add方法</li>
<li>分布式呢就是把计算的服务单独拿出来了 但是怎么获取到计算服务的方法呢?</li>
</ol>
<p>可以在计算服务加一个接口? 但是不能每一次都发起http请求呀</p>
<p>如何让使用者感受不到远程调用呢?</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference</span></span><br><span class="line"><span class="keyword">private</span> 计算 name;</span><br></pre></td></tr></table></figure>

<p>使用<strong>代理模式</strong>和Spring的<strong>IOC</strong>一起, 注入需要的对象</p>
<ul>
<li><strong>核心模块</strong> 通讯 和 序列化</li>
<li><strong>解决分布式系统中，服务之间的调用问题。</strong></li>
<li><strong>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</strong></li>
</ul>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-roadmap.jpg" alt="dubbo流程"></p>
<p><strong>dubbo流程</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/2accc2840a1b">如何给老婆解释什么是RPC</a></p>
<p><a href="https://www.cnblogs.com/haimishasha/p/10756448.html#autoid-0-0-0">NIO通信模型案例</a></p>
<p><strong>Scalable</strong> <strong>IO in</strong> <strong>Java</strong> (一本书)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学</title>
    <url>/2021/07/25/JavaBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="计算机科学-随便记"><a href="#计算机科学-随便记" class="headerlink" title="计算机科学(随便记)"></a>计算机科学(随便记)</h1><blockquote>
<p>了解点计算机科学以及历史 记录一下</p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ol>
<li>计算机最早的机电设备 一般以十进制 齿轮计数 到 晶体管</li>
<li>后来以 开、关两种状态 出现二进制</li>
<li>有电流为1(true) 没有电流为0(false) 基本的数字电路嘛(逻辑代数部分)</li>
<li>布尔代数就是逻辑代数中的<strong>与或非</strong>运算 可以被晶体管很容易实现</li>
</ol>
<p><img src="https://i.loli.net/2020/12/29/BqIVYFEwKXALxRr.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li><a href="https://zhidao.baidu.com/question/535926678.html">真值表</a> 或者 <a href="https://blog.csdn.net/qq_39497488/article/details/81367998">这里</a> 二进制实现更加支持</li>
</ol>
<h2 id="到硬件部分了"><a href="#到硬件部分了" class="headerlink" title="到硬件部分了"></a>到硬件部分了</h2><h3 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h3><p>计算机中所有操作都需要这部分</p>
<p><img src="https://i.loli.net/2020/12/29/HefU4sAk2JxGqMP.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>加法器就是 2个半加器 组成全加器 多个全加器进行计算 预留进位(可以判断是否溢出)</p>
<ul>
<li>电脑会有专门做乘除法的计算单元</li>
</ul>
<h3 id="寄存器，锁存器-内存"><a href="#寄存器，锁存器-内存" class="headerlink" title="寄存器，锁存器,内存"></a>寄存器，锁存器,内存</h3><p>锁存器： 锁存器是电平触发的存储单元</p>
<p><img src="https://i.loli.net/2020/12/29/T7XCbPIszY3OZaD.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>另一种锁存器：</p>
<p><img src="https://i.loli.net/2020/12/29/xOZqhBUJfvWRbAi.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>这些能存储一位的数据，经他们组合起来 叫寄存器 通常为8、16….位的</p>
<p>寄存器：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果</p>
<p><img src="https://i.loli.net/2020/12/29/ar7AxNC1RngjXYF.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>多路复用：矩阵</p>
<p><img src="https://i.loli.net/2020/12/29/glhBtuJHLODmrwb.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>多个组成内存</p>
<p><img src="https://i.loli.net/2020/12/29/g53NeW9VioFHpIv.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>再有多个独立内存空间组合成现在使用的内存（RAM）</p>
<p>从基本的电路到一层一层抽象到内存芯片 其中的内容还是蛮多的 ，这里只是介绍一下， 如果想进一步学习，可以去学习 数电模电、和电路(毕竟这个专业对口了&#x3D;。&#x3D;)</p>
<p><img src="https://i.loli.net/2020/12/29/uc1vMINgkQTPAYs.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>内存 算数逻辑单元 都有了</p>
<p>我们拼一个cpu(中央处理器)出来</p>
<p><img src="https://i.loli.net/2020/12/29/KUpJEDlvFZirTgM.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>根据指令（匹配到对应的操作码） 执行对应操作 到寄存器</p>
<p>取指令 - 解码 - 执行</p>
<p>alu 计算 时钟信号进行控制cpu频率</p>
<p>简化的cpu就设计完成了 – 取指令 - 解码 - 执行 时钟 计算</p>
<p><img src="https://i.loli.net/2020/12/29/32TlJe15jKuQhzV.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ul>
<li>&#x3D;&#x3D;<strong>集成电路&amp;摩尔定律</strong>&#x3D;&#x3D;</li>
</ul>
<p><a href="https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B/350634?fr=aladdin">摩尔定律</a></p>
<p>光刻技术：</p>
<p>硅为原材料</p>
<p><img src="https://i.loli.net/2020/12/29/AXNVQ2BE6InSswU.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h2 id="指令，程序"><a href="#指令，程序" class="headerlink" title="指令，程序"></a>指令，程序</h2><p>CPU之所以强大是因为是可编程的</p>
<p>所以将二进制指令改为英文指令写入内存</p>
<p><img src="https://i.loli.net/2020/12/29/LekVIqMFlKiHb9o.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>cpu处理指令长度和一些方式：指令长度， 可变指令长度，立即值(立即数)当然只介绍 - 好奇的话可以去了解<a href="https://blog.csdn.net/qq_36982160/article/details/82950848">汇编语言基本指令</a></p>
<h2 id="真正的CPU"><a href="#真正的CPU" class="headerlink" title="真正的CPU"></a>真正的CPU</h2><p>在真正的cpu中相比于上面简单的来说，需要处理的问题要大得多，所以现在cpu会处理的：</p>
<ol>
<li>首先超高的时钟 让ram的传输速率跟不上 于是在cpu加上了缓存 一批一批的读取数据</li>
<li>缓存会有一些处理方式： 缓存命中&#x2F; 未命中</li>
<li>脏位： 数据与缓存不一致， 被修改过</li>
<li>程序执行会在流水线中执行 – 流水线满了会执行分支预测(90%以上的正确率)</li>
<li>ALU不让他们闲置</li>
<li>取址 – 解码 – 执行并行处理</li>
</ol>
<p>性能可以通过多核、多个cpu来实现</p>
<p>中国神威·太湖有40960个cpu，每个256核 现存<strong>最快的</strong>超级计算机</p>
<p><img src="https://i.loli.net/2020/12/29/TSsKji8UNHPOe6E.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>从插线 – 卡纸 – 面板编程（很多开关） – 汇编等</p>
<ul>
<li>二进制写程序： 纸伪代码，手工转二进</li>
<li>葛丽丝．霍晋(GraceHopper)-哈佛1号计算机首批程序员，海军军官</li>
<li>Grace设计了编程语言A-O</li>
<li>IBM编程语言：FORTRAN</li>
<li>第一个可移植的：COBOL （真名实姓提到过）</li>
<li>新语言： c，C++ ， obj-C， python。。。。java</li>
</ul>
<p>有了语言 软件或者编译器将器转换为计算机认识的语言</p>
<p>再有一些数据结构 就是现代编程了 不需要过多考虑 计算机的硬件实现</p>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li>图片</li>
<li>P9，20，21</li>
<li>24，25</li>
</ul>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2021/07/25/net/epoll/</url>
    <content><![CDATA[<h1 id="epoll为什么性能好"><a href="#epoll为什么性能好" class="headerlink" title="epoll为什么性能好"></a>epoll为什么性能好</h1><blockquote>
<p>对 select&#x2F;poll&#x2F;epoll 一个记录吧，一些自己的理解</p>
</blockquote>
<p>服务端开发嘛，所以很重要的是网络编程，epoll作为linux下的高性能网络服务所以了解一下也蛮重要的。比如epoll和select的区别是什么？epoll高效率的原因是什么？</p>
<h2 id="如何处理网络信息"><a href="#如何处理网络信息" class="headerlink" title="如何处理网络信息"></a>如何处理网络信息</h2><ul>
<li>一台机器接收到了一条消息后，硬件的传输后，写入到内存。这个写入内存的操作是一个优先级较高的中断程序。当很多很多的消息从客户端传来，怎么处理？</li>
<li>计算机如何知道网络数据对应哪个(socket)连接？如何同时监控这些数据。</li>
</ul>
<p>&#x3D;.&#x3D;</p>
<ul>
<li>首先第一个：建立多个连接，每个连接一个线程（如果是一个多线程的程序，一个用户一个线程，上下文切换会消耗很多性能，如果单线程下如何处理大量的网络消息呢？）</li>
<li>第二个：<ul>
<li><strong>如何识别哪个连接：</strong> ip和端口号在操作系统的socket的索引。</li>
<li><strong>同时监控呢？</strong> 多路复用是重点</li>
</ul>
</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>先写一个程序来在用户态实现这个功能：</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先在一个的循环程序下，遍历这个所有的连接，有数据进行处理。</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(fdx in <span class="title function_">fd</span><span class="params">(<span class="number">1</span>)</span>~fd(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd 有数据)&#123;</span><br><span class="line">            处理。。。</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// todo ----</span></span><br></pre></td></tr></table></figure>

<p>网络数据不应该在用户态进行监控，所以基于内核的select技术出现了，源码：</p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_select</span><span class="params">(<span class="type">int</span> n, fd_set_bits *fds, s64 *timeout)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">poll_wqueues</span> table;    </span><br><span class="line"> poll_table *wait;    </span><br><span class="line"> <span class="type">int</span> retval, i;    </span><br><span class="line"></span><br><span class="line"> <span class="built_in">rcu_read_lock</span>();    </span><br><span class="line"> <span class="comment">/*根据已经打开fd的位图检查用户打开的fd, 要求对应fd必须打开, 并且返回最大的fd*/</span>   </span><br><span class="line"> retval = <span class="built_in">max_select_fd</span>(n, fds);    </span><br><span class="line"> <span class="built_in">rcu_read_unlock</span>();    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)    </span><br><span class="line">  <span class="keyword">return</span> retval;    </span><br><span class="line"> n = retval;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*将当前进程放入自已的等待队列table, 并将该等待队列加入到该测试表wait*/</span>   </span><br><span class="line"> <span class="built_in">poll_initwait</span>(&amp;table);    </span><br><span class="line"> wait = &amp;table.pt;    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!*timeout)    </span><br><span class="line">  wait = <span class="literal">NULL</span>;    </span><br><span class="line"> retval = <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;<span class="comment">/*死循环*/</span>   </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *exp;    </span><br><span class="line">  <span class="type">long</span> __timeout;    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*注意:可中断的睡眠状态*/</span>   </span><br><span class="line">  <span class="built_in">set_current_state</span>(TASK_INTERRUPTIBLE);    </span><br><span class="line"></span><br><span class="line">  inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;    </span><br><span class="line">  rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;<span class="comment">/*遍历所有fd*/</span>   </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;    </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;    </span><br><span class="line">   <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> *f_op = <span class="literal">NULL</span>;    </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">file</span> *file = <span class="literal">NULL</span>;    </span><br><span class="line"></span><br><span class="line">   in = *inp++; out = *outp++; ex = *exp++;    </span><br><span class="line">   all_bits = in | out | ex;    </span><br><span class="line">   <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="comment">/*   </span></span><br><span class="line"><span class="comment">    __NFDBITS定义为(8 * sizeof(unsigned long)),即long的位数。   </span></span><br><span class="line"><span class="comment">    因为一个long代表了__NFDBITS位，所以跳到下一个位图i要增加__NFDBITS   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    i += __NFDBITS;    </span><br><span class="line">    <span class="keyword">continue</span>;    </span><br><span class="line">   &#125;    </span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;    </span><br><span class="line">    <span class="type">int</span> fput_needed;    </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= n)    </span><br><span class="line">     <span class="keyword">break</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试每一位*/</span>   </span><br><span class="line">    <span class="keyword">if</span> (!(bit &amp; all_bits))    </span><br><span class="line">     <span class="keyword">continue</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*得到file结构指针，并增加引用计数字段f_count*/</span>   </span><br><span class="line">    file = <span class="built_in">fget_light</span>(i, &amp;fput_needed);    </span><br><span class="line">    <span class="keyword">if</span> (file) &#123;    </span><br><span class="line">     f_op = file-&gt;f_op;    </span><br><span class="line">     mask = DEFAULT_POLLMASK;    </span><br><span class="line"></span><br><span class="line">     <span class="comment">/*对于socket描述符,f_op-&gt;poll对应的函数是sock_poll   </span></span><br><span class="line"><span class="comment">     注意第三个参数是等待队列，在poll成功后会将本进程唤醒执行*/</span>   </span><br><span class="line">     <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)    </span><br><span class="line">      mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);    </span><br><span class="line"></span><br><span class="line">     <span class="comment">/*释放file结构指针，实际就是减小他的一个引用计数字段f_count*/</span>   </span><br><span class="line">     <span class="built_in">fput_light</span>(file, fput_needed);    </span><br><span class="line"></span><br><span class="line">     <span class="comment">/*根据poll的结果设置状态,要返回select出来的fd数目，所以retval++。   </span></span><br><span class="line"><span class="comment">     注意：retval是in out ex三个集合的总和*/</span>   </span><br><span class="line">     <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;    </span><br><span class="line">      res_in |= bit;    </span><br><span class="line">      retval++;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;    </span><br><span class="line">      res_out |= bit;    </span><br><span class="line">      retval++;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;    </span><br><span class="line">      res_ex |= bit;    </span><br><span class="line">      retval++;    </span><br><span class="line">     &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*   </span></span><br><span class="line"><span class="comment">    注意前面的set_current_state(TASK_INTERRUPTIBLE);   </span></span><br><span class="line"><span class="comment">    因为已经进入TASK_INTERRUPTIBLE状态,所以cond_resched回调度其他进程来运行，   </span></span><br><span class="line"><span class="comment">    这里的目的纯粹是为了增加一个抢占点。被抢占后，由等待队列机制唤醒。   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在支持抢占式调度的内核中（定义了CONFIG_PREEMPT），cond_resched是空操作   </span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="built_in">cond_resched</span>();    </span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="comment">/*根据poll的结果写回到输出位图里*/</span>   </span><br><span class="line">   <span class="keyword">if</span> (res_in)    </span><br><span class="line">    *rinp = res_in;    </span><br><span class="line">   <span class="keyword">if</span> (res_out)    </span><br><span class="line">    *routp = res_out;    </span><br><span class="line">   <span class="keyword">if</span> (res_ex)    </span><br><span class="line">    *rexp = res_ex;    </span><br><span class="line">  &#125;    </span><br><span class="line">  wait = <span class="literal">NULL</span>;    </span><br><span class="line">  <span class="keyword">if</span> (retval || !*timeout || <span class="built_in">signal_pending</span>(current))<span class="comment">/*signal_pending前面说过了*/</span>   </span><br><span class="line">   <span class="keyword">break</span>;    </span><br><span class="line">  <span class="keyword">if</span>(table.error) &#123;    </span><br><span class="line">   retval = table.error;    </span><br><span class="line">   <span class="keyword">break</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">   <span class="comment">/*无限等待*/</span>   </span><br><span class="line">   __timeout = MAX_SCHEDULE_TIMEOUT;    </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;    </span><br><span class="line">   <span class="comment">/* 时间超过MAX_SCHEDULE_TIMEOUT,即schedule_timeout允许的最大值，用一个循环来不断减少超时值*/</span>   </span><br><span class="line">   __timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;    </span><br><span class="line">   *timeout -= __timeout;    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">   <span class="comment">/*等待一段时间*/</span>   </span><br><span class="line">   __timeout = *timeout;    </span><br><span class="line">   *timeout = <span class="number">0</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*TASK_INTERRUPTIBLE状态下，调用schedule_timeout的进程会在收到信号后重新得到调度的机会，   </span></span><br><span class="line"><span class="comment">  即schedule_timeout返回,并返回剩余的时钟周期数   </span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line">  __timeout = <span class="built_in">schedule_timeout</span>(__timeout);    </span><br><span class="line">  <span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)    </span><br><span class="line">   *timeout += __timeout;    </span><br><span class="line"> &#125;    </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*设置为运行状态*/</span>   </span><br><span class="line"> __set_current_state(TASK_RUNNING);    </span><br><span class="line"> <span class="comment">/*清理等待队列*/</span>   </span><br><span class="line"> <span class="built_in">poll_freewait</span>(&amp;table);    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> retval;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>一个实例：</p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建连接的描述符 fd[x]</span></span><br><span class="line"><span class="comment">// max 表示集合中最大的数字</span></span><br><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">20</span>OO);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"><span class="built_in">bind</span>(sockfd，(<span class="keyword">struct</span> sockaddr *) &amp; addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="built_in">listen</span>(sockfd，S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client，<span class="number">0</span>，<span class="built_in">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="built_in">Sizeof</span>(client);</span><br><span class="line">    <span class="comment">// 创建了五个连接</span></span><br><span class="line">    fds[i] = <span class="built_in">accept</span>(sockfd，(<span class="keyword">struct</span> sockaddr *) &amp; client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (fdsp[i] &gt; max)</span><br><span class="line">        max = fds[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while 来处理网络消息  执行</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set 是一个bitMap 半段哪些会被监听</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            bitMap有1024位</span></span><br><span class="line"><span class="comment">            如果：1，2，5，6，7（fd中数据） </span></span><br><span class="line"><span class="comment">            所以：就是 0 1 1 0 0 1 1 1 0 0。。。。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FD_SET</span>(fds[i], &amp;set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">    <span class="comment">/*  1. max+1</span></span><br><span class="line"><span class="comment">        2. 读文件描述符集合</span></span><br><span class="line"><span class="comment">        3. 写文件描述符集合</span></span><br><span class="line"><span class="comment">        4. 异常集合</span></span><br><span class="line"><span class="comment">        5. 超时时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">select</span>(max + l, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// 要对每一个有数据的描述符(fd)进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fds[i]，&amp;rset))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">                <span class="built_in">read</span>(fds[i], buffer, MAXBUF);</span><br><span class="line">                <span class="built_in">puts</span>(buffer);<span class="comment">// 处理函数</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用户创建 出rset 给内核来监听 判断到数据发送回用户态对应到fd[x]</li>
<li>select函数如果没有数据会一致阻塞</li>
<li>rset置位，select执行结束。用户可以根据rset的变化来判断哪个收到了数据，并且处理</li>
</ol>
<ul>
<li>图中列出了缺点</li>
</ul>
<p><img src="https://i.loli.net/2021/01/17/HkrL4MjAeB3sSuq.png" alt="select"></p>
<p><strong>select</strong></p>
<h2 id="poll-x2F-epoll"><a href="#poll-x2F-epoll" class="headerlink" title="poll&#x2F;epoll"></a>poll&#x2F;epoll</h2><p>用例：</p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体的改变</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    fd</span></span><br><span class="line"><span class="comment">    events: 在意的事件 （POLLIN， POLLOUT）</span></span><br><span class="line"><span class="comment">    revents: 对事件的反馈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span>&#123; </span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">short</span> events;</span><br><span class="line"><span class="type">short</span> revents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cltent, <span class="number">0</span>, <span class="built_in">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd=<span class="built_in">accept</span>(sockfd,<span class="keyword">struct</span> sockaddr*)&amp;cltent, &amp;addrlen);</span><br><span class="line">    pollfds[i].events=POLLIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep</span>(l);</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="keyword">while</span>(l)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;roundagain&quot;</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        1. poofd:结构体</span></span><br><span class="line"><span class="comment">        2. 数量</span></span><br><span class="line"><span class="comment">        3. 超时时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">poll</span>(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(po11fds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">        <span class="comment">// 置位回去</span></span><br><span class="line">        pollfds[i]].revents = <span class="number">0</span>；</span><br><span class="line">        <span class="built_in">memset</span>(buffer，<span class="number">0</span>，MAXBUF);</span><br><span class="line">        <span class="built_in">read</span>(pollfds[i].fd, buffer, MAXBUF)；</span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>内核判断有数据 置位revent我们就知道哪个有数据了</li>
<li>置位方式所以可以重用</li>
</ol>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210117175836804.png" alt="image-20210117175836804"></p>
<p><strong>image-20210117175836804</strong></p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>将复杂度简化为O(1)</p>
<p>用例：</p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epolI_event</span> events[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建EPFD</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cltent, <span class="number">0</span>, <span class="built_in">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    ev.data.fd =<span class="built_in">accept</span>(sockfd，(<span class="keyword">struct</span> sockaddr*)&amp;client，&amp;addrlen);</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="comment">// 在结构体添加 fd - events （有五个）</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行:</span></span><br><span class="line"><span class="keyword">while</span>(l)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;roundagain&quot;</span>);</span><br><span class="line">    <span class="comment">// 具体函数</span></span><br><span class="line">    nfds = <span class="built_in">epoll_wait</span>(epfd, events,<span class="number">5</span>, <span class="number">10000</span>）;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nfds; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">        <span class="built_in">read</span>(events[i],data,fd,buffer,MAXBUF);</span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>epfd 是一个公用的 所以不用拷贝了</li>
<li>置位方式：重排序（将有数据的fd放到最前） 所以不需要单独的结构来处理置位</li>
<li>复杂度降低O(1) 不需要遍历所有的fd 因为返回的 只是接收的数据（nfds）</li>
</ol>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210117175854638.png" alt="image-20210117175854638"></p>
<p><strong>image-20210117175854638</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210117175913944.png" alt="image-20210117175913944"></p>
<p><strong>image-20210117175913944</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/63179839">https://zhuanlan.zhihu.com/p/63179839</a></p>
<p><a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=12266065751194287806">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=12266065751194287806</a></p>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><p>epoll 没有深入</p>
<p>代码实现</p>
<p>底层</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>华为gt2</title>
    <url>/2021/05/07/other/%E5%8D%8E%E4%B8%BAgt2/</url>
    <content><![CDATA[<p><a href="https://cn.club.vmall.com/thread-25848096-1-1.html">https://cn.club.vmall.com/thread-25848096-1-1.html</a></p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的AOP和IOC</title>
    <url>/2020/05/27/JavaBase/Spring%E7%9A%84AOP%E5%92%8CIOC/</url>
    <content><![CDATA[<h1 id="Spring的IOC和AOP"><a href="#Spring的IOC和AOP" class="headerlink" title="Spring的IOC和AOP"></a>Spring的IOC和AOP</h1><p>[toc]</p>
<h2 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h2><blockquote>
<p>Spring框架即以<em>interface21*框架为基础,经过重新设计,并不断丰富其内涵,于*2004*年</em>3月24日*,发布了1.0正式版。作者: [Rod Johnson]([[<a href="https://baike.baidu.com/item/Rod%20Johnson/1423612?fr=aladdin%5C%5D%5D">https://baike.baidu.com/item/Rod%20Johnson/1423612?fr=aladdin\]]</a>(<a href="https://baike.baidu.com/item/Rod">https://baike.baidu.com/item/Rod</a> Johnson&#x2F;1423612?fr&#x3D;aladdin])(<a href="https://baike.baidu.com/item/Rod">https://baike.baidu.com/item/Rod</a> Johnson&#x2F;1423612?fr&#x3D;aladdin))</p>
<p>&#x3D;&#x3D;非入侵式, 轻量级框架 – 支持事务&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>Spring(容器&#x2F;代理类框架)</p>
</blockquote>
<p><img src="https://i.loli.net/2020/05/27/Pcl8ygk3zEiVHWY.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ul>
<li><p>Spring七个模块</p>
<p><img src="https://i.loli.net/2020/06/28/jWdqFXVefgiDCH4.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</li>
</ul>
<h2 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC(控制反转)"></a>IOC(控制反转)</h2><p>IOC – Inversion of Control</p>
<blockquote>
<p>DI：依赖注入：实现方式</p>
<p>IOC：控制反转:&#x3D;&#x3D;<strong>是一种设计思想</strong>&#x3D;&#x3D;</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>作用: 借助于“第三方”实现具有依赖关系的对象之间的解耦</p>
</li>
<li><p>理念: 应用组件<strong>不应该负责查找资源或者其他的对象之间的依赖关系</strong>, 配置这个关系的由容器负责, 查找资源从应用组件的代码中抽取出来(set); 交给容器</p>
</li>
<li></li>
<li><p>IOC控制:</p>
<ul>
<li><p><strong>谁控制谁</strong>: ioc容器控制了对象</p>
</li>
<li><p>控制什么</p>
<p>: 主要控制了外部资源的获取,创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对象由Spring创建、管理、装配</span><br><span class="line">   2.  控制的内容：控制对象的创建：传统的由程序本身去创建, 框架由Spring来创建和管理</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>IOC反转</strong>：(正转：程序自己创建对象)</p>
<ul>
<li><strong>反转:</strong> 由容器帮我们查找和注入了依赖对象, 对象只是被动地接受</li>
<li><strong>反转了啥:</strong> 把依赖对象的获取方式反转了</li>
</ul>
<ol>
<li>对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转” 官方一点就是原来对象间的关系由程序猿的部分控制; 现在由容器框架来创建和管理</li>
</ol>
</li>
</ol>
<ul>
<li><p>用一个简单例子理解一下为什么有IOC</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在正常开发中 把传递的对象用set来实现动态化 大大降低了耦合度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="comment">// 原先是 DAO层来创建对象和依赖关系 耦合度超高 一旦需要更改 就要改源码</span></span><br><span class="line">    <span class="comment">// MyDataBase dao = new DataBase();</span></span><br><span class="line">    MyDataBase dao;</span><br><span class="line">    <span class="comment">// 把需要的对象用来传递后 就是服务端传递对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(MyDataBase dao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过&quot;</span> + dao.thisName() + <span class="string">&quot;获取到了名字&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IOC实现"><a href="#IOC实现" class="headerlink" title="IOC实现"></a>IOC实现</h3><p>maven导入:</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/06/29/d6ZkSsux2f8Dwgv.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li>传统的设计模式 由程序本身new出对象,主动去创建依赖,耦合度很高</li>
<li>当有了IOC容器后,在客户端类中不再主动去创建这些对象了</li>
</ol>
<p><img src="https://i.loli.net/2020/06/29/9YnpjRGZdbw1DoL.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li>pojo类</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hello;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一定要有set方法 Spring通过set来获取对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.hello = hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;hello=&#x27;&quot;</span> + hello + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>配置文件</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在加载配置文件时 对象就已经new出</span></span><br><span class="line"><span class="comment">        容器创建了对象</span></span><br><span class="line"><span class="comment">        id 就像对象名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello Spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端加载配置文件 获取需要的Bean即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ApplicationContext.xml&quot;</span>);<span class="comment">// 可以加载多个XML文件</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Spring中对象由容器创建, 管理, 装配</strong></p>
</li>
</ol>
<h3 id="Spring的BeanFactory实现生成Bean"><a href="#Spring的BeanFactory实现生成Bean" class="headerlink" title="Spring的BeanFactory实现生成Bean"></a>Spring的BeanFactory实现生成Bean</h3><ul>
<li>Spring是一个大的Bean工厂, 负责Bean的创建和注入</li>
<li>Bean创建流程</li>
</ul>
<p><img src="https://i.loli.net/2020/07/05/G78ImnKQaSyFwVj.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<ol>
<li><p>ResourceLoader<strong>加载配置文件</strong></p>
</li>
<li><p><strong>BeanDefinitionReader解析配置文件</strong>– 将 <strong>解析为BeanDefinition对象</strong>, 并保存到BeanDefinitionRegistry</p>
</li>
<li><p>利用后处理器BeanFactoryPostProcessor</p>
<p>对BeanDefinition加工处理</p>
<ul>
<li>使用标签进行解析.<strong>将占位符替换为真实值</strong></li>
<li>对所有的BeanDefinition扫描,<strong>用反射机制找出所有的属性编辑器的Bean</strong>,注册到PropertyEditorRegistry</li>
</ul>
</li>
<li><p>从BeanDefinitionRegistry中取出BeanDefinition, 调用InstantiationStrategy<strong>进行实例化</strong></p>
</li>
<li><p>实例化时, 利用BeanWrapper对Bean设置属性</p>
</li>
<li><p>利用后处理器BeanFactoryPostProcessor<strong>对完成的Bean进行加工</strong></p>
</li>
</ol>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><blockquote>
<p>ioc启动先产生一个BeanDedinition 后 有可能会触发实例化</p>
<p>如果是原型模式在getBean时会实例化</p>
<p>单例模式在初始化实例后回到容器中寻找</p>
</blockquote>
<ol>
<li><strong>实例化bean对象</strong></li>
<li><strong>设置属性(DI注入)</strong></li>
<li><strong>调用Bean的初始化方法</strong></li>
<li><strong>使用Bean</strong></li>
<li><strong>容器关闭前销毁Bean</strong></li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bean的销毁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student这个Bean：销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 配置:</span></span><br><span class="line">destroy-method：指定销毁的方法 </span><br></pre></td></tr></table></figure>

<h3 id="BeanFactory与ApplicationContext是干什么的-区别"><a href="#BeanFactory与ApplicationContext是干什么的-区别" class="headerlink" title="BeanFactory与ApplicationContext是干什么的,区别?"></a>BeanFactory与ApplicationContext是干什么的,区别?</h3><table>
<thead>
<tr>
<th align="left">BeanFactory</th>
<th align="left">ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left">都是容器</td>
<td align="left">都是容器</td>
</tr>
<tr>
<td align="left">顶层-基础接口,实现了基础功能</td>
<td align="left">容器的高级形态,增加了特性,顶级父类是BeanFactory</td>
</tr>
</tbody></table>
<p>FactoryBean是一个Bean,用于生产修饰其他的Bean实例,典型的是AOP代理类</p>
<h3 id="Spring的IOC创建对象的方式"><a href="#Spring的IOC创建对象的方式" class="headerlink" title="Spring的IOC创建对象的方式"></a>Spring的IOC创建对象的方式</h3><ol>
<li><p><strong>无参构造:</strong></p>
<ul>
<li>上慢的例子就是</li>
</ul>
</li>
<li><p><strong>有参构造(3中方式)</strong></p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过构造器参数名字获取 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello Spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过构造器参数索引--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello Spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello Spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工厂方式创建</strong></p>
<ol>
<li>静态工厂</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hello <span class="title function_">getInstance</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hello</span>(name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">配置文件</span><br><span class="line"><span class="comment">&lt;!-- 静态工厂方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.MyFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hello Factory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>动态工厂</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  Hello <span class="title function_">getInstance</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hello</span>(name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态工厂方法   与静态比少了static --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.MyFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对应工厂的对应方法创建对应的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello Dynamic Factory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI - 依赖注入"></a>DI - 依赖注入</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>前面有的就是构造器</p>
<h3 id="set注入"><a href="#set注入" class="headerlink" title="set注入"></a>set注入</h3><ul>
<li>依赖注入<ol>
<li>依赖: bean对象的<strong>创建</strong>依赖容器</li>
<li>注入: bean的所有属性由容器注入</li>
</ol>
</li>
</ul>
<blockquote>
<p>注入配置</p>
</blockquote>
<ul>
<li>所有类型</li>
</ul>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Address&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.People&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;me&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--set--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123422<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--map--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1号&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lol&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;2号&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ow&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;other&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;key&quot;</span>&gt;</span>value<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;secend&quot;</span>&gt;</span>hahah<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展方式注入"><a href="#拓展方式注入" class="headerlink" title="拓展方式注入"></a>拓展方式注入</h3><ul>
<li>c&#x2F;p命名方式注入</li>
</ul>
<ol>
<li>p标签就是和 property相同功能</li>
</ol>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>所以c标签就是和构造器参数constructor-arg相同功能配置在标签内</li>
</ol>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure>

<p>配置:</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.People&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">p:address-ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Spring核心配置头</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引入配置文件 – 将多个配置文件引入合并到一个文件中</li>
</ul>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;ApplicationContext1.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">import</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;ApplicationContext2.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">import</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;ApplicationContext3.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">import</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bean配置</li>
</ul>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id对象名字 class权限定名  name 别名配置(空格/,/;)当分隔符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2,23 12&quot;</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--别名可以用这配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;hello2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Bean作用区域"><a href="#Bean作用区域" class="headerlink" title="Bean作用区域"></a>Bean作用区域</h3><p>官方文档有六个:</p>
<table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton">singleton(单例)</a></td>
<td align="left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype">prototype(原型)</a></td>
<td align="left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request">request</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session">session</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application">application</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope">websocket</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<p>后面四个在web中才会用到</p>
<ul>
<li>单例Singleton</li>
</ul>
<p><img src="https://i.loli.net/2020/07/02/u5reoLZBkP6asGA.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原型</li>
</ul>
<p><img src="https://i.loli.net/2020/07/02/dAIstZrxTL8m1Ru.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h3><ul>
<li>byName和byType</li>
</ul>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!--写两个类: 人类拥有猫 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Cat&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;neo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    自动装配: autowire:</span></span><br><span class="line"><span class="comment">        byType: 找到对应的类</span></span><br><span class="line"><span class="comment">        byName: 找到对应的id和name</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;human&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sjs.Human&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjs&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.(官方推荐使用注解)</p>
<ul>
<li>注解开发</li>
<li>1.带入约束</li>
<li>&#x3D;&#x3D;2.只需要多加一个 <a href="context:annotation-config/">context:annotation-config/</a>&#x3D;&#x3D;</li>
</ul>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>@Autowired</p>
<p>参数(required &#x3D; “false 表示可以为null”) <em>选择性填写</em></p>
<p>先通过byName方式获取 如果没有则通过 byType (如果有两个相同的注入配置 byName会异常)</p>
<p>直接加到对应的属性或者set方法上</p>
<p>如果自动装配的属性在IOC(Spring)容器中存在, 且名字对应 就可以不写set方法(用反射机制获取对应的属性结构)</p>
</li>
<li><p>@Qualifier(value &#x3D; “参数名字”) 配置一个别名</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource(是java自带的)</p>
<p>参数可以配置名字(name&#x3D; “参数名字”)</p>
<p>先通过byName方式获取 如果没有则通过 byType</p>
</li>
</ul>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><blockquote>
<p>一定要引入aop包 和配置自动扫描</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描package下所有文件 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.sjs&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>bean</strong></p>
<ol>
<li><p>@Component注解表示注入到Spring中 相当于 <code>&lt;bean id=&quot;&quot; name=&quot;&quot;/&gt;</code></p>
</li>
<li><p>@Component的衍生注解, 在web开发中,的MVC三层架构</p>
<ul>
<li>DAO层: @Repository</li>
<li>Controller层: @Controller</li>
<li>Service层: @Service</li>
</ul>
<blockquote>
<p>注解功能相同</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>属性注入</strong></p>
</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;abc&quot;)</span></span><br><span class="line"><span class="comment">// 相当于 &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>自动装配</strong></p>
<ul>
<li><p>@Autowired</p>
<p>参数(required &#x3D; “false 表示可以为null”) <em>选择性填写</em></p>
<p>先通过byName方式获取 如果没有则通过 byType (如果有两个相同的注入配置 byName会异常)</p>
<p>直接加到对应的属性或者set方法上</p>
<p>如果自动装配的属性在IOC(Spring)容器中存在, 且名字对应 就可以不写set方法(用反射机制获取对应的属性结构)</p>
</li>
<li><p>@Qualifier(value &#x3D; “参数名字”) 配置一个别名</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource(是java自带的)</p>
<p>参数可以配置名字(name&#x3D; “参数名字”)</p>
<p>先通过byName方式获取 如果没有则通过 byType</p>
</li>
</ul>
</li>
<li><p><strong>作用域</strong></p>
</li>
</ul>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例 原型 ... </span></span><br><span class="line"><span class="meta">@Scope(&quot;Singleton&quot;)</span>/<span class="meta">@Scope(&quot;prototype&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小结</strong></li>
</ul>
<blockquote>
<p>Xml与注解:</p>
</blockquote>
<ul>
<li>xml方便维护,比较万能 适用任何场合</li>
<li>注解 针对自己的类, 维护复杂</li>
</ul>
<blockquote>
<p>实践</p>
</blockquote>
<ul>
<li>xml用来管理bean</li>
<li>注解只负责完成注入</li>
<li>在使用过程中,只要注意一个问题: 开启注解支持配置(配置文件 和 扫描包)</li>
</ul>
<h3 id="javaConfig实现配置"><a href="#javaConfig实现配置" class="headerlink" title="javaConfig实现配置"></a>javaConfig实现配置</h3><ul>
<li>由于有javaConfig配置可以实现不用配置文件, 全交给JAVA来做!</li>
<li>javaConfig是Spring的一个子项目, 在Spring4之后, 成为了一个核心功能(获取ConfigContext)</li>
</ul>
<p><img src="https://i.loli.net/2020/07/04/HPgrKlqpuFb58GQ.png" alt="ApplicationContext.png"></p>
<p><strong>ApplicationContext.png</strong></p>
<ul>
<li>测试例子</li>
</ul>
<p>配置类:可以完全替代Bean.xml</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类回由Spring容器托管 @Configuration的实现有@Component </span></span><br><span class="line"><span class="comment">// @Configuration 代表配置类 和ApplicationContext.xml相同</span></span><br><span class="line"><span class="comment">// 完全使用配置类只需要annotationConfig上下文来获取容器, 通过配置类的class对象加载!</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.sjs.POJO&quot;)</span></span><br><span class="line"><span class="comment">//@Import(OtherConfig.class)  引入其他配置文件 和 xml中的import一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SongConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 方法名为 id name 自动注入方式By_TYPE</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;getUser&quot;, autowire = Autowire.BY_TYPE)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫来啦!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PO类</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;sjs&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCat</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Cat类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;mao&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SongConfig.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">    System.out.println(user.getCat());</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<p> hahaha<br>​ 猫来啦!<br>​ Cat{name&#x3D;’mao’}<br>​ User{name&#x3D;’sjs’}</p>
</blockquote>
<h2 id="AOP代理-面向切面"><a href="#AOP代理-面向切面" class="headerlink" title="AOP代理-面向切面"></a>AOP代理-面向切面</h2><p>AOP -Aspect Oriented Programming</p>
<blockquote>
<p>了解Spring的AOP实现不得不说到 java的反射机制和 动态<a href="https://sunxinan12138.github.io/2020/05/27/Spring%E7%9A%84AOP%E5%92%8CIOC/[https://sunxinan12138.github.io/2020/05/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/](https://sunxinan12138.github.io/2020/05/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/)">代理模式</a></p>
<ul>
<li>基本概念<ol>
<li>通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术.</li>
<li>AOP是OOP的延续, 是软件开发的热点, 也是SPring框架的重要内容. 函数式编程的衍生泛型. ;利用AOP可以对业务逻辑各个部门进行隔离,是逻辑间耦合度降低, 提高重用性,提高开发效率</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p>正常编程</p>
<p><img src="https://i.loli.net/2020/05/28/rQZ36jmDFYCR5NI.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</blockquote>
<blockquote>
<p>面向切面: 在一个功能(类)中切入另一个功能</p>
<p><img src="https://i.loli.net/2020/06/26/rOYqRu3ZHSNVeMc.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
<p><img src="https://i.loli.net/2020/06/27/zMpQPvU64AdBYw8.png" alt="image.png"></p>
<p><strong>image.png</strong></p>
</blockquote>
<h3 id="Spring中AOP的作用"><a href="#Spring中AOP的作用" class="headerlink" title="Spring中AOP的作用"></a>Spring中AOP的作用</h3><blockquote>
<p>**提供声明式服务: ** 允许用户自定义切面</p>
<ul>
<li>横切关注点: 跨越应用程序多个模块的方法或功能. – 与业务逻辑无关 但是我们要关注的部分– 日志, 安全, 缓存….</li>
<li>切面(ASPECT): 横切关注点 被模块化的特殊对象 – 是一个类(Log)</li>
<li>通知(Advice): 切面必须要完成的工作, 即, 他是类中的一个方法(日志方法)</li>
<li>目标(Target): 被通知对象.</li>
<li>代理(Proxy): 向目标对象应用通知后创建的对象</li>
<li>切入点(PointCut): 切面通知 执行的”地点”的定义</li>
<li>连接点(JoinPoint): 与切入点匹配的执行点</li>
</ul>
<p><img src="file:///C:/%5CUsers%5C25778%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200627195527701.png" alt="image-20200627195527701"></p>
<p><strong>image-20200627195527701</strong></p>
</blockquote>
<h3 id="AOP重要性："><a href="#AOP重要性：" class="headerlink" title="AOP重要性："></a>AOP重要性：</h3><p>aop将公共业务（日志，安全）和领域业务结合。公共业务可以重复使用，程序猿更专注与领域业务 本质动态代理</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote>
<p><a href="https://sunxinan12138.github.io/2020/05/27/Spring%E7%9A%84AOP%E5%92%8CIOC/[https://sunxinan12138.github.io/2020/06/05/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/](https://sunxinan12138.github.io/2020/06/05/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/)">反射机制</a> 需要了解一下</p>
</blockquote>
<ul>
<li>哪些方法不能被AOP增强</li>
</ul>
<ol>
<li>基于JDK代理，除public外的其他所有方法，包括public static也不能被增强</li>
<li>基于CGLIB代理，由于其通过生成目标类子类的方式来增强，因此不能被子类继承的方法都不能被增强，private、static、final 方法</li>
</ol>
<h4 id="使用Spring原生接口方式-和JDK动态代理模式很像"><a href="#使用Spring原生接口方式-和JDK动态代理模式很像" class="headerlink" title="使用Spring原生接口方式(和JDK动态代理模式很像)"></a>使用Spring原生接口方式(和JDK动态代理模式很像)</h4><ol>
<li><p>核心配置文件</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.SpringAOP.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> // 被切入的业务</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.SpringAOP.MyLog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> // 切入的业务</span><br><span class="line"> <span class="comment">&lt;!-- 配置的(..) 括号是方法 .. 任意参数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 切入点  expression: (返回类型  切入的位置(包.类.方法(参数类型)))--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.SpringAOP.UserServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 哪个类切入哪个切入点(log) --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>日志类</p>
</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLog</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>载入配置文件</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;aopConfig.xml&quot;</span>); <span class="comment">// 加载xml方式</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>); <span class="comment">// Spring调用</span></span><br><span class="line">userService.add();</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring的五种Advice</li>
</ul>
<table>
<thead>
<tr>
<th align="left">通知类型</th>
<th align="left">连接点</th>
<th align="left">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前置通知</td>
<td align="left">方法前</td>
<td align="left">aop.MethodBeforeAdvice</td>
</tr>
<tr>
<td align="left">后置通知</td>
<td align="left">方法后</td>
<td align="left">aop.AfterReturnAdvice</td>
</tr>
<tr>
<td align="left">环绕通知</td>
<td align="left">方法前后</td>
<td align="left">intercept.MethodInterceptor</td>
</tr>
<tr>
<td align="left">异常抛出通知</td>
<td align="left">方法抛出异常</td>
<td align="left">aop.ThrowsAdvice</td>
</tr>
<tr>
<td align="left">引介通知</td>
<td align="left">类中增加新的方法属性</td>
<td align="left">aop.IntroductionInterceptor</td>
</tr>
</tbody></table>
<h4 id="使用自定义类实现"><a href="#使用自定义类实现" class="headerlink" title="使用自定义类实现"></a>使用自定义类实现</h4><ol>
<li>先自定义一个类</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDiyLog</span> &#123; <span class="comment">// 自定义类当做切面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">befor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>配置文件</li>
</ol>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 注入Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.SpringAOP.MyDiyLog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.SpringAOP.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  aop 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  配置切面的ref  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;log&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.SpringAOP.UserServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;befor&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用注解方式实现"><a href="#使用注解方式实现" class="headerlink" title="使用注解方式实现"></a>使用注解方式实现</h4><ol>
<li>配置文件:</li>
</ol>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 三: 注解 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 两种方式 </span></span><br><span class="line"><span class="comment">    1. jdk自己的(false)(默认就是这个) </span></span><br><span class="line"><span class="comment">    2. cglib(true) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.AnnotationMethod.MyLogAnnotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>注解部分</li>
</ol>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.SpringAOP.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">befor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;befor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>其他的相比第一种没有变化</p>
</li>
<li><h3 id="六种增强类型"><a href="#六种增强类型" class="headerlink" title="六种增强类型"></a>六种增强类型</h3><ol>
<li>@Before 前置增强，相当于BeforeAdvice</li>
<li>@AfterReturning 后置增强，相当于AfterReturningAdvice</li>
<li>@Around 环绕增强，相当于MethodInterceptor</li>
<li>@AfterThrowing 抛出增强，相当于ThrowsAdvice</li>
<li>@AfterFinal增强，不管抛出异常还是正常退出，都会执行，没有对应的增强接口，一般用于释放资源</li>
<li>@DeclareParents 引介增强，相当于IntroductionInterceptor</li>
</ol>
</li>
</ol>
<blockquote>
<p><a href="https://sunxinan12138.github.io/2020/05/27/Spring%E7%9A%84AOP%E5%92%8CIOC/#">Spring事务运用</a></p>
</blockquote>
<h1 id="加一个MVC的"><a href="#加一个MVC的" class="headerlink" title="加一个MVC的"></a>加一个MVC的</h1><p><img src="https://i.loli.net/2020/10/02/VD3Xah5SyBOoKsQ.png" alt="mvc工作原理"></p>
<p><strong>mvc工作原理</strong></p>
<ol>
<li>客户端<strong>请求</strong>到DispatcherServlet</li>
<li>DispatcherServlet根据请求地址查询映射处理器<strong>HandleMapping，获取Handler</strong></li>
<li>请求<strong>HandlerAdapter执行Handler</strong></li>
<li><strong>执行相应的Controller方法</strong>，执行完毕<strong>返回ModelAndView</strong></li>
<li>通过<strong>ViewResolver解析视图</strong>，<strong>返回View</strong></li>
<li><strong>渲染视图</strong>，将<strong>Model数据转换为Response响应</strong></li>
<li>将<strong>结果返回给客户端</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2，3 两步都在DispatcherServlet -&gt; doDispatch中进行处理</span><br></pre></td></tr></table></figure>

<h2 id="Spring-MVC-架构-与原生Servlet区别-请求处理流程"><a href="#Spring-MVC-架构-与原生Servlet区别-请求处理流程" class="headerlink" title="Spring MVC 架构 | 与原生Servlet区别 | 请求处理流程"></a>Spring MVC 架构 | 与原生Servlet区别 | 请求处理流程</h2><ol>
<li>原生的一个请求对应一个servlet 框架(SpringMVC框架 简写) 由前端控制器去寻找对应的Controller</li>
<li>框架封装了一些数据</li>
</ol>
<p><a href="https://sunxinan12138.github.io/2020/05/27/Spring%E7%9A%84AOP%E5%92%8CIOC/">Spring注解 boot 会很频繁用到</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
