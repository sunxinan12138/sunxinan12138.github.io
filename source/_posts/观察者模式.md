---
title: 观察者模式
author: 熙男
date: 2021-07-25 17:16:58
categories:
tags:
---

# 观察者模式

## 观察者例子

一个气象台 想要**几个显示器** , 数据从**weather对象**中获取 如果 weather 数据更新 显示器要更新对应数据

> 显示器就是观察者 而气象台的数据weather 就是通知者(**主题对象**)





java

```java
/**
 * @author SunJusong
 * 观察者部分
 * @date 2020年 08月27日 23:17:48
 */
public class Obs implements Observer, DisPlay {
    float temp; // 温度
    float humidity; // 湿度
    float pressur; // 气压
    private Subject weather; // 天气对象

    public Obs(Subject sub) {
        this.weather = sub;
        sub.RegistObserver(this);
    }

    // 实现update 方法来显示
    @Override
    public void update(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressur = pressure;
        display();
    }

    @Override
    public void display() {
        System.out.println(temp + "==" + humidity + "==" + pressur);
    }
}
// -----------------观察者接口-------------------------
interface Observer {
    void update(float temp, float humidity, float pressure);
}

// -----------------显示功能接口-----------------------
interface DisPlay {
    void display();
}
// ---------------主方法--------------------------
class MainDemo {
    public static void main(String[] args) {
        // 创建主体对象
        Weather weather = new Weather();
        // 创建观察者 当然 也可以是多个不同的类
        Obs obs1 = new Obs(weather);
        Obs obs2 = new Obs(weather);
        Obs obs3 = new Obs(weather);
        weather.setMessage(12, 12, 12);
        weather.RemoveObserver(obs2);
        weather.setMessage(13, 13, 13);

    }
}
```





java

```java
/**
 * @author SunJusong
 * 主体对象部分
 * @date 2020年 08月27日 23:14:29
 */
public class Weather implements Subject {
    private List<Observer> observers; // 观察者列表
    private float temp;
    private float humidity;
    private float pressur;

    public Weather() {
        this.observers = new ArrayList<>();
    }

    @Override
    public void RegistObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void RemoveObserver(Observer o) {
        int i = observers.indexOf(o);
        observers.remove(i);
    }

    @Override
    public void notifyObserver() {
        for (Observer observer : observers) {
            observer.update(temp, humidity, pressur);
        }
    }

    /* jdk自带 
    观察者要继承Observable 观察者实现 Observer
     public void change() {
         // 封裝了通知和changed方法
         setChanged();
         notifyObservers();
     }

     public float getTemp() {
         return temp;
     }

     public float getHumidity() {
         return humidity;
     }

     public float getPressur() {
         return pressur;
     }
 */
    // 传入更新的数值
    public void setMessage(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressur = pressure;
        notifyObserver();
    }
}
// 主体对象接口
interface Subject {
    // 注册观察者
    void RegistObserver(Observer o);
    // 移除观察者
    void RemoveObserver(Observer o);
    // 更新信息
    void notifyObserver();
}
```



![image.png](https://i.loli.net/2020/08/18/GRxYKhX5bvAluLs.png)

**image.png**



## 观察者模式

> 定义了一种一对多的依赖关系, 让多个观察者对象同时监听某个**主题对象**. 这个主体对象发生变化时会通知所有的**观察者**, 使得他们自己可以更新自己



![image.png](https://i.loli.net/2020/08/18/LPSEpFO87CcHmkB.png)

**image.png**





## 观察者监听

观察者list

被观察者event

初始化和成就事件触发检测需要被移除的观察者





```
事件监听list(在初始化时监听) -- 当事件触(发送时间event.fire) --  obs类根据条件遍历发送消息到对应的对象 -- 对象接收时间判断.... 是否取消监听...
```

## java中lambda实现委托

### 委托

委托是一种引用方法类型, 一旦为委托分配了方法,委托与该方法有完全相同的行为. 委托方法使用和其他方法一样.委托可以看做对函数的抽象, 是函数的”类”, 委托的实例代表的一个具体的函数,

委托能搭载的方法必须有相同的参数列表和返回值 和java8中方法引用的实现方式相同

**代码实现:**





java

```java
public class MyDelegate {
    private MyAction<Integer> delegate; // 委托事件

    // --------主方法--------------
    public static void main(String[] args) {
        // 创建实例
        MyDelegate delegate = new MyDelegate();
        // 一:
        delegate.delegate = (Integer i) -> {
            System.out.println(i);
        };
        delegate.delegate.action(3);
        // 二:
        delegate.delegate = MyDelegate::action;
        delegate.delegate.action(3);
    }

    private static void action(Integer i) {
        System.out.println("::" + "--" + i);
    }
}

// ------------------委托类型接口(消费形)------------------
interface MyAction<T> {
    void action(T t);
}
// 可以使用委托实现观察者模式
```
